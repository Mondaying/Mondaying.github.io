<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>梅森旋转算法(MT19937)</title>
      <link href="/2025/04/19/%E6%A2%85%E6%A3%AE%E6%97%8B%E8%BD%AC%E7%AE%97%E6%B3%95-MT19937/"/>
      <url>/2025/04/19/%E6%A2%85%E6%A3%AE%E6%97%8B%E8%BD%AC%E7%AE%97%E6%B3%95-MT19937/</url>
      
        <content type="html"><![CDATA[<p>​        偶遇题目，拼尽全力无法战胜，故来学习</p><blockquote><p><a href="https://zh.wikipedia.org/wiki/%E4%BC%AA%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90%E5%99%A8">wiki 伪随机数</a></p><p><a href="https://blog.csdn.net/deephub/article/details/143423835">随机性、熵与随机数生成器:解析伪随机数生成器（PRNG）和真随机数生成器（TRNG）-CSDN博客</a></p><p><a href="https://blog.csdn.net/qq_39780701/article/details/140279301">【密码学】流密码的基本概念-CSDN博客</a></p><p><a href="https://blog.csdn.net/m0_73725283/article/details/140613749">MT19937_mt19937predictor-CSDN博客</a></p><p><a href="https://www.anquanke.com/post/id/205861#h3-9">浅析MT19937伪随机数生成算法-安全KER - 安全资讯平台</a></p><p><a href="https://www.cnblogs.com/CHNmuxii/p/12232475.html#autoid-0-0-0">你没听过的梅森旋转算法 - CHNmuxii - 博客园</a></p><p><a href="https://hasegawaazusa.github.io/mersenne-twister-note.html#%E7%AE%97%E6%B3%95%E6%8F%8F%E8%BF%B0">Mersenne Twister 梅森旋转算法笔记</a> 这一篇很详细</p></blockquote><h2 id="相关知识"><a href="#相关知识" class="headerlink" title="相关知识"></a>相关知识</h2><p>​        既然聊到随机数生成了，就会想到PRNG嘛，所以我觉得顺带联系一下流密码会更透彻一点，下面是一些联系知识点，可跳过直接看梅森旋转算法介绍。</p><h3 id="流密码"><a href="#流密码" class="headerlink" title="流密码"></a>流密码</h3><p>​        流密码是一种对称密码，一般逐字节或逐比特处理信息（比如说采用异或加密）。现有的流密码是在<strong>一次一密</strong>的思想基础上发展来的。</p><p>​        一次一密（One-Time Pad，简称OTP）也是一种流密码算法，它被认为是理论上最安全的加密算法之一，它必须遵循以下原则：</p><ol><li>密钥必须和明文一样<strong>长</strong></li><li>密钥必须是真正<strong>随机</strong>的（我们可以采用<strong>真随机数发生器TRNG</strong>来生成）</li><li>密钥必须只使用<strong>一次</strong></li><li>密钥必须<strong>保密</strong>（感觉有点废话）</li></ol><p>​    看上面这几条原则，很容易就可以想到密钥的管理是困难的。密钥和明文一样长，且每个都只使用一次，密钥的存储和共享十分困难，这在实际运用上是不现实的</p><p>​        于是人们在试图解决一次一密密钥管理和长度的问题时，想到了能不能有一种方法，只需要提供一小段密钥，就可以生成加密明文所需要的所有密钥。流密码就在此思想上发展。</p><p>​        在流密码中，一个小的密钥（通常称为<strong>种子</strong>或初始向量）被用来通过一个<strong>伪随机数生成器（PRNG）</strong>产生一个与明文等长的<strong>伪随机密钥流</strong>。这个密钥流然后与明文进行<strong>异或</strong>操作，生成密文。同样，解密过程就是用相同的密钥流对密文进行异或，恢复出明文。</p><p>​        像我们学过的比较简单的流密码RC4、LCG(也都是PRNG生成算法)都是采用这种思想。(我的理解是，一种流密码，其实就是一种PRNG生成算法，毕竟加密一般就是异或嘛，所以还是要看伪随机数的生成)</p><h3 id="PRNG"><a href="#PRNG" class="headerlink" title="PRNG"></a>PRNG</h3><p>​        我们将要了解的这个算法，其实就是一种用于生成PRNG（即伪随机数生成器 pseudo random number generator）的一种算法。与PRNG相对的就是TRNG(真随机数生成器)，这里不做过多介绍。</p><p>​        <font style="color:rgb(32, 33, 34);">PRNG可以使用</font><strong><font style="color:rgb(32, 33, 34);">随机种子</font></strong>（和种子状态）从任意初始状态启动，使用同一状态进行初始化时，它将始终生成相同的<strong>序列</strong>。PRNG的周期定义为：序列的无重复前缀长度在所有起始状态中的最大值。周期受状态数的限制，通常用比特位数表示。然而，每增加一个比特位，周期长度就可能增加一倍，所以构建周期足够长的PRNG对于许多实际应用程序来说是很容易的。(感觉有点绕，但是目前只要知道，用相同的seed，会生成相同的序列就行了)</p><p>​        PRNG所生成的序列，其特性近似于随机数序列。具有以下特点：</p><ol><li>确定性，相同的种子值会生成相同的序列</li><li>高效性，PRNG能快速产生大量随机数</li><li>周期性，PRNG会在一定周期后重复，但是现代PRNG算法这个周期是很长的</li></ol><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><p>目前通用的伪随机数生成器主要有</p><ul><li>线性同余生成器，LCG</li><li>线性回归发生器</li><li>Mersenne Twister (梅森旋转算法)</li><li>xorshift generators</li><li>WELL family of generators</li><li>Linear feedback shift register，LFSR，线性反馈移位寄存器</li></ul><p>​        后面翻资料的时候发现还有一种<strong>密码学PRNG(CSPRNG)</strong>：密码学伪随机数生成器(Cryptographically Secure Pseudo-Random Number Generator, CSPRNG)，只能后面再去了解了。LFSR之前做题也有遇到，只能又鸽了</p><p>​        知道这样一个框架后，就可以进入重头戏，PRNG的一种算法——梅森旋转算法</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>​        <font style="color:rgb(51, 51, 51);">梅森旋转算法，是由松本真和西村拓士在1997年开发的一种能快速产生优质随机数的算法。</font></p><font style="color:rgb(51, 51, 51);">        它之所以叫做是梅森旋转算法是因为它的循环节是</font>$ 2^{19937}-1 $<font style="color:rgb(51, 51, 51);">，这个叫做梅森素数。这个循环节(就是循环周期，理解为经过多少次后会回到第一次的随机数)是很长的，这也是为什么这个算法可以产生优质的随机数。</font><p>​        常见的两种形式为基于32位的MT19937-32和基于64位的MT19937-64(其实是状态向量里整数的位数的区别)，而python中的random库主要用的还是MT19937-32，所以我们主要理解一下这个</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>​        <font style="color:rgba(0, 0, 0, 0.87);">MT19937 算法可分为三个部分</font></p><ol><li><font style="color:rgba(0, 0, 0, 0.87);">初始化</font></li><li><font style="color:rgba(0, 0, 0, 0.87);">旋转状态</font></li><li><font style="color:rgba(0, 0, 0, 0.87);">提取伪随机数</font></li></ol><font style="color:rgba(0, 0, 0, 0.87);">其中 32 位的 MT19937 Python 代码实现为：</font><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">def _int32(x):</span><br><span class="line">    return int(0xFFFFFFFF &amp; x)</span><br><span class="line"></span><br><span class="line">class MT19937:</span><br><span class="line">    # 初始化</span><br><span class="line">    def __init__(self, seed):</span><br><span class="line">        self.mt = [0] * 624</span><br><span class="line">        self.mt[0] = seed</span><br><span class="line">        self.mti = 0</span><br><span class="line">        for i in range(1, 624):</span><br><span class="line">            self.mt[i] = _int32(1812433253 * (self.mt[i - 1] ^ self.mt[i - 1] &gt;&gt; 30) + i)</span><br><span class="line"></span><br><span class="line">    # 提取伪随机数</span><br><span class="line">    def extract_number(self):</span><br><span class="line">        if self.mti == 0:</span><br><span class="line">            self.twist()</span><br><span class="line">        y = self.mt[self.mti]</span><br><span class="line">        y = y ^ y &gt;&gt; 11</span><br><span class="line">        y = y ^ y &lt;&lt; 7 &amp; 2636928640</span><br><span class="line">        y = y ^ y &lt;&lt; 15 &amp; 4022730752</span><br><span class="line">        y = y ^ y &gt;&gt; 18</span><br><span class="line">        self.mti = (self.mti + 1) % 624</span><br><span class="line">        return _int32(y)</span><br><span class="line"></span><br><span class="line">    # 旋转状态</span><br><span class="line">    def twist(self):</span><br><span class="line">        for i in range(0, 624):</span><br><span class="line">            y = _int32((self.mt[i] &amp; 0x80000000) + (self.mt[(i + 1) % 624] &amp; 0x7fffffff))</span><br><span class="line">            self.mt[i] = (y &gt;&gt; 1) ^ self.mt[(i + 397) % 624]</span><br><span class="line"></span><br><span class="line">            if y % 2 != 0:</span><br><span class="line">                self.mt[i] = self.mt[i] ^ 0x9908b0df</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​        其实如果简单过一遍的话，还是好理解的，就是根据一个seed进行初始化624的状态向量，然后旋转（怎么旋转的有点扣不懂了，浅放一下），提取，每624次提取后再旋转</p><h2 id="Randon库"><a href="#Randon库" class="headerlink" title="Randon库"></a>Randon库</h2><p>​        了解了基本的原理后，我们来看看Python中random库的诸如getrandbits这些函数的具体用法和小特性</p><p>​        python中内置的Random类就是采用了MT19937算法，每次生成的随机数都是32位的。getrandbits(32)方法可以获得一个32位随机数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(random.getrandbits(<span class="number">32</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4027601637</span></span><br></pre></td></tr></table></figure><p>​        random.seed(a)：设置初始化随机种子，可输出相同随机数序列；a取整数或浮点数，不设置时默认以系统时间为种子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(random.getrandbits(<span class="number">32</span>))</span><br><span class="line"></span><br><span class="line">random.seed(<span class="number">32</span>)</span><br><span class="line"><span class="built_in">print</span>(random.getrandbits(<span class="number">32</span>))</span><br><span class="line"></span><br><span class="line">random.seed(<span class="number">32</span>)</span><br><span class="line"><span class="built_in">print</span>(random.getrandbits(<span class="number">32</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 863923632</span></span><br><span class="line"><span class="comment"># 332524003</span></span><br><span class="line"><span class="comment"># 332524003</span></span><br></pre></td></tr></table></figure><p>​        getrandbits(8)获得的是32位随机数的前8位，而在这之后再次使用getrandbits(8)获取的是下一个32位随机数的前8位</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">random.seed(<span class="number">32</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(random.getrandbits(<span class="number">32</span>))[<span class="number">2</span>:])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(random.getrandbits(<span class="number">32</span>))[<span class="number">2</span>:])</span><br><span class="line"></span><br><span class="line">random.seed(<span class="number">32</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(random.getrandbits(<span class="number">8</span>))[<span class="number">2</span>:])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(random.getrandbits(<span class="number">8</span>))[<span class="number">2</span>:])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 13d1e9e3</span></span><br><span class="line"><span class="comment"># ed2ef1c1</span></span><br><span class="line"><span class="comment"># 13</span></span><br><span class="line"><span class="comment"># ed</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​        getrandbits(64)则是两个32位随机数的拼接，倒序拼接</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">random.seed(<span class="number">32</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(random.getrandbits(<span class="number">32</span>))[<span class="number">2</span>:])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(random.getrandbits(<span class="number">32</span>))[<span class="number">2</span>:])</span><br><span class="line"></span><br><span class="line">random.seed(<span class="number">32</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(random.getrandbits(<span class="number">64</span>))[<span class="number">2</span>:])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 13d1e9e3</span></span><br><span class="line"><span class="comment"># ed2ef1c1</span></span><br><span class="line"><span class="comment"># ed2ef1c113d1e9e3</span></span><br></pre></td></tr></table></figure><p>​        还需要注意，向高位生长时其实跟小于32位一样是从高位开始取。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">random.seed(<span class="number">32</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(random.getrandbits(<span class="number">32</span>))[<span class="number">2</span>:])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(random.getrandbits(<span class="number">32</span>))[<span class="number">2</span>:])</span><br><span class="line"></span><br><span class="line">random.seed(<span class="number">32</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(random.getrandbits(<span class="number">40</span>))[<span class="number">2</span>:])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 13d1e9e3</span></span><br><span class="line"><span class="comment"># ed2ef1c1</span></span><br><span class="line"><span class="comment"># ed13d1e9e3</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​        getstate()的用法（相对应的是setstate()）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line">rng = random.Random()</span><br><span class="line">rng.seed(<span class="number">32</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(rng.getstate())</span><br><span class="line"></span><br><span class="line"><span class="comment"># (3, (2147483648, 2981664610, 82649134, 1807122176, 302157071, 755388178, 2623462981, 851257013, 216974233, 1073938670, 323755660, 2384483883, 1744767122, 3695390407, 52014645, 459371615, 3906083420, 609507109, 610977697, 567019764, 2613493387, 916367194, 1292648220, 4281430835, 603958090, 1085002086, 1076867180, 801231231, 3803349301, 2028653073, 1458283220, 1919772958, 2834427473, 145396400, 3423484661, 652682164, 18482579, 482317922, 500545892, 4262442629, 259966470, 1065747013, 4129843740, 117008655, 3356700754, 405228818, 2146344620, 904962943, 2335240969, 3483444628, 2812342939, 243772448, 4052954505, 974896576, 293524298, 2204846868, 3801875453, 1589429472, 3392403291, 1025270310, 1005772097, 3550127576, 1790752761, 1606443774, 1328005442, 3963248671, 2816323641, 3138536632, 4291349728, 1196288615, 3153400508, 3934718159, 2790896303, 2028649333, 1451545150, 1014986440, 4186142173, 4086045459, 661114379, 2368957789, 2266586516, 2421168059, 1870394660, 1982958283, 3465622627, 609333992, 2700947100, 4114189243, 22625788, 3176992568, 896225921, 2344820312, 922443065, 2853383903, 3030451356, 658221849, 3254595837, 3668447465, 3208004282, 1804923500, 3882158971, 84112801, 3275442855, 1713196384, 2078103568, 1624721945, 1420515015, 80757766, 3036199207, 3175701083, 1288786439, 3231940832, 10031906, 91060640, 2788052507, 2104768957, 2495796052, 1167365945, 839068315, 3781468505, 313744802, 2615503802, 1872999469, 3542740129, 3517369250, 3966272654, 3439320817, 55090350, 1933659639, 2179729091, 3112466017, 1175975703, 1828407681, 105582466, 3589634096, 2282048609, 2446991225, 2212241085, 1502806219, 1438997647, 2921640279, 3736656255, 2894637459, 351604790, 427967470, 3097656137, 2565447163, 2472848566, 3662806121, 2837288467, 1359216601, 1211006512, 2485534644, 3645695355, 1767676058, 601956087, 1543053032, 204820565, 4133788867, 1060908608, 3855049815, 4015536910, 2971584352, 56962322, 3546815736, 3310579232, 1181351349, 581872004, 1104445211, 3199855229, 584304768, 2857640007, 3963080308, 1918026254, 3557712257, 717957697, 2605576760, 2839901208, 4041967724, 3871933765, 3579478960, 3561335339, 3496241806, 3323555189, 4199989126, 443971454, 2759899833, 1251185906, 585248642, 842743147, 1391919910, 2861045395, 816948222, 198625549, 3781980984, 3239677416, 2046972831, 1850626891, 468850643, 3740899351, 1224863120, 1845712388, 1342062971, 768279889, 1567226079, 2584712143, 1114840832, 3761226868, 2193432879, 2374470972, 2577173949, 1557186029, 3873247469, 957872477, 2394080002, 4023827162, 4188217292, 839158856, 2090482280, 53463168, 83974694, 1724965904, 650741183, 2778336473, 4277063498, 1456658756, 456107739, 3462352155, 1575608861, 4018132647, 2432365576, 2715236919, 1225680973, 2863498653, 674890329, 3473172628, 411076689, 3215056284, 3821524280, 1184977003, 2582060598, 2527134872, 3351823467, 3172733736, 4048514431, 2671275640, 3193496925, 2433639562, 3928579687, 2813396580, 3812638932, 1416650140, 3600892096, 3232545207, 1250740885, 3363297892, 2000437280, 3804682658, 2547870510, 3332317444, 3486657292, 2882851682, 1938388214, 3034661023, 3991043770, 3483788369, 1512472737, 1908682443, 1059047586, 2243622793, 3524945907, 2404115663, 990882311, 2471221882, 3072200400, 876342782, 3903939525, 3905347388, 1935550924, 2891758942, 3521138013, 3005767809, 2999009524, 1327279939, 1943800407, 640427466, 3084536079, 700645511, 1338782426, 2264697014, 938935645, 344738163, 2311466192, 1637326701, 1102012914, 4173606536, 802682715, 3063116242, 3802425104, 2724672801, 2230711586, 2413750001, 4255139566, 3954170358, 1302721114, 2732170767, 1139306538, 3695422750, 3547144070, 716263268, 4172405440, 3438102401, 2148842670, 3896935059, 2275750532, 2861664676, 93639066, 4103591988, 2522391420, 657968115, 144916106, 2437447734, 473423694, 2562322086, 1739841119, 3749273316, 2527951928, 2469057797, 2469057171, 3552507765, 2547872402, 2169450804, 2197564692, 1459768138, 1148433842, 2132426770, 2063580222, 2993639595, 508642970, 1492817956, 57022243, 1351740882, 3749501729, 314095794, 3322120215, 1519460267, 2045234971, 2675305001, 3648397390, 3619021619, 3851936312, 647782153, 655145155, 1223393823, 3845890350, 1510800397, 3675627882, 1029945969, 2378074523, 1455919460, 1838312376, 3370926044, 4196546489, 1274041036, 3016742944, 82756560, 3915887215, 4019075249, 2298314253, 3304259580, 1343841177, 607522726, 639997923, 1674712318, 2135847655, 3101388171, 63191086, 2770135294, 2530192008, 2188475789, 1620366947, 3038817640, 1241763876, 3979640425, 383261701, 2325895137, 2378407688, 3054432273, 1097038754, 773664257, 2762497941, 979233138, 1506650225, 2022134751, 1129927790, 3476182076, 3054136278, 2761190690, 1595650873, 1514097467, 509019484, 2990680402, 171266122, 5794339, 3046940969, 3816395130, 2115717995, 1940568737, 3289974461, 733344441, 3926583596, 321505248, 1874286757, 3682533796, 1274702259, 198520217, 828123087, 3368592821, 1591619265, 2494285061, 404073469, 3738926862, 953789241, 4032511973, 2460730661, 1012375673, 585792413, 2819670610, 2229887984, 2374016081, 2431497255, 3789681296, 670884029, 3903410055, 3762586428, 2450275213, 242955591, 3312815380, 2247560084, 3188866986, 2953117091, 3734162145, 641332960, 587712331, 2185195334, 3270498270, 584022697, 1311493692, 1706387626, 2402043314, 2473770888, 2342620662, 3005544869, 3816857950, 391899607, 2822448002, 3450091114, 3266591578, 2631029892, 1793928024, 3708130896, 372142539, 3386509210, 3916907799, 3042854929, 3735328056, 2874161759, 1844089759, 1882687817, 904490032, 1737874898, 3691589734, 3795674018, 717188390, 3880627804, 3296223810, 3177630739, 553466201, 2607251041, 2402207612, 3912741292, 3544977279, 679344905, 2421023657, 429467538, 2735205380, 1932519125, 2038123701, 2376985142, 1043259972, 193599666, 1050430870, 4175957367, 29365306, 1751954589, 2578680403, 3420562479, 4267733734, 467600736, 3311162776, 3037951919, 3926437922, 3165928232, 1232517126, 3257628202, 3895439459, 1616722311, 3027645040, 2550116418, 4220643369, 3627886577, 3578677455, 3395485167, 3339674257, 3765213326, 765805494, 482486297, 3480301331, 3955880588, 798768951, 3693847025, 420701721, 1151767317, 3914711615, 2577577392, 1080158294, 332747221, 1279867472, 2707768266, 2786128928, 3748455533, 3522857857, 2453723104, 2744868592, 1237637661, 2933112744, 1878673409, 1018701131, 4209888015, 263654486, 3017122881, 2691524399, 1053756612, 1187424032, 3257603881, 2352354616, 60236961, 2328160652, 152703480, 2630697922, 2689232765, 825147421, 1673724729, 1493962066, 897352027, 175335306, 4005774659, 2318883597, 519865390, 1913890232, 821345729, 2269093420, 1528572181, 4185395893, 2493530055, 40668990, 2034577100, 1920819529, 1646347693, 322244438, 693268627, 2444591237, 2081602764, 2292388262, 1550027624, 3878242529, 198232945, 1502012648, 2518060143, 824807254, 3067952308, 1842732054, 3065158519, 89344625, 1147397791, 3154513321, 3827308929, 2558819632, 2314588350, 3021440071, 3764176503, 2394771812, 3635650757, 755749977, 3880150197, 1483850587, 2144701659, 2299027958, 3229625002, 2941244074, 4105623027, 2342673337, 633689222, 2627198003, 3389683863, 425091459, 648407162, 402334000, 2345289546, 212958946, 4140303075, 1446126212, 1946371200, 3708392064, 2694950657, 3644622098, 3545174953, 3705151558, 392923605, 330618321, 3854576478, 3936935861, 767734276, 2853918368, 624), None)</span></span><br></pre></td></tr></table></figure><h2 id="考点"><a href="#考点" class="headerlink" title="考点"></a>考点</h2><p>​        既然说了是伪随机数，那就说明是有一定规律的，所以我们期望可以通过一些手段来预测随机数</p><h3 id="逆向extract-number"><a href="#逆向extract-number" class="headerlink" title="逆向extract_number"></a><font style="color:rgb(79, 79, 79);">逆向extract_number</font></h3><p>​        大概理解了一下就是将extract_number过程逆向，看了一遍后是理解了，但是让我复述一遍有点难，但是试着来吧</p><p>​        首先 <code>y = y ^ y &gt;&gt; 18</code>这一块，很明显是y和y右移18位后的结果异或，那么高位的18位就是没有变化的，所以我们可以把y_result右移18位后再和自己异或，就又复原了18位，依此类推就可以回退回去，大概是下图这样（图画的有点丑）</p><p><img src="https://cdn.nlark.com/yuque/0/2025/jpeg/42554774/1745040105636-a5ff049f-ad00-4de0-974a-d2c1d5a76ffe.jpeg" alt=""></p><p>代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">o = <span class="number">2080737669</span></span><br><span class="line"><span class="built_in">print</span>(o.bit_length())<span class="comment">#31</span></span><br><span class="line">y = o^o&gt;&gt;<span class="number">18</span></span><br><span class="line"><span class="comment"># 控制位移的次数</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">31</span>//<span class="number">18</span>):</span><br><span class="line">    y = y^(y&gt;&gt;<span class="number">18</span>)</span><br><span class="line"><span class="built_in">print</span>(y==o)</span><br><span class="line"><span class="comment">#如果o的位数大于36那么代码还需要做修改</span></span><br><span class="line"><span class="comment">#但是实际上y的大小应该是固定的，32位数，所以这段代码可以固定使用</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​        接着我们看<code>y = y ^ y &lt;&lt; 15 &amp; 4022730752</code>这个过程，y和 y左移15位与上4022730752 的结果进行异或，相当于<font style="color:rgb(79, 79, 79);">y_result的低位15位是原y与y左移15位（其实低位15位都是0）与上4022730752 的结果（图我画不出来，但是就是循环这个过程，低位15知道后再左移15位与上4022730752 ，就又可以知道15位，重复下去）</font></p><font style="color:rgb(79, 79, 79);">代码如下</font><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">o = <span class="number">2080737669</span></span><br><span class="line">y = o ^ o &lt;&lt; <span class="number">15</span> &amp; <span class="number">4022730752</span></span><br><span class="line">tmp = y</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span> // <span class="number">15</span>):</span><br><span class="line">    <span class="comment"># (y&lt;&lt;15)&amp;40022730752 每次可以恢复y的15位</span></span><br><span class="line">    y = tmp ^ y &lt;&lt; <span class="number">15</span> &amp; <span class="number">4022730752</span></span><br><span class="line"><span class="built_in">print</span>(y==o)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​        extract_number剩下的两个过程就是一样的分析过程了，这样extract_number就逆向完了</p><p>​        其他几个逆向过程实在扣不动了，放个总代码吧（放过自己）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MT19937Recover</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">unshiftRight</span>(<span class="params">self, x, shift</span>):</span><br><span class="line">        res = x</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">            res = x ^ res &gt;&gt; shift</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">unshiftLeft</span>(<span class="params">self, x, shift, mask</span>):</span><br><span class="line">        res = x</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">            res = x ^ (res &lt;&lt; shift &amp; mask)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">untemper</span>(<span class="params">self, v</span>):</span><br><span class="line">        v = <span class="variable language_">self</span>.unshiftRight(v, <span class="number">18</span>)</span><br><span class="line">        v = <span class="variable language_">self</span>.unshiftLeft(v, <span class="number">15</span>, <span class="number">0xefc60000</span>)</span><br><span class="line">        v = <span class="variable language_">self</span>.unshiftLeft(v, <span class="number">7</span>, <span class="number">0x9d2c5680</span>)</span><br><span class="line">        v = <span class="variable language_">self</span>.unshiftRight(v, <span class="number">11</span>)</span><br><span class="line">        <span class="keyword">return</span> v</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">go</span>(<span class="params">self, outputs, forward=<span class="literal">True</span></span>):</span><br><span class="line">        result_state = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">assert</span> <span class="built_in">len</span>(outputs) &gt;= <span class="number">624</span></span><br><span class="line"></span><br><span class="line">        ivals = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">624</span>):</span><br><span class="line">            ivals.append(<span class="variable language_">self</span>.untemper(outputs[i]))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(outputs) &gt;= <span class="number">625</span>:</span><br><span class="line">            challenge = outputs[<span class="number">624</span>]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">626</span>):</span><br><span class="line">                state = (<span class="number">3</span>, <span class="built_in">tuple</span>(ivals+[i]), <span class="literal">None</span>)</span><br><span class="line">                r = random.Random()</span><br><span class="line">                r.setstate(state)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> challenge == r.getrandbits(<span class="number">32</span>):</span><br><span class="line">                    result_state = state</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            result_state = (<span class="number">3</span>, <span class="built_in">tuple</span>(ivals+[<span class="number">624</span>]), <span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">        rand = random.Random()</span><br><span class="line">        rand.setstate(result_state)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> forward:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">624</span>, <span class="built_in">len</span>(outputs)):</span><br><span class="line">                <span class="keyword">assert</span> rand.getrandbits(<span class="number">32</span>) == outputs[i]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> rand</span><br><span class="line"></span><br><span class="line">mtc = MT19937Recover()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="randcrack库进行预测"><a href="#randcrack库进行预测" class="headerlink" title="randcrack库进行预测"></a>randcrack库进行预测</h3><p>​        python中的randcrack库为我们提供了预测的函数，只要我们输入624个32位的数，就可以进行预测</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random <span class="comment">#导入random库（Python内置了）</span></span><br><span class="line"><span class="keyword">from</span> randcrack <span class="keyword">import</span>  RandCrack</span><br><span class="line"><span class="comment">#你可以掷随机数种子来确保预测的有效性， 不过random预测的时候默认以当前时间作为随机数种子</span></span><br><span class="line">rc = RandCrack()<span class="comment">#实例化randcrack类</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">624</span>):<span class="comment">#循环624次</span></span><br><span class="line">    rc.submit(random.getrandbits(<span class="number">32</span>))<span class="comment">#每次循环提交一个32位random生成的随机数</span></span><br><span class="line"><span class="built_in">print</span>(random.getrandbits(<span class="number">64</span>))<span class="comment">#利用random库获取一个64位的随机数（你可以修改为任意位数）</span></span><br><span class="line"><span class="built_in">print</span>(rc.predict_getrandbits(<span class="number">64</span>))<span class="comment">#利用randcrack获取的随机数</span></span><br></pre></td></tr></table></figure><p>​        但是这个库有个缺点就是必须提交624次，少一次都不行，而且必须是32位的，多一位都不行，具体可以看看下面这篇博客，进行了测试</p><blockquote><p><a href="https://blog.51cto.com/u_16099213/6895353">https://blog.51cto.com/u_16099213/6895353</a></p></blockquote><h3 id="矩阵状态破解"><a href="#矩阵状态破解" class="headerlink" title="矩阵状态破解"></a>矩阵状态破解</h3><p>​        这个感觉特别巧妙，就是发现了最后的输出和初始状态之间的一个线性关系，然后通过矩阵求解</p><p>我们把初始状态state[i]表示为二进制</p><p>$ x_0x_1···x_{30}x_{31} $</p><p>然后我们把输出的随机数也用二进制表示</p><p>$ z_0z_1···z_{30}z_{31} $</p><p>二者之间存在以下关系</p><p><img src="https://cdn.nlark.com/yuque/0/2025/png/42554774/1745042510516-b614d70c-07ca-4288-856e-c5d7cc08f7a1.png" alt=""></p><p>真不知道这是怎么发现的，只能说太厉害了</p><p>那么在GF(2)域上存在一个矩阵使得x变为z</p><p>即$ XT=Z $</p><p>下面是代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">extract_number</span>(<span class="params">x</span>):</span><br><span class="line">    x ^^= x &gt;&gt; <span class="number">11</span></span><br><span class="line">    x ^^= (x &lt;&lt; <span class="number">7</span>) &amp; <span class="number">2636928640</span></span><br><span class="line">    x ^^= (x &lt;&lt; <span class="number">15</span>) &amp; <span class="number">4022730752</span></span><br><span class="line">    x ^^= x &gt;&gt; <span class="number">18</span></span><br><span class="line">    <span class="keyword">return</span> x &amp; <span class="number">0xffffffff</span></span><br><span class="line"></span><br><span class="line">T = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">    x = <span class="number">1</span> &lt;&lt; (<span class="number">31</span> - i)</span><br><span class="line">    x = extract_number(x)</span><br><span class="line">    T.append(x.digits(<span class="number">2</span>, padto=<span class="number">32</span>)[::-<span class="number">1</span>])</span><br><span class="line">T = matrix(GF(<span class="number">2</span>), T)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">untemper</span>(<span class="params">leak</span>):</span><br><span class="line">    Z = matrix(GF(<span class="number">2</span>), ZZ(leak).digits(<span class="number">2</span>, padto=<span class="number">32</span>)[::-<span class="number">1</span>])</span><br><span class="line">    X = T.solve_left(Z)</span><br><span class="line">    <span class="keyword">return</span> reduce(<span class="keyword">lambda</span> x, y: (ZZ(x) &lt;&lt; <span class="number">1</span>) + ZZ(y), <span class="built_in">list</span>(X[<span class="number">0</span>]))</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​         如果我们能拿到连续的 624 个输出（比如用 <code>random.getrandbits(32)</code> 连续取 624 次），就能：  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">state = []</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">624</span>):</span><br><span class="line">    output = random.getrandbits(<span class="number">32</span>)</span><br><span class="line">    state.append(untemper(output))</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>从而恢复初始状态，然后进行预测</p><p>​        然后在m1n9师傅博客上看到另一种脚本写法，思路应该是一样的，这里就直接搬过来喽</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">construct_a_row</span>(<span class="params">RNG</span>): </span><br><span class="line">    row = []</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">19968</span>//<span class="number">32</span>):</span><br><span class="line">        tmp = RNG.getrandbits(<span class="number">32</span>)</span><br><span class="line">        row += <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">bin</span>(tmp)[<span class="number">2</span>:].zfill(<span class="number">32</span>)))</span><br><span class="line">    <span class="keyword">return</span> row</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 构造线性方程组的矩阵 </span></span><br><span class="line">L = [] </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> trange(<span class="number">19968</span>): </span><br><span class="line">    state = [<span class="number">0</span>]*<span class="number">624</span>  <span class="comment"># MT19937使用624个32位整数作为状态 </span></span><br><span class="line">    <span class="comment"># 构造一个只有一位为1,其他都为0的序列 </span></span><br><span class="line">    temp = <span class="string">&quot;0&quot;</span>*i + <span class="string">&quot;1&quot;</span>*<span class="number">1</span> + <span class="string">&quot;0&quot;</span>*(<span class="number">19968</span>-<span class="number">1</span>-i) </span><br><span class="line">    <span class="comment"># 将这个序列分成624段,每段32位,转换为整数 </span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">624</span>): </span><br><span class="line">        state[j] = <span class="built_in">int</span>(temp[<span class="number">32</span>*j:<span class="number">32</span>*j+<span class="number">32</span>], <span class="number">2</span>) </span><br><span class="line">     </span><br><span class="line">    RNG = Random() </span><br><span class="line">    RNG.setstate((<span class="number">3</span>,<span class="built_in">tuple</span>(state+[<span class="number">624</span>]),<span class="literal">None</span>))</span><br><span class="line">    L.append(construct_a_row(RNG)) </span><br><span class="line"> </span><br><span class="line"><span class="comment"># 将L转换为GF(2)上的矩阵（二进制域） </span></span><br><span class="line">L = Matrix(GF(<span class="number">2</span>),L)</span><br><span class="line"><span class="built_in">print</span>(L.nrows(), L.ncols())</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">MT19937_re</span>(<span class="params">state</span>): </span><br><span class="line">    <span class="keyword">try</span>: </span><br><span class="line">        <span class="comment"># 构造目标向量R </span></span><br><span class="line">        R = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> state:</span><br><span class="line">            R += <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">bin</span>(i)[<span class="number">2</span>:].zfill(<span class="number">32</span>)))</span><br><span class="line">         </span><br><span class="line">        R = vector(GF(<span class="number">2</span>), R)</span><br><span class="line">        s = L.solve_left(R)  <span class="comment"># 这里可能会抛出异常 </span></span><br><span class="line">         </span><br><span class="line">        <span class="comment"># 将解转换为二进制字符串 </span></span><br><span class="line">        init = <span class="string">&quot;&quot;</span>.join(<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">str</span>,s))) </span><br><span class="line">        state = [] </span><br><span class="line">        <span class="comment"># 将解重新分割成624个32位整数 </span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">624</span>): </span><br><span class="line">            state.append(<span class="built_in">int</span>(init[<span class="number">32</span>*i:<span class="number">32</span>*i+<span class="number">32</span>],<span class="number">2</span>)) </span><br><span class="line"> </span><br><span class="line">        <span class="comment"># 创建新的RNG并设置恢复出的状态 </span></span><br><span class="line">        RNG1 = Random() </span><br><span class="line">        RNG1.setstate((<span class="number">3</span>,<span class="built_in">tuple</span>(state+[<span class="number">624</span>]),<span class="literal">None</span>)) </span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> RNG1</span><br><span class="line">         </span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e: </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;[-]<span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"> </span><br><span class="line">RNG = MT19937_re() <span class="comment"># 这里传入state</span></span><br></pre></td></tr></table></figure><p>详细可以上m1n9师傅博客查看</p><blockquote><p><a href="https://mi1n9.github.io/2025/04/11/MT19937/">MT19937</a></p></blockquote><p>暂时看到的就这么多了，其他的等之后补充了</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="Division（xyctf-2025）"><a href="#Division（xyctf-2025）" class="headerlink" title="Division（xyctf 2025）"></a>Division（xyctf 2025）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- encoding: utf-8 -*-</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">@File    :   server.py</span></span><br><span class="line"><span class="string">@Time    :   2025/03/20 12:25:03</span></span><br><span class="line"><span class="string">@Author  :   LamentXU </span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">import</span> random </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;----Welcome to my division calc----&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">menu:</span></span><br><span class="line"><span class="string">      [1]  Division calc</span></span><br><span class="line"><span class="string">      [2]  Get flag</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    choose = <span class="built_in">input</span>(<span class="string">&#x27;: &gt;&gt;&gt; &#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> choose == <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            denominator = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;input the denominator: &gt;&gt;&gt; &#x27;</span>))</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;INPUT NUMBERS&#x27;</span>)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        nominator = random.getrandbits(<span class="number">32</span>)</span><br><span class="line">        <span class="keyword">if</span> denominator == <span class="string">&#x27;0&#x27;</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;NO YOU DONT&#x27;</span>)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;nominator&#125;</span>//<span class="subst">&#123;denominator&#125;</span> = <span class="subst">&#123;nominator//denominator&#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="keyword">elif</span> choose == <span class="string">&#x27;2&#x27;</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            ans = <span class="built_in">input</span>(<span class="string">&#x27;input the answer: &gt;&gt;&gt; &#x27;</span>)</span><br><span class="line">            rand1 = random.getrandbits(<span class="number">11000</span>)</span><br><span class="line">            rand2 = random.getrandbits(<span class="number">10000</span>)</span><br><span class="line">            correct_ans = rand1 // rand2</span><br><span class="line">            <span class="keyword">if</span> correct_ans == <span class="built_in">int</span>(ans):</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;WOW&#x27;</span>)</span><br><span class="line">                <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;flag&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">f&#x27;Here is your flag: <span class="subst">&#123;f.read()&#125;</span>&#x27;</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&#x27;NOPE, the correct answer is <span class="subst">&#123;correct_ans&#125;</span>&#x27;</span>)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;INPUT NUMBERS&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Invalid choice&#x27;</span>)</span><br></pre></td></tr></table></figure><p>​        一道靶机题，<code>correct_ans = rand1 // rand2</code>这里告诉我们，要想得到flag，我们必须预测出11000位的数整除10000位数的结果，我们回头看<code>random.getrandbits(32)</code>就可以知道，我们有办法搞到624个32位结果，那么运用randcrack库很容易就可以进行预测，交互代码甚至是ai给我写的，解题代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> randcrack <span class="keyword">import</span> RandCrack</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动本地进程（若为远程服务，替换为remote(&#x27;host&#x27;, port)）</span></span><br><span class="line">proc = remote(<span class="string">&#x27;host&#x27;</span>, port)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化随机数破解器</span></span><br><span class="line"></span><br><span class="line">rc = RandCrack()</span><br><span class="line"><span class="comment"># 收集624个32位随机数样本</span></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">624</span>):</span><br><span class="line">    proc.sendlineafter(<span class="string">b&#x27;: &gt;&gt;&gt; &#x27;</span>, <span class="string">b&#x27;1&#x27;</span>)               <span class="comment"># 发送选项1（bytes格式）</span></span><br><span class="line">    proc.sendlineafter(<span class="string">b&#x27;input the denominator: &gt;&gt;&gt; &#x27;</span>, <span class="string">b&#x27;1&#x27;</span>)  <span class="comment"># 分母输入1</span></span><br><span class="line">    line = proc.recvline().decode().strip()         <span class="comment"># 接收输出并解析</span></span><br><span class="line">    numerator = <span class="built_in">int</span>(line.split(<span class="string">&#x27;//&#x27;</span>)[<span class="number">0</span>])</span><br><span class="line">    rc.submit(numerator)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 预测大随机数（使用predict_getrandbits）</span></span><br><span class="line">rand1 = rc.predict_getrandbits(<span class="number">11000</span>)  <span class="comment"># 直接预测11000位随机数</span></span><br><span class="line">rand2 = rc.predict_getrandbits(<span class="number">10000</span>)  <span class="comment"># 直接预测10000位随机数</span></span><br><span class="line">correct_ans = rand1 // rand2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交答案获取flag</span></span><br><span class="line">proc.sendlineafter(<span class="string">b&#x27;: &gt;&gt;&gt; &#x27;</span>, <span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">proc.sendlineafter(<span class="string">b&#x27;input the answer: &gt;&gt;&gt; &#x27;</span>, <span class="built_in">str</span>(correct_ans).encode())</span><br><span class="line"></span><br><span class="line">proc.interactive()</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">WOW</span></span><br><span class="line"><span class="string">Here is your flag: XYCTF&#123;3bb2de1f-5bb3-486a-8da4-d1df6629067b&#125;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>写了两三天总算写完，但是应该还是不全，之后看有空再修修补补吧，不过总算了解了这么一个东西吧，道阻且长捏</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> CTF </tag>
            
            <tag> Crypto </tag>
            
            <tag> 对称密码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2024 NewStar-Crypto复现</title>
      <link href="/2025/02/04/2024-NewStar-Crypto%E5%A4%8D%E7%8E%B0/"/>
      <url>/2025/02/04/2024-NewStar-Crypto%E5%A4%8D%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="week1"><a href="#week1" class="headerlink" title="week1"></a>week1</h1><h2 id="xor"><a href="#xor" class="headerlink" title="xor"></a>xor</h2><p><strong>题目</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> xor</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> bytes_to_long</span><br><span class="line"></span><br><span class="line">key = <span class="string">b&#x27;New_Star_CTF&#x27;</span></span><br><span class="line">flag=<span class="string">&#x27;flag&#123;*******************&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line">m1 = bytes_to_long(<span class="built_in">bytes</span>(flag[:<span class="number">13</span>], encoding=<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">m2 = flag[<span class="number">13</span>:]</span><br><span class="line"></span><br><span class="line">c1 = m1 ^ bytes_to_long(key)</span><br><span class="line">c2 = xor(key, m2)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;c1=&#x27;</span>,c1)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;c2=&#x27;</span>,c2)</span><br></pre></td></tr></table></figure><p><strong>考点</strong>：异或，pwn库里的xor()函数</p><p>只要了解一下异或运算就可以解决，运算法则为：0 ⊕ 0 = 0，1 ⊕ 0 = 1，0 ⊕ 1 = 1，1 ⊕ 1 = 0（同为 0，异为 1）</p><p>一个特点是p、q异或的结果与其中一个再进行一次异或就可以得到另一个</p><font style="color:rgb(60, 60, 60);">pwntools 中</font>的 xor()，它<font style="color:rgb(60, 60, 60);">可以将不同类型和长度的数据进行异或</font><p>题目将明文分成两部分m1和m2,分别和key进行了异或运算，只要再把c1、c2和key异或一次，结果合起来，就是flag，代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> xor</span><br><span class="line"><span class="comment">#The Python pwntools library has a convenient xor() function that can XOR together data of different types and lengths</span></span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> bytes_to_long,long_to_bytes</span><br><span class="line"></span><br><span class="line">key = <span class="string">b&#x27;New_Star_CTF&#x27;</span></span><br><span class="line"></span><br><span class="line">c1= <span class="number">8091799978721254458294926060841</span></span><br><span class="line">c2= <span class="string">b&#x27;;:\x1c1&lt;\x03&gt;*\x10\x11u;&#x27;</span></span><br><span class="line"></span><br><span class="line">m1 = c1 ^ bytes_to_long(key)<span class="comment"># 自带的异或符号^只能用于整数类型操作</span></span><br><span class="line">m2 = xor(key, c2)</span><br><span class="line">m1 = long_to_bytes(m1)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(m1+m2)</span><br><span class="line"><span class="comment"># flag&#123;0ops!_you_know_XOR!&#125;</span></span><br></pre></td></tr></table></figure><h2 id="Base"><a href="#Base" class="headerlink" title="Base"></a>Base</h2><p><strong>题目</strong></p><p>4C4A575851324332474E324547554B494A5A4446513653434E564D444154545A4B354D45454D434E4959345536544B474D5134513D3D3D3D</p><p><strong>考点</strong>：base系列编码</p><p>之前用的在线网站进行解码，但说实话，挺复杂，因为这个进行了好几个base系列的编码，看了官方wp后知道了CyberChef，用这个就可以一把梭哈</p><p><img src="https://cdn.nlark.com/yuque/0/2025/png/42554774/1736225714200-dffbceb2-0045-48d7-a5bb-8e100fcb1739.png" alt=""></p><p>看了官方wp后才想起来我对base编码其实了解到不太熟，看了之后才了解了编码原理</p><h2 id="一眼秒了"><a href="#一眼秒了" class="headerlink" title="一眼秒了"></a>一眼秒了</h2><p><strong>题目</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> serct <span class="keyword">import</span> flag</span><br><span class="line">p = getPrime(<span class="number">512</span>)</span><br><span class="line">q = getPrime(<span class="number">512</span>)</span><br><span class="line">n = p*q</span><br><span class="line">m = bytes_to_long(flag)</span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">c = powmod(m, e, n)</span><br><span class="line"><span class="built_in">print</span>(n)</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 52147017298260357180329101776864095134806848020663558064141648200366079331962132411967917697877875277103045755972006084078559453777291403087575061382674872573336431876500128247133861957730154418461680506403680189755399752882558438393107151815794295272358955300914752523377417192504702798450787430403387076153</span></span><br><span class="line"><span class="comment"># 48757373363225981717076130816529380470563968650367175499612268073517990636849798038662283440350470812898424299904371831068541394247432423751879457624606194334196130444478878533092854342610288522236409554286954091860638388043037601371807379269588474814290382239910358697485110591812060488786552463208464541069</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>考点</strong>：rsa，分解n</p><p>p和q都不算太大，直接用在线网站分解一下n，得到p、q后按RSA解密就行（求phi，然后求d）</p><p>但是补充一下yafu的用法，打开cmd，输入yafu-x64.exe，之后输入factor(需要分解的素数)，如果数比较大，就要放到txt里，记得回车，然后再从cmd里输入yafu-x64.exe “factor(@)” -batchfile D:\data.txt，每次用完会自动删除这个txt文件</p><p>有了p和q之后就没有难度了，rsa解密就行，代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">n= <span class="number">52147017298260357180329101776864095134806848020663558064141648200366079331962132411967917697877875277103045755972006084078559453777291403087575061382674872573336431876500128247133861957730154418461680506403680189755399752882558438393107151815794295272358955300914752523377417192504702798450787430403387076153</span></span><br><span class="line">c=<span class="number">48757373363225981717076130816529380470563968650367175499612268073517990636849798038662283440350470812898424299904371831068541394247432423751879457624606194334196130444478878533092854342610288522236409554286954091860638388043037601371807379269588474814290382239910358697485110591812060488786552463208464541069</span></span><br><span class="line">p=<span class="number">7221289171488727827673517139597844534869368289455419695964957239047692699919030405800116133805855968123601433247022090070114331842771417566928809956044421</span></span><br><span class="line">q=<span class="number">7221289171488727827673517139597844534869368289455419695964957239047692699919030405800116133805855968123601433247022090070114331842771417566928809956045093</span></span><br><span class="line"></span><br><span class="line">phi = (p-<span class="number">1</span>)*(q-<span class="number">1</span>)</span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">d = inverse(e,phi)</span><br><span class="line">m = <span class="built_in">pow</span>(c,d,n)</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(m))</span><br><span class="line"><span class="comment"># flag&#123;9cd4b35a-affc-422a-9862-58e1cc3ff8d2&#125;</span></span><br></pre></td></tr></table></figure><h2 id="Strange-King"><a href="#Strange-King" class="headerlink" title="Strange King"></a>Strange King</h2><p><strong>题目</strong></p><p>某喜欢抽锐刻 5 的皇帝想每天进步一些，直到他娶了个模，回到原点，全部白给😅 这是他最后留下的讯息：<code>ksjr&#123;EcxvpdErSvcDgdgEzxqjql&#125;</code>，flag 包裹的是可读的明文</p><p><strong>考点</strong>：变异凯撒</p><p>是凯撒密码的变形，把密文前四个字符和flag对比就会发现他们的ascii码值分别差了5、7、9、11（其实题目也提醒了锐刻5和每天进步一点，说明一开始偏移5，逐渐加2），然后取模，是为了防止超出范围（一开始我模没取对，想着是取ascii表的模，然后写不对，其实应该大写字母和小写字母分别取26，使其在各自的范围里）代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">txt = <span class="string">&#x27;ksjr&#123;EcxvpdErSvcDgdgEzxqjql&#125;&#x27;</span></span><br><span class="line">plain = <span class="string">&#x27;&#x27;</span></span><br><span class="line">i = <span class="number">5</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> txt:</span><br><span class="line">    <span class="keyword">if</span> j.islower():</span><br><span class="line">        plain = plain + <span class="built_in">chr</span>(<span class="number">97</span> + (<span class="built_in">ord</span>(j) - i - <span class="number">97</span>)%<span class="number">26</span>)</span><br><span class="line">    <span class="keyword">elif</span> j.isupper():</span><br><span class="line">        plain = plain + <span class="built_in">chr</span>(<span class="number">65</span> + (<span class="built_in">ord</span>(j) - i - <span class="number">65</span>)%<span class="number">26</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        plain = plain + j</span><br><span class="line">    i += <span class="number">2</span></span><br><span class="line"><span class="built_in">print</span>(plain)</span><br><span class="line"><span class="comment"># flag&#123;PleaseDoNotStopLearing&#125;</span></span><br></pre></td></tr></table></figure><h1 id="week2"><a href="#week2" class="headerlink" title="week2"></a>week2</h1><h2 id="这是几次方？-疑惑"><a href="#这是几次方？-疑惑" class="headerlink" title="这是几次方？ 疑惑"></a>这是几次方？ 疑惑</h2><p><strong>题目</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">flag = <span class="string">b&#x27;flag&#123;*****&#125;&#x27;</span></span><br><span class="line">p = getPrime(<span class="number">512</span>)</span><br><span class="line">q = getPrime(<span class="number">512</span>)</span><br><span class="line">n = p*q</span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line"></span><br><span class="line">m = bytes_to_long(flag)</span><br><span class="line">c = <span class="built_in">pow</span>(m, e, n)</span><br><span class="line"></span><br><span class="line">hint = p^e + <span class="number">10086</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;c =&quot;</span>, c)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;[n, e] =&quot;</span>, [n, e])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hint =&quot;</span>, hint)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">c = 36513006092776816463005807690891878445084897511693065366878424579653926750135820835708001956534802873403195178517427725389634058598049226914694122804888321427912070308432512908833529417531492965615348806470164107231108504308584954154513331333004804817854315094324454847081460199485733298227480134551273155762</span></span><br><span class="line"><span class="string">[n, e] = [124455847177872829086850368685666872009698526875425204001499218854100257535484730033567552600005229013042351828575037023159889870271253559515001300645102569745482135768148755333759957370341658601268473878114399708702841974488367343570414404038862892863275173656133199924484523427712604601606674219929087411261, 65537]</span></span><br><span class="line"><span class="string">hint = 12578819356802034679792891975754306960297043516674290901441811200649679289740456805726985390445432800908006773857670255951581884098015799603908242531673390</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>考点</strong>：异或符号的运算优先级</p><p>这道题需要清楚异或操作的优先级是低于乘除加减的，所有hint是p和e+10086的异或结果，这样就可以得到p，再用n整除得到q，然后就是RSA解密了，代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Utill.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line">c = <span class="number">36513006092776816463005807690891878445084897511693065366878424579653926750135820835708001956534802873403195178517427725389634058598049226914694122804888321427912070308432512908833529417531492965615348806470164107231108504308584954154513331333004804817854315094324454847081460199485733298227480134551273155762</span></span><br><span class="line">n = <span class="number">124455847177872829086850368685666872009698526875425204001499218854100257535484730033567552600005229013042351828575037023159889870271253559515001300645102569745482135768148755333759957370341658601268473878114399708702841974488367343570414404038862892863275173656133199924484523427712604601606674219929087411261</span></span><br><span class="line">hint = <span class="number">12578819356802034679792891975754306960297043516674290901441811200649679289740456805726985390445432800908006773857670255951581884098015799603908242531673390</span></span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">p = hint ^ <span class="number">10086</span> + e</span><br><span class="line">q= n//p</span><br><span class="line">phi = (q-<span class="number">1</span>)*(p-<span class="number">1</span>)</span><br><span class="line">d = gmpy2.invert(e,phi)</span><br><span class="line">m = <span class="built_in">pow</span>(c,d,n)</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(m))</span><br><span class="line"><span class="comment"># flag&#123;yihuo_yuan_lai_xian_ji_suan_liang_bian_de2333&#125;</span></span><br></pre></td></tr></table></figure><h2 id="Since-you-konw-something"><a href="#Since-you-konw-something" class="headerlink" title="Since you konw something"></a>Since you konw something</h2><p><strong>题目</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> xor</span><br><span class="line"><span class="comment"># The Python pwntools library has a convenient xor() function that can XOR together data of different types and lengths</span></span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> bytes_to_long</span><br><span class="line"></span><br><span class="line">key = ?? <span class="comment"># extremely short</span></span><br><span class="line">FLAG = <span class="string">&#x27;flag&#123;????????&#125;&#x27;</span></span><br><span class="line">c = bytes_to_long(xor(FLAG,key))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;c=&#123;&#125;&quot;</span>.<span class="built_in">format</span>(c))</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">c=218950457292639210021937048771508243745941011391746420225459726647571</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>考点</strong>：异或</p><p>这道题要再了解一下pwntools库里的xor函数，举个例子，我们进行xor(data, key)，那么data中的第一个字节（对应的ascii值，后面同理）会和key里的第一个字节进行异或，依此类推，当data的字节数超过key的长度时，key会从头开始重复使用，直到data中的数据全部处理完毕</p><p>从题目可以知道key很短，恰巧我们知道FLAG的前几个字节（falg），所以异或一下就可以知道key是’ns’，之后c和key再异或一次就可以知道flag了（对称性），代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> xor</span><br><span class="line"><span class="comment"># The Python pwntools library has a convenient xor() function that can XOR together data of different types and lengths</span></span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> bytes_to_long,long_to_bytes</span><br><span class="line"></span><br><span class="line">c=<span class="number">218950457292639210021937048771508243745941011391746420225459726647571</span></span><br><span class="line">FLAG = <span class="string">b&#x27;flag&#123;????????&#125;&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(c))</span><br><span class="line">c = long_to_bytes(c)</span><br><span class="line"><span class="built_in">print</span>(xor(c,FLAG))</span><br><span class="line">key = <span class="string">&#x27;ns&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(xor(c,key))</span><br><span class="line"><span class="comment"># flag&#123;Y0u_kn0w_th3_X0r_b3tt3r&#125;</span></span><br></pre></td></tr></table></figure><h2 id="茶里茶气"><a href="#茶里茶气" class="headerlink" title="茶里茶气"></a>茶里茶气</h2><p><strong>题目</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">flag = <span class="string">&quot;flag&#123;*****&#125;&quot;</span></span><br><span class="line"><span class="keyword">assert</span> <span class="built_in">len</span>( flag ) == <span class="number">25</span></span><br><span class="line"></span><br><span class="line">a = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> flag:</span><br><span class="line">    a += <span class="built_in">hex</span>(<span class="built_in">ord</span>(i))[<span class="number">2</span>:]</span><br><span class="line">l = <span class="built_in">int</span>(a,<span class="number">16</span>).bit_length()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;l  =&quot;</span> , l )</span><br><span class="line"></span><br><span class="line">v0 = <span class="built_in">int</span>(a,<span class="number">16</span>)&gt;&gt;(l//<span class="number">2</span>)</span><br><span class="line">v1 = <span class="built_in">int</span>(a,<span class="number">16</span>)-(v0&lt;&lt;(l//<span class="number">2</span>))</span><br><span class="line">p = getPrime(l//<span class="number">2</span>+<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">v2 = <span class="number">0</span></span><br><span class="line">derta = <span class="number">462861781278454071588539315363</span></span><br><span class="line">v3 = <span class="number">489552116384728571199414424951</span></span><br><span class="line">v4 = <span class="number">469728069391226765421086670817</span></span><br><span class="line">v5 = <span class="number">564098252372959621721124077407</span></span><br><span class="line">v6 = <span class="number">335640247620454039831329381071</span></span><br><span class="line"><span class="keyword">assert</span> v1 &lt; p <span class="keyword">and</span> v0 &lt; p <span class="keyword">and</span> derta &lt; p <span class="keyword">and</span> v3 &lt; p <span class="keyword">and</span> v4 &lt; p <span class="keyword">and</span> v5 &lt; p <span class="keyword">and</span> v6 &lt; p </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">    v1 += (v0+v2) ^ ( <span class="number">8</span>*v0 + v3 ) ^ ( (v0&gt;&gt;<span class="number">7</span>) + v4 ) ; v1 %= p</span><br><span class="line">    v0 += (v1+v2) ^ ( <span class="number">8</span>*v1 + v5 ) ^ ( (v1&gt;&gt;<span class="number">7</span>) + v6 ) ; v0 %= p</span><br><span class="line">    v2 += derta ; v2 %= p</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>( <span class="string">&quot;p  =&quot;</span> , p  )</span><br><span class="line"><span class="built_in">print</span>( <span class="string">&quot;v0 =&quot;</span> , v0 )</span><br><span class="line"><span class="built_in">print</span>( <span class="string">&quot;v1 =&quot;</span> , v1 )</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">l  = 199</span></span><br><span class="line"><span class="string">p  = 446302455051275584229157195942211</span></span><br><span class="line"><span class="string">v0 = 190997821330413928409069858571234</span></span><br><span class="line"><span class="string">v1 = 137340509740671759939138452113480</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><p><strong>考点</strong>：<font style="color:rgb(60, 60, 60);">TEA（Tiny Encryption Algorithm）加密算法</font></p><font style="color:rgb(60, 60, 60);">不知道是TEA加密算法也没有关系，因为逆推其实也很简单，如下，自己写一下就很清晰</font><p><img src="https://cdn.nlark.com/yuque/0/2025/jpeg/42554774/1736234814527-a03ceadd-3d09-4988-8361-ac5d3ea51057.jpeg" alt=""></p><font style="color:rgb(60, 60, 60);">把最终的V2求出来后把顺序反过来退回去就行，就改成减号，把起始的V0和V1求出来后，就可以求出来a，把a转十六进制，两位一个转字符就可以求出flag，代码如下</font><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">v2 = <span class="number">0</span></span><br><span class="line">delta = <span class="number">462861781278454071588539315363</span></span><br><span class="line">v3 = <span class="number">489552116384728571199414424951</span></span><br><span class="line">v4 = <span class="number">469728069391226765421086670817</span></span><br><span class="line">v5 = <span class="number">564098252372959621721124077407</span></span><br><span class="line">v6 = <span class="number">335640247620454039831329381071</span></span><br><span class="line">l  = <span class="number">199</span></span><br><span class="line">p  = <span class="number">446302455051275584229157195942211</span></span><br><span class="line">v0 = <span class="number">190997821330413928409069858571234</span></span><br><span class="line">v1 = <span class="number">137340509740671759939138452113480</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>( <span class="number">32</span> ):</span><br><span class="line">    v2 += delta ; v2 %= p</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">    v2 -= delta ; v2 %= p</span><br><span class="line">    v0 -= (v1+v2) ^ ( <span class="number">8</span>*v1 + v5 ) ^ ( (v1&gt;&gt;<span class="number">7</span>) + v6 ) ; v0 %= p</span><br><span class="line">    v1 -= (v0+v2) ^ ( <span class="number">8</span>*v0 + v3 ) ^ ( (v0&gt;&gt;<span class="number">7</span>) + v4 ) ; v1 %= p</span><br><span class="line"></span><br><span class="line">a = <span class="built_in">hex</span>((v0&lt;&lt;((l//<span class="number">2</span>))) + v1)[<span class="number">2</span>:]</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">flag = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(a),<span class="number">2</span>):</span><br><span class="line">    flag += <span class="built_in">chr</span>(<span class="built_in">int</span>(a[i:i+<span class="number">2</span>],<span class="number">16</span>))</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br><span class="line"><span class="comment"># flag&#123;f14gg9_te2_1i_7ea_7&#125;</span></span><br></pre></td></tr></table></figure><h2 id="Just-one-and-more-than-two"><a href="#Just-one-and-more-than-two" class="headerlink" title="Just one and more than two"></a>Just one and more than two</h2><p><strong>题目</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">flag = <span class="string">b&#x27;flag&#123;?????&#125;&#x27;</span></span><br><span class="line">m1 = bytes_to_long(flag[:<span class="built_in">len</span>(flag)//<span class="number">2</span>])</span><br><span class="line">m2 = bytes_to_long(flag[<span class="built_in">len</span>(flag)//<span class="number">2</span>:])</span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">p, q, r= (getPrime(<span class="number">512</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>))</span><br><span class="line">N=p*q*r</span><br><span class="line">c1 = <span class="built_in">pow</span>(m1, e, p)</span><br><span class="line">c2 = <span class="built_in">pow</span>(m2, e, N)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;p=<span class="subst">&#123;p&#125;</span>\nq=<span class="subst">&#123;q&#125;</span>\nr=<span class="subst">&#123;r&#125;</span>\nc1=<span class="subst">&#123;c1&#125;</span>\nc2=<span class="subst">&#123;c2&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">p=11867061353246233251584761575576071264056514705066766922825303434965272105673287382545586304271607224747442087588050625742380204503331976589883604074235133</span></span><br><span class="line"><span class="string">q=11873178589368883675890917699819207736397010385081364225879431054112944129299850257938753554259645705535337054802699202512825107090843889676443867510412393</span></span><br><span class="line"><span class="string">r=12897499208983423232868869100223973634537663127759671894357936868650239679942565058234189535395732577137079689110541612150759420022709417457551292448732371</span></span><br><span class="line"><span class="string">c1=8705739659634329013157482960027934795454950884941966136315983526808527784650002967954059125075894300750418062742140200130188545338806355927273170470295451</span></span><br><span class="line"><span class="string">c2=1004454248332792626131205259568148422136121342421144637194771487691844257449866491626726822289975189661332527496380578001514976911349965774838476334431923162269315555654716024616432373992288127966016197043606785386738961886826177232627159894038652924267065612922880048963182518107479487219900530746076603182269336917003411508524223257315597473638623530380492690984112891827897831400759409394315311767776323920195436460284244090970865474530727893555217020636612445</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>考点</strong>：欧拉函数</p><p>一道RSA题，flag被分成两部分分别进行加密，c1是m1通过e和p加密得到，c2是m2通过e和N加密得到，要求m1和m2就得求对应的d1和d2，只要了解一下欧拉函数就可以了，我们已知p、q、r，且他们都是素数，那么</p><p>$ phi(p) = p - 1 $</p><p>$ phi(N) = (p -1)(q - 1)(r - 1) $</p><p>再分别求一下e关于他们两个的逆元就可以得到d1和d2，后面就是RSA解密了，代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"></span><br><span class="line">p=<span class="number">11867061353246233251584761575576071264056514705066766922825303434965272105673287382545586304271607224747442087588050625742380204503331976589883604074235133</span></span><br><span class="line">q=<span class="number">11873178589368883675890917699819207736397010385081364225879431054112944129299850257938753554259645705535337054802699202512825107090843889676443867510412393</span></span><br><span class="line">r=<span class="number">12897499208983423232868869100223973634537663127759671894357936868650239679942565058234189535395732577137079689110541612150759420022709417457551292448732371</span></span><br><span class="line">c1=<span class="number">8705739659634329013157482960027934795454950884941966136315983526808527784650002967954059125075894300750418062742140200130188545338806355927273170470295451</span></span><br><span class="line">c2=<span class="number">1004454248332792626131205259568148422136121342421144637194771487691844257449866491626726822289975189661332527496380578001514976911349965774838476334431923162269315555654716024616432373992288127966016197043606785386738961886826177232627159894038652924267065612922880048963182518107479487219900530746076603182269336917003411508524223257315597473638623530380492690984112891827897831400759409394315311767776323920195436460284244090970865474530727893555217020636612445</span></span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">N = p*q*r</span><br><span class="line">d1 = gmpy2.invert(e,p-<span class="number">1</span>)</span><br><span class="line">d2 = gmpy2.invert(e,(p-<span class="number">1</span>)*(q-<span class="number">1</span>)*(r-<span class="number">1</span>))</span><br><span class="line">m1 = <span class="built_in">pow</span>(c1, d1, p)</span><br><span class="line">m2 = <span class="built_in">pow</span>(c2, d2, N)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(m1)+long_to_bytes(m2))</span><br><span class="line"><span class="comment"># flag&#123;Y0u_re4lly_kn0w_Euler_4nd_N3xt_Eu1er_is_Y0u!&#125;</span></span><br></pre></td></tr></table></figure><h1 id="week3"><a href="#week3" class="headerlink" title="week3"></a>week3</h1><h2 id="没e这能玩"><a href="#没e这能玩" class="headerlink" title="没e这能玩"></a><strong>没e这能玩</strong></h2><p><strong>题目</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> sympy</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"></span><br><span class="line">m = bytes_to_long(<span class="string">b&#x27;flag&#123;*****&#125;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p = getPrime(<span class="number">512</span>)</span><br><span class="line">q = getPrime(<span class="number">512</span>)</span><br><span class="line">r = getPrime(<span class="number">512</span>)</span><br><span class="line">h1 = <span class="number">1</span>*p + <span class="number">1</span>*q + <span class="number">1</span>*r</span><br><span class="line">h2 = <span class="number">2</span>*p + <span class="number">3</span>*q + <span class="number">3</span>*r</span><br><span class="line">h3 = <span class="number">9</span>*p + <span class="number">9</span>*q + <span class="number">6</span>*r</span><br><span class="line"><span class="built_in">print</span>( <span class="string">&quot;hint_of_pqr=&quot;</span> , h1 , h2 , h3 )</span><br><span class="line"></span><br><span class="line">e = getPrime(<span class="number">64</span>)</span><br><span class="line">a_big_prime = getPrime( <span class="number">512</span> )</span><br><span class="line">hint = <span class="built_in">pow</span>(a_big_prime,e,<span class="number">2</span>**<span class="number">512</span>)</span><br><span class="line"><span class="built_in">print</span>( <span class="string">&quot;big_prime is: &quot;</span> , a_big_prime )</span><br><span class="line"><span class="built_in">print</span>( <span class="string">&quot;hint is: &quot;</span> , hint )</span><br><span class="line"></span><br><span class="line">n = p*q*r</span><br><span class="line">c = <span class="built_in">pow</span>( m , e , n )</span><br><span class="line"><span class="built_in">print</span>( <span class="string">&quot;c=&quot;</span> , c )</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">hint_of_pqr= 31142735238530997044538008977536563192992446755282526163704097825748037157617958329370018716097695151853567914689441893020256819531959835133410539308633497 83244528500940968089139246591338465098116598400576450028712055615289379610182828415628469144649133540240957232351546273836449824638227295064400834828714760 248913032538718194100308575844236838621741774207751338576000867909773931464854644505429950530402814602955352740032796855486666128271187734043696395254816172 </span></span><br><span class="line"><span class="string">big_prime is:  10340528340717085562564282159472606844701680435801531596688324657589080212070472855731542530063656135954245247693866580524183340161718349111409099098622379</span></span><br><span class="line"><span class="string">hint is:  1117823254118009923270987314972815939020676918543320218102525712576467969401820234222225849595448982263008967497960941694470967789623418862506421153355571 </span></span><br><span class="line"><span class="string">c= 999238457633695875390868312148578206874085180328729864031502769160746939370358067645058746087858200698064715590068454781908941878234704745231616472500544299489072907525181954130042610756999951629214871917553371147513692253221476798612645630242018686268404850587754814930425513225710788525640827779311258012457828152843350882248473911459816471101547263923065978812349463656784597759143314955463199850172786928389414560476327593199154879575312027425152329247656310</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>考点</strong>：离散对数</p><p>是一道RSA题目，n是p、q、r的乘积，而题目告诉我们pqr之间的线性关系（三个未知数，三个方程，可以解出p、q、r）</p><p>那接下来就是要求d，但是题目没有给我们e，给的是a_big_prime^e(mod 2^512)</p><p>参考了一些博客，知道是离散对数问题，但是我不太了解离散对数（之后会多看看的），然后直接在一个博客里就找到了一个库里的一个函数，可以直接求出e</p><font style="color:rgb(77, 77, 77);">python的 sympy库discrete_log函数是专门求指数的，discrete_log(x,y,z)，x为模数，y为余数，z为底数</font><p>用这个函数求出来e后就是RSA解密的经典过程了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">import</span> sympy</span><br><span class="line"></span><br><span class="line">h1 = <span class="number">31142735238530997044538008977536563192992446755282526163704097825748037157617958329370018716097695151853567914689441893020256819531959835133410539308633497</span></span><br><span class="line">h2 = <span class="number">83244528500940968089139246591338465098116598400576450028712055615289379610182828415628469144649133540240957232351546273836449824638227295064400834828714760</span></span><br><span class="line">h3 = <span class="number">248913032538718194100308575844236838621741774207751338576000867909773931464854644505429950530402814602955352740032796855486666128271187734043696395254816172</span></span><br><span class="line">big_prime= <span class="number">10340528340717085562564282159472606844701680435801531596688324657589080212070472855731542530063656135954245247693866580524183340161718349111409099098622379</span></span><br><span class="line">hint=      <span class="number">1117823254118009923270987314972815939020676918543320218102525712576467969401820234222225849595448982263008967497960941694470967789623418862506421153355571</span></span><br><span class="line">c= <span class="number">999238457633695875390868312148578206874085180328729864031502769160746939370358067645058746087858200698064715590068454781908941878234704745231616472500544299489072907525181954130042610756999951629214871917553371147513692253221476798612645630242018686268404850587754814930425513225710788525640827779311258012457828152843350882248473911459816471101547263923065978812349463656784597759143314955463199850172786928389414560476327593199154879575312027425152329247656310</span></span><br><span class="line"></span><br><span class="line">p = <span class="number">3</span> * h1 - h2</span><br><span class="line">r = (<span class="number">9</span> * h1 - h3)//<span class="number">3</span></span><br><span class="line">q = h1 - p - r</span><br><span class="line"></span><br><span class="line">n = p*q*r</span><br><span class="line">phi = (p-<span class="number">1</span>)*(q-<span class="number">1</span>)*(r-<span class="number">1</span>)</span><br><span class="line">e = sympy.discrete_log(<span class="number">2</span>**<span class="number">512</span>,hint,big_prime)</span><br><span class="line">d = gmpy2.invert(e,phi)</span><br><span class="line">m = <span class="built_in">pow</span>(c,d,n)</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(m))</span><br><span class="line"><span class="comment"># flag&#123;th1s_2s_A_rea119_f34ggg&#125;</span></span><br></pre></td></tr></table></figure><h2 id="故事新编"><a href="#故事新编" class="headerlink" title="故事新编"></a>故事新编</h2><p><strong>题目</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> md5</span><br><span class="line">zen1  = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">key1 = </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">enc1</span>(<span class="params">plaintext, key</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">shift_char</span>(<span class="params">c, k</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">chr</span>(((<span class="built_in">ord</span>(c) - <span class="built_in">ord</span>(<span class="string">&#x27;A&#x27;</span>) + (<span class="built_in">ord</span>(k) - <span class="built_in">ord</span>(<span class="string">&#x27;A&#x27;</span>))) % <span class="number">26</span>) + <span class="built_in">ord</span>(<span class="string">&#x27;A&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    plaintext = plaintext.upper()</span><br><span class="line">    key = key.upper()</span><br><span class="line">    ciphertext = []</span><br><span class="line">    key_index = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> char <span class="keyword">in</span> plaintext:</span><br><span class="line">        <span class="keyword">if</span> char.isalpha():</span><br><span class="line">            ciphertext.append(shift_char(char, key[key_index % <span class="built_in">len</span>(key)]))</span><br><span class="line">            key_index += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            ciphertext.append(char)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(ciphertext)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;enc = \&#x27;\&#x27;\&#x27;&#x27;</span> + enc1(zen1, key1)+<span class="string">&#x27;\&#x27;\&#x27;\&#x27;&#x27;</span>)</span><br><span class="line">flag = <span class="string">b&#x27;flag&#123;&#x27;</span>+md5(zen1.encode()).hexdigest().encode()+<span class="string">b&#x27;&#125;&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(flag)</span><br><span class="line"><span class="comment">#----------------------------------------------</span></span><br><span class="line">enc = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">TYBNBBZNT WF TYUMMK NAIB HYFZ.</span></span><br><span class="line"><span class="string">XFIFBKWG AM CXBMYK BVNF CNITBWBB.</span></span><br><span class="line"><span class="string">GVEJMX QL VXBHRJ NITV VIFXZRP.</span></span><br><span class="line"><span class="string">WPFXEYQ QG OWNUXZ MBTV QBEJMBKTNXL.</span></span><br><span class="line"><span class="string">TYSN JL JXNMMF GZUO GMLNXL.</span></span><br><span class="line"><span class="string">GCSLTX QL VXBHRJ NITV WYGAS.</span></span><br><span class="line"><span class="string">SDUHT QL PXOSAWLF</span></span><br><span class="line"><span class="string">KMTXTJWYANZ VWNHMA.</span></span><br><span class="line"><span class="string">GCWWJTT VULMG NJYO&#x27;M AIYVQOY WHPNOA NH JFRSE UAM KOEMG.</span></span><br><span class="line"><span class="string">NDNIHCZB IZOPLCDTTBNR JSNLM QNZBNR.</span></span><br><span class="line"><span class="string">MFEGLT LPHOEL BRNYS IILM LQZRFNMR.</span></span><br><span class="line"><span class="string">CGFXAG RPJMBKBNEG GVDYOVMW.</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>考点</strong>：维吉尼亚爆破</p><p>题目是定义了一个enc函数，它接收明文和密钥，然后将它们全部大写，然后明文里的每个字符依次移动密文对应字符的ASCII值（减去’A’后的值）看到这里，如果古典密码记得熟的话应该就能反应过来这是一个维吉尼亚密码<del>（我吗？我记不住，我问AI的，它告诉我的）</del></p><p>那知道是维吉尼亚加密了，找到密钥不就解出来了<del>，嗯？没给我密钥？那就跟你爆了！</del> 是的，没有密钥的情况下运用在线网站爆破一下就可以得到明文了，我就是用的<a href="https://www.guballa.de/vigenere-solver">链接</a>网址的在线工具</p><p>之后MD5加密后的十六进制转字节，打印出来就是了</p><p>至于故事新编2，是<font style="color:rgb(60, 60, 60);">自动密钥密码，与故事新编 1 相类似。是维吉尼亚的变异，在上面那个网站也能爆破，都可以求出flag</font></p><font style="color:rgb(60, 60, 60);"></font><h2 id="不用谢喵"><a href="#不用谢喵" class="headerlink" title="不用谢喵"></a><font style="color:rgb(60, 60, 60);">不用谢喵</font></h2><p><strong>题目</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">KEY = <span class="string">b&quot;fake_key_fake_ke&quot;</span></span><br><span class="line">FLAG = <span class="string">&quot;flag&#123;fake_flag_fake_flag&#125;&quot;</span>  </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decrypt</span>(<span class="params">c</span>):</span><br><span class="line">    AES_ECB = AES.new(KEY, AES.MODE_ECB)</span><br><span class="line">    decrypted = AES_ECB.decrypt(long_to_bytes(c))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> decrypted.<span class="built_in">hex</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encrypt</span>():</span><br><span class="line">    iv = os.urandom(<span class="number">16</span>)</span><br><span class="line">    AES_CBC = AES.new(KEY, AES.MODE_CBC, iv)</span><br><span class="line">    encrypted = AES_CBC.encrypt(FLAG.encode())</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;iv:&#x27;</span>,iv.<span class="built_in">hex</span>())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> iv.<span class="built_in">hex</span>() + encrypted.<span class="built_in">hex</span>()</span><br><span class="line"></span><br><span class="line">c=encrypt()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;encrypt:&#x27;</span>,c)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;decrypt:&#x27;</span>,decrypt(<span class="built_in">int</span>(c,<span class="number">16</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment">#encrypt: f2040fe3063a5b6c65f66e1d2bf47b4cddb206e4ddcf7524932d25e92d57d3468398730b59df851cbac6d65073f9e138</span></span><br><span class="line"><span class="comment">#什么是AES啊😭，求求你帮我解密吧，我什么都会做的！！！！！😭</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">什么都会做？那就去学习一下AES的工作模式吧……</span></span><br><span class="line"><span class="string">我这次就先给你解一下好了，不用谢喵</span></span><br><span class="line"><span class="string">decrypt: f9899749fec184d81afecd35da430bc394686e847d72141b3a955a4f6e920e7d91cb599d92ba2a6ba51860bb5b32f23b</span></span><br><span class="line"><span class="string">这对吗？哦不对不对，哦对的对的。</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>考点</strong>：AES的不同分组模式</p><p>这道题定义了两个函数，一个CBC分组模式的AES加密函数；一个是ECB分组模式的AES解密函数。</p><p>CBC模式是对每个块都使用同一个key进行块加密，但块加密之前，先将明文块与前一个密文块进行异或计算，然后再对异或计算结果进行块加密。对于首个明文块，因为不存在前一个密文块，所以需要额外的一个字节数组来充当”前一个密文块”，这个字节数组被称为初始化向量，IV。解密时要把和key进行块解密操作后的块和前一个密文块（第一个密文块和iv）异或后才能得到明文块。</p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/42554774/1728642690114-23f34435-6fc5-4ece-9d53-aabee58c6680.png?x-oss-process=image%2Fformat%2Cwebp%2Fresize%2Cw_1125%2Climit_0" alt=""></p><p>ECB是最简单的一个分组模式（应该是），对每一个块的加密都是使用同样的key，同样的明文块一定会被加密成同样的密文块。解密过程就是把每一个块和key进行块解密操作就可以了。</p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/42554774/1728642677785-40fe2fba-9d49-48fc-a382-a271a009ed79.png?x-oss-process=image%2Fformat%2Cwebp%2Fresize%2Cw_994%2Climit_0" alt=""></p><p>那么已知明文是被encrypt()函数加密的，是一个CBC模式，所以我们只要知道iv和key就可以解密了，iv其实很好知道，因为我们知道encrypt，它是iv和密文的十六进制，因为我们知道iv是16个字节，那么encrypt的前32个字符就是iv（每个字节对应两个十六进制字符数）</p><p>但是我们不知道key呀，怎么办呢，让我们看看喵帮我们干了什么，嗯，它用ECB模式解密了我们的明文，这不对吧？但是只要我们观察一下，就会发现用ECB模式解密和CBC模式就差一步异或，这样我们就不用知道key了，只要异或就行了</p><p>官方wp很巧妙，把所有转成字节型再疑惑，后面查了一下发现十进制和十六进制long_to_bytes的结果是一样的，也是长见识了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes <span class="keyword">as</span> l2b , bytes_to_long <span class="keyword">as</span> b2l</span><br><span class="line"></span><br><span class="line">c = <span class="number">0xf2040fe3063a5b6c65f66e1d2bf47b4cddb206e4ddcf7524932d25e92d57d3468398730b59df851cbac6d65073f9e138</span></span><br><span class="line">d = <span class="number">0xf9899749fec184d81afecd35da430bc394686e847d72141b3a955a4f6e920e7d91cb599d92ba2a6ba51860bb5b32f23b</span></span><br><span class="line"></span><br><span class="line">part1=l2b( b2l(l2b(c)[<span class="number">0</span>:<span class="number">16</span>]) ^ b2l(l2b(d)[<span class="number">16</span>:<span class="number">32</span>]))</span><br><span class="line">part2=l2b( b2l(l2b(c)[<span class="number">16</span>:<span class="number">32</span>]) ^ b2l(l2b(d)[<span class="number">32</span>:<span class="number">48</span>]))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(part1+part2)</span><br><span class="line"><span class="comment"># flag&#123;HOw_c4REfu1Ly_yOu_O65ERve!&#125;</span></span><br></pre></td></tr></table></figure><h2 id="两个黄鹂鸣翠柳"><a href="#两个黄鹂鸣翠柳" class="headerlink" title="两个黄鹂鸣翠柳"></a>两个黄鹂鸣翠柳</h2><p><strong>题目</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    delta = getPrime(<span class="number">1024</span>)</span><br><span class="line">    p = getPrime(<span class="number">512</span>)</span><br><span class="line">    q = getPrime(<span class="number">512</span>)</span><br><span class="line">    N = p * q</span><br><span class="line">    <span class="keyword">if</span> delta&lt;N:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">flag = <span class="string">b&#x27;flag&#123;xxxxxxxxxxxxx&#125;&#x27;</span></span><br><span class="line">e = getPrime(<span class="number">10</span>)</span><br><span class="line">m = bytes_to_long(flag)</span><br><span class="line">t1 = random.randint(<span class="number">0</span>,<span class="number">255</span>)</span><br><span class="line">t2 = random.randint(<span class="number">0</span>,<span class="number">255</span>)</span><br><span class="line"><span class="keyword">assert</span> (t1 != t2)</span><br><span class="line">m1 = m + t1 * delta</span><br><span class="line">m2 = m + t2 * delta</span><br><span class="line">c1 = <span class="built_in">pow</span>(m1, e, N)</span><br><span class="line">c2 = <span class="built_in">pow</span>(m2, e, N)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;e = &quot;</span>, e)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;c1 = &quot;</span>, c1)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;c2 = &quot;</span>, c2)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;N = &quot;</span>, N)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;delta = &quot;</span>, delta)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">e =  683</span></span><br><span class="line"><span class="string">c1 =  56853945083742777151835031127085909289912817644412648006229138906930565421892378967519263900695394136817683446007470305162870097813202468748688129362479266925957012681301414819970269973650684451738803658589294058625694805490606063729675884839653992735321514315629212636876171499519363523608999887425726764249</span></span><br><span class="line"><span class="string">c2 =  89525609620932397106566856236086132400485172135214174799072934348236088959961943962724231813882442035846313820099772671290019212756417758068415966039157070499263567121772463544541730483766001321510822285099385342314147217002453558227066228845624286511538065701168003387942898754314450759220468473833228762416</span></span><br><span class="line"><span class="string">N =  147146340154745985154200417058618375509429599847435251644724920667387711123859666574574555771448231548273485628643446732044692508506300681049465249342648733075298434604272203349484744618070620447136333438842371753842299030085718481197229655334445095544366125552367692411589662686093931538970765914004878579967</span></span><br><span class="line"><span class="string">delta =  93400488537789082145777768934799642730988732687780405889371778084733689728835104694467426911976028935748405411688535952655119354582508139665395171450775071909328192306339433470956958987928467659858731316115874663323404280639312245482055741486933758398266423824044429533774224701791874211606968507262504865993</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>考点</strong>：关联信息攻击，多项式gcd</p><p>总的来说就是找到两个多项式的公因子，而这个值大概率就是m1，之后就可以求解出明文。但具体原理有点复杂，用到了Half-GCD 算法，之后细扣</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">HGCD</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="number">2</span> * b.degree() &lt;= a.degree() <span class="keyword">or</span> a.degree() == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    m = a.degree() // <span class="number">2</span></span><br><span class="line">    a_top, a_bot = a.quo_rem(x ^ m)</span><br><span class="line">    b_top, b_bot = b.quo_rem(x ^ m)</span><br><span class="line">    R00, R01, R10, R11 = HGCD(a_top, b_top)</span><br><span class="line">    c = R00 * a + R01 * b</span><br><span class="line">    d = R10 * a + R11 * b</span><br><span class="line">    q, e = c.quo_rem(d)</span><br><span class="line">    d_top, d_bot = d.quo_rem(x ^ (m // <span class="number">2</span>))</span><br><span class="line">    e_top, e_bot = e.quo_rem(x ^ (m // <span class="number">2</span>))</span><br><span class="line">    S00, S01, S10, S11 = HGCD(d_top, e_top)</span><br><span class="line">    RET00 = S01 * R00 + (S00 - q * S01) * R10</span><br><span class="line">    RET01 = S01 * R01 + (S00 - q * S01) * R11</span><br><span class="line">    RET10 = S11 * R00 + (S10 - q * S11) * R10</span><br><span class="line">    RET11 = S11 * R01 + (S10 - q * S11) * R11</span><br><span class="line">    <span class="keyword">return</span> RET00, RET01, RET10, RET11</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">related_message_attack</span>(<span class="params">a, b</span>):</span><br><span class="line">    q, r = a.quo_rem(b)</span><br><span class="line">    <span class="keyword">if</span> r == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> b</span><br><span class="line">    R00, R01, R10, R11 = HGCD(a, b)</span><br><span class="line">    c = R00 * a + R01 * b</span><br><span class="line">    d = R10 * a + R11 * b</span><br><span class="line">    <span class="keyword">if</span> d == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> c.monic()</span><br><span class="line">    q, r = c.quo_rem(d)</span><br><span class="line">    <span class="keyword">if</span> r == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> d</span><br><span class="line">    <span class="keyword">return</span> related_message_attack(d, r)</span><br><span class="line"></span><br><span class="line">e =  <span class="number">683</span></span><br><span class="line">c1 =  <span class="number">56853945083742777151835031127085909289912817644412648006229138906930565421892378967519263900695394136817683446007470305162870097813202468748688129362479266925957012681301414819970269973650684451738803658589294058625694805490606063729675884839653992735321514315629212636876171499519363523608999887425726764249</span></span><br><span class="line">c2 =  <span class="number">89525609620932397106566856236086132400485172135214174799072934348236088959961943962724231813882442035846313820099772671290019212756417758068415966039157070499263567121772463544541730483766001321510822285099385342314147217002453558227066228845624286511538065701168003387942898754314450759220468473833228762416</span></span><br><span class="line">N =  <span class="number">147146340154745985154200417058618375509429599847435251644724920667387711123859666574574555771448231548273485628643446732044692508506300681049465249342648733075298434604272203349484744618070620447136333438842371753842299030085718481197229655334445095544366125552367692411589662686093931538970765914004878579967</span></span><br><span class="line">delta =  <span class="number">93400488537789082145777768934799642730988732687780405889371778084733689728835104694467426911976028935748405411688535952655119354582508139665395171450775071909328192306339433470956958987928467659858731316115874663323404280639312245482055741486933758398266423824044429533774224701791874211606968507262504865993</span></span><br><span class="line"></span><br><span class="line">is_flag = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> delt <span class="keyword">in</span> <span class="built_in">range</span>(-<span class="number">255</span>, <span class="number">255</span>, <span class="number">8</span>):</span><br><span class="line"></span><br><span class="line">    PR.&lt;x&gt; = PolynomialRing(Zmod(N))</span><br><span class="line">    f = x ^ e - c1</span><br><span class="line">    g1 = ((x + (delt + <span class="number">0</span>) * delta) ^ e - c2) * ((x + (delt + <span class="number">1</span>) * delta) ^ e - c2)</span><br><span class="line">    g2 = ((x + (delt + <span class="number">2</span>) * delta) ^ e - c2) * ((x + (delt + <span class="number">3</span>) * delta) ^ e - c2)</span><br><span class="line">    g3 = ((x + (delt + <span class="number">4</span>) * delta) ^ e - c2) * ((x + (delt + <span class="number">5</span>) * delta) ^ e - c2)</span><br><span class="line">    g4 = ((x + (delt + <span class="number">6</span>) * delta) ^ e - c2) * ((x + (delt + <span class="number">7</span>) * delta) ^ e - c2)</span><br><span class="line">    <span class="keyword">if</span> delt == -<span class="number">7</span>:</span><br><span class="line">        g4 = ((x + (delt + <span class="number">6</span>) * delta) ^ e - c2)</span><br><span class="line">    g = g1 * g2 * g3 * g4</span><br><span class="line">    res = related_message_attack(f, g)</span><br><span class="line">    m1 = <span class="built_in">int</span>(-res.monic().coefficients()[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">for</span> t1 <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">        m = (m1 % N - t1 * delta) % N</span><br><span class="line">        <span class="keyword">if</span> m &gt; <span class="number">0</span>:</span><br><span class="line">            flag = long_to_bytes(m)</span><br><span class="line">            <span class="keyword">if</span> flag[:<span class="number">4</span>] ==<span class="string">b&#x27;flag&#x27;</span>:</span><br><span class="line">                <span class="built_in">print</span>(flag)</span><br><span class="line">                is_flag = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> is_flag:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="comment"># flag&#123;V_me_the_flag&#125;</span></span><br></pre></td></tr></table></figure><h1 id="week4"><a href="#week4" class="headerlink" title="week4"></a>week4</h1><h2 id="圣石匕首"><a href="#圣石匕首" class="headerlink" title="圣石匕首"></a>圣石匕首</h2><p><strong>题目</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line">beta=<span class="number">0.37</span></span><br><span class="line">delta=<span class="number">0.01</span></span><br><span class="line">n=<span class="built_in">round</span>((<span class="number">1</span>-<span class="number">2</span>*beta-<span class="number">2</span>*delta)/((<span class="number">1</span>-beta)^<span class="number">2</span>-<span class="number">2</span>*delta-beta),<span class="number">6</span>)</span><br><span class="line">e= <span class="number">3668637434348843171145584606519031375027610199908169273169275927238735031431533260375377791001464799116453803408104076615710166171199990283470548282669948353598733020244755959461974603778630346457439345913209321194112256348302765254052193562603687450740346132207444615610078198488883539133291840346099727880587092122957231085658576850601488737629051252914095889313671875244094452330062619943781809984690384476868543570724769198985172300665613239047649089399919032152539462701309393130614829962670866062380816370571057536421400102100259975636785825540933280194583888638501981649650640939392658268133881679239293596283</span></span><br><span class="line">N= <span class="number">9748523098652101859947730585916490335896800943242955095820326993765071194474558998322598145898741779502734772138283011560029368500998354183150180904846368209977332058847768859238711047784703104535311583123388923571789764758869419482184613566672922481672444028753365755071127320541645016370072493604532087980626825687519083734367691341907014061379844209864141989961751681235215504772582878202048494707090104738899927036896915997556102574747166491969027546256022019959716418675672979328622656831990050058120299353807110233202113906317969377201045402271911946244076903611612303290556012512559696538977841061277173754331</span></span><br><span class="line">c= <span class="number">5374936627659221745209010619827617207565185520404653329184605916859755641352457088986635357806048863755173540232471505333583684733535121482637476692432365062808450583470788320547816186936317927449796090525477205337038591439577855884910604383190932340306435201976465543731935147881754136301375206828970248293731391543905441514528959500307972606931927112031018356411970001312995489429650903529877904694901310020882390008248466887950986326522740278880600110217817950511478637493101027659292006016454642135508207492151610829525082829566392116546434101694921106423469015683277992978077101831969525458693031031468092418427</span></span><br><span class="line">n=<span class="built_in">int</span>(n+<span class="number">1</span>)</span><br><span class="line"><span class="comment">#print(n)</span></span><br><span class="line">m=<span class="built_in">int</span>(n*(<span class="number">1</span>-beta))</span><br><span class="line">X=<span class="built_in">int</span>(<span class="built_in">pow</span>(N,delta))</span><br><span class="line">Y=<span class="built_in">int</span>(<span class="built_in">pow</span>(N,delta+beta))</span><br><span class="line">Z.&lt;x,y&gt;=ZZ[]</span><br><span class="line">L=Matrix(ZZ,n,n)</span><br><span class="line">f=e*x-y</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    g=<span class="built_in">list</span>(N^<span class="built_in">max</span>(<span class="number">0</span>,m-i)*x^(n-<span class="number">1</span>-i)*f^i)</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(g)):</span><br><span class="line">        L[i,j]=g[j][<span class="number">0</span>]*X^(n-<span class="number">1</span>-j)*Y^j</span><br><span class="line">L=L.LLL()[<span class="number">0</span>]</span><br><span class="line">coeff=[]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    coeff.append((L[i]//(X^(n-<span class="number">1</span>-i)*Y^i),<span class="string">&#x27;x&#x27;</span>+<span class="string">&#x27;**&#x27;</span>+<span class="built_in">str</span>(n-<span class="number">1</span>-i)+<span class="string">&#x27;*y&#x27;</span>+<span class="string">&#x27;**&#x27;</span>+<span class="built_in">str</span>(i)))</span><br><span class="line">s=<span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(coeff)):</span><br><span class="line">    s+=<span class="built_in">str</span>(coeff[i][<span class="number">0</span>])+<span class="string">&#x27;*&#x27;</span>+coeff[i][<span class="number">1</span>]+<span class="string">&#x27;+&#x27;</span></span><br><span class="line">f=<span class="built_in">eval</span>(s[:-<span class="number">1</span>])</span><br><span class="line">factored_f = f.factor()</span><br><span class="line">first_polynomial = factored_f[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">first_coefficient = first_polynomial.coefficients()[<span class="number">0</span>]</span><br><span class="line">k = first_coefficient + <span class="number">1</span></span><br><span class="line">dp = first_polynomial.coefficients()[<span class="number">1</span>]</span><br><span class="line">p=(e*dp-<span class="number">1</span>)//k+<span class="number">1</span></span><br><span class="line">q=N//p</span><br><span class="line">phi=(p-<span class="number">1</span>)*(q-<span class="number">1</span>)</span><br><span class="line">d=gmpy2.invert(e,phi)</span><br><span class="line">m=<span class="built_in">pow</span>(c,d,N)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">bytes</span>.fromhex(<span class="built_in">hex</span>(m)[<span class="number">2</span>:]))</span><br></pre></td></tr></table></figure><p>就是一个sage文件，在sagemath里面运行就行了，就是运行比较久（我就复制到Jupyter上运行一下就行了）</p><p>flag{small_dp_is_not_secure_adhfaiuhaph}</p><h2 id="欧拉欧拉！！"><a href="#欧拉欧拉！！" class="headerlink" title="欧拉欧拉！！"></a>欧拉欧拉！！</h2><p><strong>题目</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">flag = <span class="string">b&#x27;flag&#123;*********&#125;&#x27;</span></span><br><span class="line">m = bytes_to_long(flag)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_prime</span>(<span class="params">bits</span>):</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        p = getPrime(bits)</span><br><span class="line">        x = (<span class="number">1</span> &lt;&lt; bits) - <span class="number">1</span> ^ p</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(-<span class="number">10</span>, <span class="number">11</span>):</span><br><span class="line">            <span class="keyword">if</span> isPrime(x + i):</span><br><span class="line">                <span class="keyword">return</span> p, x + i, i</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p, q, i = get_prime(<span class="number">512</span>)</span><br><span class="line">n = p * q</span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">c = <span class="built_in">pow</span>(m, e, n)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;c =&quot;</span>, c)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;n =&quot;</span>, n)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;i =&quot;</span>, i)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">c = 14859652090105683079145454585893160422247900801288656111826569181159038438427898859238993694117308678150258749913747829849091269373672489350727536945889312021893859587868138786640133976196803958879602927438349289325983895357127086714561807181967380062187404628829595784290171905916316214021661729616120643997</span></span><br><span class="line"><span class="string">n = 18104347461003907895610914021247683508445228187648940019610703551961828343286923443588324205257353157349226965840638901792059481287140055747874675375786201782262247550663098932351593199099796736521757473187142907551498526346132033381442243277945568526912391580431142769526917165011590824127172120180838162091</span></span><br><span class="line"><span class="string">i = -3</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>考点</strong>：二进制加法，间接求欧拉函数</p><p>我们有以下式子</p><p>$ x = (1 &lt;&lt; bits) - 1 \text{^} p $</p><p>那么就要了解一下二进制加法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">0b1001</span></span><br><span class="line">b = a ^ <span class="number">0b1111</span> = <span class="number">0b0110</span></span><br><span class="line">a + b = <span class="number">1111</span></span><br></pre></td></tr></table></figure><p>所有我们有$ x + p= (1 &lt;&lt; bits) - 1 $</p><p>然后1&lt;&lt;512是$ 2^{512} $</p><p>所以$ x + p= 2^{512} - 1 $</p><p>所以$ p+q = p+x+i=2^{512}-1+i $</p><p>$ phi(n)=(p-1)(q-1)=pq-(p+q)+1=n-2^{512}+2-i $</p><p>后面就没有难度了，求出d正常求解就行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"></span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">c = <span class="number">14859652090105683079145454585893160422247900801288656111826569181159038438427898859238993694117308678150258749913747829849091269373672489350727536945889312021893859587868138786640133976196803958879602927438349289325983895357127086714561807181967380062187404628829595784290171905916316214021661729616120643997</span></span><br><span class="line">n = <span class="number">18104347461003907895610914021247683508445228187648940019610703551961828343286923443588324205257353157349226965840638901792059481287140055747874675375786201782262247550663098932351593199099796736521757473187142907551498526346132033381442243277945568526912391580431142769526917165011590824127172120180838162091</span></span><br><span class="line">i = -<span class="number">3</span></span><br><span class="line">phi = n - <span class="number">2</span>**<span class="number">512</span> + <span class="number">2</span> - i</span><br><span class="line">d = gmpy2.invert(e,phi)</span><br><span class="line">m = <span class="built_in">pow</span>(c,d,n)</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(m))</span><br><span class="line"><span class="comment"># flag&#123;y0u_really_kn0w_the_phi&#125;</span></span><br></pre></td></tr></table></figure><h2 id="俱以我之名"><a href="#俱以我之名" class="headerlink" title="俱以我之名"></a>俱以我之名</h2><p><strong>题目</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pad</span>(<span class="params">msg, nbits</span>):</span><br><span class="line">    pad_length = nbits - <span class="built_in">len</span>(msg) * <span class="number">8</span> - <span class="number">8</span></span><br><span class="line">    <span class="keyword">assert</span> pad_length &gt;= <span class="number">0</span></span><br><span class="line">    pad = random.getrandbits(pad_length).to_bytes((pad_length + <span class="number">7</span>) // <span class="number">8</span>, <span class="string">&quot;big&quot;</span>)</span><br><span class="line">    padded_msg = pad[:<span class="built_in">len</span>(pad)//<span class="number">2</span>] + <span class="string">b&quot;\x00&quot;</span> + msg + pad[<span class="built_in">len</span>(pad)//<span class="number">2</span>:]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> padded_msg</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">All_in_my_name</span>(<span class="params">p, q</span>):</span><br><span class="line">    <span class="comment">#开启三技能&lt;俱以我之名&gt;后，维娜立即在周围八格可部署地面召唤“黄金盟誓(Golden_Oath)”;对RSA造成真实伤害。</span></span><br><span class="line">    Golden_Oath = (p-<span class="number">114</span>)*(p-<span class="number">514</span>)*(p+<span class="number">114</span>)*(p+<span class="number">514</span>)*(q-<span class="number">1919</span>)*(q-<span class="number">810</span>)*(q+<span class="number">1919</span>)*(q+<span class="number">810</span>)</span><br><span class="line">    x = bytes_to_long(pad(gift, random.randint(bytes_to_long(gift).bit_length(), <span class="number">512</span>)))</span><br><span class="line">    y = inverse(x, Golden_Oath)</span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line"></span><br><span class="line">flag = <span class="string">b&#x27;flag&#123;?????&#125;&#x27;</span></span><br><span class="line">gift = <span class="string">b&#x27;?????&#x27;</span></span><br><span class="line"><span class="keyword">assert</span> gift[:<span class="number">3</span>] == <span class="string">b&#x27;end&#x27;</span></span><br><span class="line"></span><br><span class="line">p = getPrime(<span class="number">512</span>)</span><br><span class="line">q = getPrime(<span class="number">512</span>)</span><br><span class="line">n = p*q</span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">c = <span class="built_in">pow</span>(bytes_to_long(flag), e,n)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;n = <span class="subst">&#123;n&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;c = <span class="subst">&#123;c&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;All_in_my_name = <span class="subst">&#123;All_in_my_name(p, q)&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">n = 141425071303405369267688583480971314815032581405819618511016190023245950842423565456025578726768996255928405749476366742320062773129810617755239412667111588691998380868379955660483185372558973059599254495581547016729479937763213364591413126146102483671385285672028642742654014426993054793378204517214486744679</span></span><br><span class="line"><span class="string">c = 104575090683421063990494118954150936075812576661759942057772865980855195301985579098801745928083817885393369435101522784385677092942324668770336932487623099755265641877712097977929937088259347596039326198580193524065645826424819334664869152049049342316256537440449958526473368110002271943046726966122355888321</span></span><br><span class="line"><span class="string">All_in_my_name = 217574365691698773158073738993996550494156171844278669077189161825491226238745356969468902038533922854535578070710976002278064001201980326028443347187697136216041235312192490502479015081704814370278142850634739391445817028960623318683701439854891399013393469200033510113406165952272497324443526299141544564964545937461632903355647411273477731555390580525472533399606416576667193890128726061970653201509841276177937053500663438053151477018183074107182442711656306515049473061426018576304621373895497210927151796054531814746265988174146635716820986208719319296233956243559891444122410388128465897348458862921336261068868678669349968117097659195490792407141240846445006330031546721426459458395606505793093432806236790060342049066284307119546018491926250151057087562126580602631912562103705681810139118673506298916800665912859765635644796622382867334481599049728329203920912683317422430015635091565073203588723830512169316991557606976424732212785533550238950903858852917097354055547392337744369560947616517041907362337902584102983344969307971888314998036201926257375424706901999793914432814775462333942995267009264203787170147555384279151485485660683109778282239772043598128219664150933315760352868905799949049880756509591090387073778041</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>考点</strong>：维娜攻击</p><p>当e过大或过小的时候我们都可以考虑维纳攻击，当然还要满足$ d&lt;\frac{1}{3}n^{\frac{1}{4}} $,且$ q&lt;p&lt;2q $</p><p>我们简单推一下，我们知道$ n=p*q $</p><p>$ phi(n)=(p-1)(q-1)=pq -(p+q)+1 $</p><p>因为p和q都是非常大的数，我们近似处理后n和phi(n)就差不多大。</p><p>我们知道$ ed=1 \mod phi(n) $</p><p>所以$ ed = k\times phi(n)+1 $，两边同时除以$ d*phi(n) $</p><p>得到$ \frac{e}{phi(n)}=\frac{k}{d}+\frac{1}{d\times phi(n)} $</p><p>同样的$ d*phi(n) $是很大的数，$ \frac{1}{d\times phi(n)} $可以忽略，phi(n)用n来代替，就可以得到$ \frac{e}{n}=\frac{k}{d} $</p><p>e和n都是已知的，我们就可以用连分数展开，得到k和d的可能值(原理还没搞懂，目前只能直接用)</p><p>这里的”俱以我之名”就是一个维纳攻击(是的，我玩舟)，那么我们就要找能连分数展开的式子</p><p>$ xy=1\mod Golden_Oath $</p><p>所以$ \frac{y}{Golden_Oath}=\frac{k}{x} $</p><p>其中$ Golden_Oath = (p-114)(p-514)(p+114)(p+514)(q-1919)(q-810)(q+1919)(q+810)<br> $我们可以看成$ n^4 $</p><p>那我们对这个式子进行连分数展开，就能找到一系列近似值，再判断一下’end’在不在求出来的x里就可以找到x了，代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">n = <span class="number">141425071303405369267688583480971314815032581405819618511016190023245950842423565456025578726768996255928405749476366742320062773129810617755239412667111588691998380868379955660483185372558973059599254495581547016729479937763213364591413126146102483671385285672028642742654014426993054793378204517214486744679</span></span><br><span class="line">c = <span class="number">104575090683421063990494118954150936075812576661759942057772865980855195301985579098801745928083817885393369435101522784385677092942324668770336932487623099755265641877712097977929937088259347596039326198580193524065645826424819334664869152049049342316256537440449958526473368110002271943046726966122355888321</span></span><br><span class="line">y = <span class="number">217574365691698773158073738993996550494156171844278669077189161825491226238745356969468902038533922854535578070710976002278064001201980326028443347187697136216041235312192490502479015081704814370278142850634739391445817028960623318683701439854891399013393469200033510113406165952272497324443526299141544564964545937461632903355647411273477731555390580525472533399606416576667193890128726061970653201509841276177937053500663438053151477018183074107182442711656306515049473061426018576304621373895497210927151796054531814746265988174146635716820986208719319296233956243559891444122410388128465897348458862921336261068868678669349968117097659195490792407141240846445006330031546721426459458395606505793093432806236790060342049066284307119546018491926250151057087562126580602631912562103705681810139118673506298916800665912859765635644796622382867334481599049728329203920912683317422430015635091565073203588723830512169316991557606976424732212785533550238950903858852917097354055547392337744369560947616517041907362337902584102983344969307971888314998036201926257375424706901999793914432814775462333942995267009264203787170147555384279151485485660683109778282239772043598128219664150933315760352868905799949049880756509591090387073778041</span></span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ContinuedFraction</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, numerator, denumerator</span>):</span><br><span class="line">        <span class="variable language_">self</span>.numberlist = []</span><br><span class="line">        <span class="variable language_">self</span>.fractionlist = []</span><br><span class="line">        <span class="variable language_">self</span>.GenerateNumberList(numerator, denumerator)</span><br><span class="line">        <span class="variable language_">self</span>.GenerateFractionList()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">GenerateNumberList</span>(<span class="params">self, numerator, denumerator</span>):</span><br><span class="line">        <span class="keyword">while</span> numerator != <span class="number">1</span>:</span><br><span class="line">            quotient = numerator // denumerator</span><br><span class="line">            remainder = numerator % denumerator</span><br><span class="line">            <span class="variable language_">self</span>.numberlist.append(quotient)</span><br><span class="line">            numerator = denumerator</span><br><span class="line">            denumerator = remainder</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">GenerateFractionList</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.fractionlist.append([<span class="variable language_">self</span>.numberlist[<span class="number">0</span>], <span class="number">1</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(<span class="variable language_">self</span>.numberlist)):</span><br><span class="line">            numerator = <span class="variable language_">self</span>.numberlist[i]</span><br><span class="line">            denumerator = <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">                temp = numerator</span><br><span class="line">                numerator = denumerator + numerator * <span class="variable language_">self</span>.numberlist[i - j - <span class="number">1</span>]</span><br><span class="line">                denumerator = temp</span><br><span class="line">            <span class="variable language_">self</span>.fractionlist.append([numerator, denumerator])</span><br><span class="line"></span><br><span class="line">n = <span class="built_in">pow</span>(n,<span class="number">4</span>)</span><br><span class="line">a = ContinuedFraction(y, n)</span><br><span class="line"><span class="keyword">for</span> k, x <span class="keyword">in</span> a.fractionlist:</span><br><span class="line">    <span class="comment"># 判断哪一个是我们所需的 x</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">b&#x27;end&#x27;</span> <span class="keyword">in</span> long_to_bytes(x):</span><br><span class="line">        <span class="built_in">print</span>(x)</span><br><span class="line">        <span class="built_in">print</span>(k)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(x))</span><br><span class="line">Golden_Oath = (x*y-<span class="number">1</span>)//k</span><br><span class="line"><span class="built_in">print</span>(Golden_Oath)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">103697213497220650500739251621743955651854455782387759691953279488676501281257640431561</span></span><br><span class="line"><span class="string">56398712132783063027132828918468670442692437484816382768162819797891220782528221182512</span></span><br><span class="line"><span class="string">b&#x27;5`\xf4\xf6t\xa3\x00end1n9_A_G2@nd_Ov3RTu2e\x1c\x13&quot;H\x0f\xc9&#x27;</span></span><br><span class="line"><span class="string">#400042032831098007958224589201074030167511216235146696966889080122265111949126155016295896501799032251334875101500882585261911204171467951139573150807043239564581043145433814155757093989016940205116328236031283789686099217459678429270939065783626769903068201144816933538226628329294355184200590029028565011348654002192085571172863125467318356642528249715812871925525776008917314884490518613080652875623759460663908309369135829140204137773254011408135516737187092812588388209697036416805176286184831779945910125467423823737934475944632379524991238593952097013985394648562259886597816452815669024660257170465154297959999722533255899489096196292778430386116108069053440749172609798098777046509743030019115282253351905670418760503352277616008654327326851761671410084489662135479597061419403235762755010286075975241013273964842915146756571330207605591193457296347769260777032489271278979332616929093357929916558230665466587125254822846466292980360420737307459205352964255972268278992730637939153686420457279334894980200862788513296786385507282999530973028293157179873999483225505784146175328159014143540959190522315340971608002638786511995717564457749873410017343184395040614025573440462522210939180555090227730875845671821586191943346000</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>有了Golden_Oath，也知道n=p*q，解个方程就可以求出来p和q了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Golden_Oath = <span class="number">400042032831098007958224589201074030167511216235146696966889080122265111949126155016295896501799032251334875101500882585261911204171467951139573150807043239564581043145433814155757093989016940205116328236031283789686099217459678429270939065783626769903068201144816933538226628329294355184200590029028565011348654002192085571172863125467318356642528249715812871925525776008917314884490518613080652875623759460663908309369135829140204137773254011408135516737187092812588388209697036416805176286184831779945910125467423823737934475944632379524991238593952097013985394648562259886597816452815669024660257170465154297959999722533255899489096196292778430386116108069053440749172609798098777046509743030019115282253351905670418760503352277616008654327326851761671410084489662135479597061419403235762755010286075975241013273964842915146756571330207605591193457296347769260777032489271278979332616929093357929916558230665466587125254822846466292980360420737307459205352964255972268278992730637939153686420457279334894980200862788513296786385507282999530973028293157179873999483225505784146175328159014143540959190522315340971608002638786511995717564457749873410017343184395040614025573440462522210939180555090227730875845671821586191943346000</span></span><br><span class="line"><span class="keyword">from</span> sympy <span class="keyword">import</span> symbols, Eq, solve</span><br><span class="line"></span><br><span class="line">p, q = symbols(<span class="string">&#x27;p q&#x27;</span>)</span><br><span class="line">equation1 = Eq(p * q, n)</span><br><span class="line">equation2 = Eq((p-<span class="number">114</span>)*(p-<span class="number">514</span>)*(p+<span class="number">114</span>)*(p+<span class="number">514</span>)*(q-<span class="number">1919</span>)*(q-<span class="number">810</span>)*(q+<span class="number">1919</span>)*(q+<span class="number">810</span>), Golden_Oath)</span><br><span class="line">solutions = solve((equation1, equation2), (p, q))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;p 和 q 的解: <span class="subst">&#123;solutions&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">p 和 q 的解: [(-11256874906034337229658272553494271626180719204801621165552253304119314454014247481847595578004383239651599038196432752043642616511808644606155091511313329, -12563439896413287507369191021540890661182794010085857062984791988214078294298809633469029528754549607502031091193150571585844351836163514784874848514208151), (11256874906034337229658272553494271626180719204801621165552253304119314454014247481847595578004383239651599038196432752043642616511808644606155091511313329, 12563439896413287507369191021540890661182794010085857062984791988214078294298809633469029528754549607502031091193150571585844351836163514784874848514208151)]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>有了p，q后就标准RSA解密过程抬走</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p = <span class="number">11256874906034337229658272553494271626180719204801621165552253304119314454014247481847595578004383239651599038196432752043642616511808644606155091511313329</span></span><br><span class="line">q = <span class="number">12563439896413287507369191021540890661182794010085857062984791988214078294298809633469029528754549607502031091193150571585844351836163514784874848514208151</span></span><br><span class="line">d = inverse(e, (p-<span class="number">1</span>)*(q-<span class="number">1</span>))</span><br><span class="line">m = <span class="built_in">pow</span>(c, d, n)</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(m))</span><br><span class="line"><span class="comment"># b&#x27;flag&#123;rE@L_d@m@9e_15_7h3_mo5t_au7hEn7ic_dam49E&#125;&#x27;</span></span><br></pre></td></tr></table></figure><h1 id="week5"><a href="#week5" class="headerlink" title="week5"></a>week5</h1><h2 id="RSA？cmd5！"><a href="#RSA？cmd5！" class="headerlink" title="RSA？cmd5！"></a>RSA？cmd5！</h2><p><strong>题目</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"></span><br><span class="line"><span class="comment"># 什么？你说你用 MD5 给 RSA 签名了？！</span></span><br><span class="line"></span><br><span class="line">m = <span class="string">&#x27;*******&#x27;</span></span><br><span class="line"><span class="keyword">assert</span> <span class="built_in">len</span>(m) == <span class="number">7</span></span><br><span class="line">flag = <span class="string">&#x27;flag&#123;th1s_1s_my_k3y:&#x27;</span> + m + <span class="string">&#x27;0x&#x27;</span> + hashlib.sha256(m.encode()).hexdigest() + <span class="string">&#x27;&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line">p = getStrongPrime(<span class="number">512</span>)</span><br><span class="line">q = getStrongPrime(<span class="number">512</span>)</span><br><span class="line">n = p * q</span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">phi = (p - <span class="number">1</span>) * (q - <span class="number">1</span>)</span><br><span class="line">d = inverse(e, phi)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_MD5</span>(<span class="params">m0</span>):</span><br><span class="line">    <span class="keyword">import</span> hashlib</span><br><span class="line">    md5_object = hashlib.md5(m0.encode())</span><br><span class="line">    md5_result = md5_object.hexdigest()</span><br><span class="line">    <span class="keyword">return</span> md5_result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_s</span>(<span class="params">m0, d0, n0</span>):</span><br><span class="line">    hm0 = get_MD5(m0)</span><br><span class="line">    hm1 = bytes_to_long(hm0.encode())</span><br><span class="line">    s0 = <span class="built_in">pow</span>(hm1, d0, n0)</span><br><span class="line">    <span class="keyword">return</span> s0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rsa_encode</span>(<span class="params">m0, e0, n0</span>):</span><br><span class="line">    m1 = bytes_to_long(m0.encode())</span><br><span class="line">    c0 = <span class="built_in">pow</span>(m1, e0, n0)</span><br><span class="line">    <span class="keyword">return</span> c0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_flag</span>(<span class="params">m0</span>):  <span class="comment"># 请用这个函数来转m得到flag</span></span><br><span class="line">    <span class="keyword">import</span> hashlib</span><br><span class="line">    flag = <span class="string">&#x27;flag&#123;th1s_1s_my_k3y:&#x27;</span> + m0 + <span class="string">&#x27;0x&#x27;</span> + hashlib.sha256(m0.encode()).hexdigest() + <span class="string">&#x27;&#125;&#x27;</span></span><br><span class="line">    <span class="built_in">print</span>(flag)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s = get_s(m, d, n)</span><br><span class="line">c = rsa_encode(flag, e, n)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;密文c =&quot;</span>, c)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;签名s =&quot;</span>, s)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;公钥[n,e] =&quot;</span>, [n, e])</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">密文c = 119084320846787611587774426118526847905825678869032529318497425064970463356147909835330423466179802531093233559613714033492951177656433798856482195873924140269461792479008703758436687940228268475598134411304167494814557384094637387369282900460926092035234233538644197114822992825439656673482850515654334379332</span></span><br><span class="line"><span class="string">签名s = 5461514893126669960233658468203682813465911805334274462134892270260355037191167357098405392972668890146716863374229152116784218921275571185229135409696720018765930919309887205786492284716906060670649040459662723215737124829497658722113929054827469554157634284671989682162929417551313954916635460603628116503</span></span><br><span class="line"><span class="string">公钥[n,e] = [139458221347981983099030378716991183653410063401398496859351212711302933950230621243347114295539950275542983665063430931475751013491128583801570410029527087462464558398730501041018349125941967135719526654701663270142483830687281477000567117071676521061576952568958398421029292366101543468414270793284704549051, 65537]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>考点</strong>：RSA数字签名</p><p>一眼看下来是很正常的一个RSA加密，多就多在这个s，所以我们仔细研究一下s的函数，它传入m0，求了m0的md5值，之后进行以下步骤</p><p>$ s=(hm_1)^d\mod n $</p><p>我们知道e，所以很容易解这个式子</p><p>$ hm_1=s^e=(hm_1)^{ed}=(hm_1)^{k*phi+1}=hm_1\mod n $</p><p>知道hm1后，我们要在线网站解一下md5，就可以知道m0了，然后用来获取flag的函数一用就可以解出flag了，解出的m0如下，在线网站是<a href="https://cmd5.com/">md5在线解密破解</a></p><p><img src="https://cdn.nlark.com/yuque/0/2025/png/42554774/1737599382838-6cf1fd7c-001a-4ddb-bcbb-e53d56dc6138.png" alt=""></p><p>代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">s = <span class="number">7270513885194445005322518350289419893608325839878215682947885852347014936106128407554345668066935779849573932055239642406851308417046145495939362638652861562381316163080735160853285303356461796079298817982074998651099375222398758502559657988024308504098238446594559605603104540325738607539729848183025647146</span></span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">n = <span class="number">118167767283404647838357773955032661171703847685597271116789633496884884504237966404005641401909577369476550625894333528860763752286157264860218284704704444830864099870199623580368198306940575628872723737071517733553706154898255520538220530675603850372384339470410704813339357637359108745206967929184573003377</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_flag</span>(<span class="params">m0</span>):  <span class="comment"># 请用这个函数来转m得到flag</span></span><br><span class="line">    <span class="keyword">import</span> hashlib</span><br><span class="line">    flag = <span class="string">&#x27;flag&#123;th1s_1s_my_k3y:&#x27;</span> + m0 + <span class="string">&#x27;0x&#x27;</span> + hashlib.sha256(m0.encode()).hexdigest() + <span class="string">&#x27;&#125;&#x27;</span></span><br><span class="line">    <span class="built_in">print</span>(flag)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">hm_int = <span class="built_in">pow</span>(s, e, n)</span><br><span class="line">hm_str = long_to_bytes(hm_int).decode()</span><br><span class="line"><span class="built_in">print</span>(hm_str)  <span class="comment"># 86133884de98baada58a8c4de66e15b8</span></span><br><span class="line"></span><br><span class="line">m = <span class="string">&#x27;adm0n12&#x27;</span>  <span class="comment"># 通过 cmd5.com 查询到的结果</span></span><br><span class="line">get_flag(m)</span><br><span class="line"><span class="comment"># flag&#123;th1s_1s_my_k3y:adm0n120xbfab06114aa460b85135659e359fe443f9d91950ca95cbb2cbd6f88453e2b08b&#125;</span></span><br></pre></td></tr></table></figure><h2 id="easyECC"><a href="#easyECC" class="headerlink" title="easyECC"></a>easyECC</h2><p><strong>题目</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> * <span class="comment"># type: ignore</span></span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag</span><br><span class="line"></span><br><span class="line">p = <span class="number">64408890408990977312449920805352688472706861581336743385477748208693864804529</span></span><br><span class="line">a = <span class="number">111430905433526442875199303277188510507615671079377406541731212384727808735043</span></span><br><span class="line">b = <span class="number">89198454229925288228295769729512965517404638795380570071386449796440992672131</span></span><br><span class="line">E = EllipticCurve(GF(p),[a,b])</span><br><span class="line">m = E.random_point()</span><br><span class="line">G = E.random_point()</span><br><span class="line">k = <span class="number">86388708736702446338970388622357740462258632504448854088010402300997950626097</span></span><br><span class="line">K = k * G</span><br><span class="line">r = getPrime(<span class="number">256</span>)</span><br><span class="line">c1 = m + r * K</span><br><span class="line">c2 = r * G</span><br><span class="line">c_left =bytes_to_long(flag[:<span class="built_in">len</span>(flag)//<span class="number">2</span>]) * m[<span class="number">0</span>]</span><br><span class="line">c_right = bytes_to_long(flag[<span class="built_in">len</span>(flag)//<span class="number">2</span>:]) * m[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;c1 = <span class="subst">&#123;c1&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;c2 = <span class="subst">&#123;c2&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;cipher_left = <span class="subst">&#123;c_left&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;cipher_right = <span class="subst">&#123;c_right&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">c1 = (10968743933204598092696133780775439201414778610710138014434989682840359444219 : 50103014985350991132553587845849427708725164924911977563743169106436852927878 : 1)</span></span><br><span class="line"><span class="string">c2 = (16867464324078683910705186791465451317548022113044260821414766837123655851895 : 35017929439600128416871870160299373917483006878637442291141472473285240957511 : 1)</span></span><br><span class="line"><span class="string">c_left = 15994601655318787407246474983001154806876869424718464381078733967623659362582</span></span><br><span class="line"><span class="string">c_right = 3289163848384516328785319206783144958342012136997423465408554351179699716569</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>考点</strong>：ECC</p><p>很简单的一道ecc了，所以的值都给了，我们可以发现flag被分成两部分分别乘了m[0]和m[1]，所以我们只需要分别解出m[0]和m[1]就行，那么只要求出密文m就可以了，而k已经给了，该有的值也都有了，所以只要套解密代码求一下就出来了（代码也是看到一篇博客知道的）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 运行环境sagemath</span></span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line">p = <span class="number">64408890408990977312449920805352688472706861581336743385477748208693864804529</span></span><br><span class="line">a = <span class="number">111430905433526442875199303277188510507615671079377406541731212384727808735043</span></span><br><span class="line">b = <span class="number">89198454229925288228295769729512965517404638795380570071386449796440992672131</span></span><br><span class="line">k = <span class="number">86388708736702446338970388622357740462258632504448854088010402300997950626097</span></span><br><span class="line"></span><br><span class="line">E = EllipticCurve(GF(p),[a,b])</span><br><span class="line"></span><br><span class="line">c1 = E([<span class="number">10968743933204598092696133780775439201414778610710138014434989682840359444219</span>,<span class="number">50103014985350991132553587845849427708725164924911977563743169106436852927878</span>])</span><br><span class="line">c2 = E([<span class="number">16867464324078683910705186791465451317548022113044260821414766837123655851895</span>,<span class="number">35017929439600128416871870160299373917483006878637442291141472473285240957511</span>])</span><br><span class="line">cipher_left = <span class="number">15994601655318787407246474983001154806876869424718464381078733967623659362582</span></span><br><span class="line">cipher_right = <span class="number">3289163848384516328785319206783144958342012136997423465408554351179699716569</span></span><br><span class="line"></span><br><span class="line">m = c1 - k * c2</span><br><span class="line">left = cipher_left//m[<span class="number">0</span>]</span><br><span class="line">right = cipher_right//m[<span class="number">1</span>] <span class="comment"># 不能转int或Integer型，不然结果为0，不知道为什么，很奇怪</span></span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(<span class="built_in">int</span>(left))+long_to_bytes(<span class="built_in">int</span>(right)))</span><br></pre></td></tr></table></figure><p>得出flag为：<strong>flag{This_is_the_last_crypto_}</strong></p><h2 id="没e也能玩？"><a href="#没e也能玩？" class="headerlink" title="没e也能玩？"></a>没e也能玩？</h2><p><strong>题目</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag</span><br><span class="line"></span><br><span class="line">p = getPrime(<span class="number">1024</span>)</span><br><span class="line">q = getPrime(<span class="number">1024</span>)</span><br><span class="line">d = inverse(<span class="number">65537</span>,(p-<span class="number">1</span>)*(q-<span class="number">1</span>))</span><br><span class="line">dp = d %(p-<span class="number">1</span>)</span><br><span class="line">dq = d%(q-<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;c=<span class="subst">&#123;<span class="built_in">pow</span>(bytes_to_long(flag),e,p*q)&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;p=<span class="subst">&#123;p&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;q=<span class="subst">&#123;q&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;dp=<span class="subst">&#123;dp&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;dq=<span class="subst">&#123;dq&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">c=312026920216195772014255984174463085443866592575942633449581804171108045852080517840578408476885673600123673447592477875543106559822653280458539889975125069364584140981069913341705738633426978886491359036285144974311751490792757751756044409664421663980721578870582548395096887840688928684149014816557276765747135567714257184475027270111822159712532338590457693333403200971556224662094381891648467959054115723744963414673861964744567056823925630723343002325605154661959863849738333074326769879861280895388423162444746726568892877802824353858845944856881876742211956986853244518521508714633279380808950337611574412909</span></span><br><span class="line"><span class="string">p=108043725609186781791705090463399988837848128384507136697546885182257613493145758848215714322999196482303958182639388180063206708575175264502030010971971799850889123915580518613554382722069874295016841596099030496486069157061211091761273568631799006187376088457421848367280401857536410610375012371577177832001</span></span><br><span class="line"><span class="string">q=121590551121540247114817509966135120751936084528211093275386628666641298457070126234836053337681325952068673362753408092990553364818851439157868686131416391201519794244659155411228907897025948436021990520853498462677797392855335364006924106615008646396883330251028071418465977013680888333091554558623089051503</span></span><br><span class="line"><span class="string">dp=11282958604593959665264348980446305500804623200078838572989469798546944577064705030092746827389207634235443944672230537015008113180165395276742807804632116181385860873677969229460704569172318227491268503039531329141563655811632035522134920788501646372986281785901019732756566066694831838769040155501078857473</span></span><br><span class="line"><span class="string">dq=46575357360806054039250786123714177813397065260787208532360436486982363496441528434309234218672688812437737096579970959403617066243685956461527617935564293219447837324227893212131933165188205281564552085623483305721400518031651417947568896538797580895484369480168587284879837144688420597737619751280559493857</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>考点</strong>：dp，dq泄露</p><p>把最后一个式子变化一下可以得到</p><p>$ m = c^d + k \times  n = c^d + k\times p\times q $</p><p>两边同时分别模p和q，可以得到两个式子</p><p>$ m_p = m\mod p = c^d \mod p $</p><p>$ m_q = m \mod q = c^d \mod q $</p><p>由已知的第一二个式子我们可以知道</p><p>$ d = k\times（p - 1）+ dp $</p><p>再带入$ m_p = c^d \mod p $可以得到</p><p>$ m_p = c^{dp} \mod p $</p><p>即可以求出mp，mq</p><p>再分析一下这两个式子$ m_p = c^d \mod p $；$ m_q = c^d \mod q $我们可以得到</p><p>$ c^d = K\times p +m_p $</p><p>$ c^d = k\times q + m_q $</p><p>下式带入上式得到</p><p>$ K\times p = k\times q + m_q - m_p $</p><p>两边模q得到</p><p>$ K\times p = （m_q - m_p）\mod q $</p><p>两边乘一个p对q的逆元，得到</p><p>$ K = p’\times (m_q - m_p) \mod q $</p><p>求出K后再带入$ c^d = K\times p +m_p $就可以得到c^d，从而解出明文</p><p>下面是代码实现（代码就是短短几行）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">c=<span class="number">312026920216195772014255984174463085443866592575942633449581804171108045852080517840578408476885673600123673447592477875543106559822653280458539889975125069364584140981069913341705738633426978886491359036285144974311751490792757751756044409664421663980721578870582548395096887840688928684149014816557276765747135567714257184475027270111822159712532338590457693333403200971556224662094381891648467959054115723744963414673861964744567056823925630723343002325605154661959863849738333074326769879861280895388423162444746726568892877802824353858845944856881876742211956986853244518521508714633279380808950337611574412909</span></span><br><span class="line">p=<span class="number">108043725609186781791705090463399988837848128384507136697546885182257613493145758848215714322999196482303958182639388180063206708575175264502030010971971799850889123915580518613554382722069874295016841596099030496486069157061211091761273568631799006187376088457421848367280401857536410610375012371577177832001</span></span><br><span class="line">q=<span class="number">121590551121540247114817509966135120751936084528211093275386628666641298457070126234836053337681325952068673362753408092990553364818851439157868686131416391201519794244659155411228907897025948436021990520853498462677797392855335364006924106615008646396883330251028071418465977013680888333091554558623089051503</span></span><br><span class="line">dp=<span class="number">11282958604593959665264348980446305500804623200078838572989469798546944577064705030092746827389207634235443944672230537015008113180165395276742807804632116181385860873677969229460704569172318227491268503039531329141563655811632035522134920788501646372986281785901019732756566066694831838769040155501078857473</span></span><br><span class="line">dq=<span class="number">46575357360806054039250786123714177813397065260787208532360436486982363496441528434309234218672688812437737096579970959403617066243685956461527617935564293219447837324227893212131933165188205281564552085623483305721400518031651417947568896538797580895484369480168587284879837144688420597737619751280559493857</span></span><br><span class="line">I = gmpy2.invert(q,p)</span><br><span class="line">m1 = <span class="built_in">pow</span>(c,dp,p)</span><br><span class="line">m2 = <span class="built_in">pow</span>(c,dq,q)</span><br><span class="line">m = (((m1-m2)*I)%p)*q+m2</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(m))</span><br></pre></td></tr></table></figure><p>得出flag为：<strong>flag{No_course_e_can_play}</strong></p><h2 id="格格你好棒"><a href="#格格你好棒" class="headerlink" title="格格你好棒"></a>格格你好棒</h2><p><strong>题目</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">flag = <span class="string">b&#x27;******&#x27;</span></span><br><span class="line">m = bytes_to_long(flag)</span><br><span class="line"></span><br><span class="line">a = getPrime(<span class="number">1024</span>)</span><br><span class="line">b = getPrime(<span class="number">1536</span>)</span><br><span class="line"></span><br><span class="line">p = getPrime(<span class="number">512</span>)</span><br><span class="line">q = getPrime(<span class="number">512</span>)</span><br><span class="line">r = random.randint(<span class="number">2</span>**<span class="number">8</span>, <span class="number">2</span>**<span class="number">9</span>)</span><br><span class="line"><span class="keyword">assert</span> ((p+<span class="number">2</span>*r) * <span class="number">3</span>*a + q) % b &lt; <span class="number">70</span></span><br><span class="line"></span><br><span class="line">c = <span class="built_in">pow</span>(m, <span class="number">0x10001</span>, p*q)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;c =&#x27;</span>, c)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;a =&#x27;</span>, a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;b =&#x27;</span>, b)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">c = 75671328500214475056134178451562126288749723392201857886683373274067151096013132141603734799638338446362190819013087028001291030248155587072037662295281180020447012070607162188511029753418358484745755426924178896079516327814868477319474776976247356213687362358286132623490797882893844885783660230132191533753</span></span><br><span class="line"><span class="string">a = 99829685822966835958276444400403912618712610766908190376329921929407293564120124118477505585269077089315008380226830398574538050051718929826764449053677947419802792746249036134153510802052121734874555372027104653797402194532536147269634489642315951326590902954822775489385580372064589623985262480894316345817</span></span><br><span class="line"><span class="string">b = 2384473327543107262477269141248562917518395867365960655318142892515553817531439357316940290934095375085624218120779709239118821966188906173260307431682367028597612973683887401344727494920856592020970209197406324257478251502340099862501536622889923455273016634520507179507645734423860654584092233709560055803703801064153206431244982586989154685048854436858839309457140702847482240801158808592615931654823643778920270174913454238149949865979522520566288822366419746</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>考点</strong>：格攻击</p><p>关注断言<code>((p+2*r) * 3*a + q) % b &lt; 70</code></p><p>结果是一个小于70的数，相当于已知（爆破很快的），那么可以设成x，就可以写出下面这个样子</p><p>$ 3a(p+2r)+q=k\times b+x $</p><p>移项后就可以构造出下面这个格</p><p>$ \begin{align}(k,p+2r)\begin{pmatrix} b&amp;0 \\ 3a&amp;1 \end{pmatrix} =(x-q,p+2r)\end{align} $</p><p>复现时把3a放在上面发现不行，后面想了一下确实是，因为那样向量的大小就未知了，所以还是得像上面这样构造，构造好了sage跑出来后，我们得爆破一下x和r，这样就可以把p和q求出来，然后就标准rsa就行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sage</span></span><br><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#from tqdm import *</span></span><br><span class="line"> </span><br><span class="line">c = <span class="number">63970090307730335877809721304200883550049640814796584855311919788444862517887223732986595675409088426370045912297203884697715744287109423956446588104144896948474600924252971426757693149049788176140093762669257572818136268391076675502412382985137721246839664247241033867414491199483652292036165169353341736721</span></span><br><span class="line">a = <span class="number">169095591032842107903100075180638676605851796444162152675549552436872904263319011471312171874748357621716550291723406808357475877569622382251716493461335948233920131882151228308789748286370580144669281233868187101339909767205887609164975015547772498904502805235278789412044800177551190013789791754504529931231</span></span><br><span class="line">b = <span class="number">6064645365981235887306179215270851271718801644429108711725310294864007556801445216060166346337708059041073442260127725535139356989204300545757168654885686344461282796094266688090445897296901297377920786192865778222921548386038058555872765953356732109313734205459623312689902913019046944089470201948948652890006944620407534229412159275346491001935499731177063675134035072472112134333424000794637616785944210359606751334132126595044554089452160862222153579096125950</span></span><br><span class="line"> </span><br><span class="line">mat = [[b,<span class="number">0</span>],[<span class="number">3</span>*a,<span class="number">1</span>]]</span><br><span class="line">M = Matrix(ZZ,mat)</span><br><span class="line">qq,pp= M.LLL()[<span class="number">0</span>]  <span class="comment"># pp=p+2r,qq=x-q</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(pp)</span><br><span class="line"><span class="built_in">print</span>(qq)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">import</span> libnum</span><br><span class="line"></span><br><span class="line">pp = <span class="number">11955063068051544630946316468962078511069091314797871913634545080191072376861594574934166492638293328464581874921393333283491910392413726570145081889323365</span></span><br><span class="line"></span><br><span class="line">qq = <span class="number">8045923199163511894962326127962855996723489290534633417316373444301965842496393267385921312122459846420286036232396674929308891656715922685980889381589005</span></span><br><span class="line"></span><br><span class="line">c = <span class="number">63970090307730335877809721304200883550049640814796584855311919788444862517887223732986595675409088426370045912297203884697715744287109423956446588104144896948474600924252971426757693149049788176140093762669257572818136268391076675502412382985137721246839664247241033867414491199483652292036165169353341736721</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span> ** <span class="number">8</span>, <span class="number">2</span> ** <span class="number">9</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">70</span>):</span><br><span class="line">        p = pp - <span class="number">2</span> * i</span><br><span class="line">        q = qq + j</span><br><span class="line">        phi = (p - <span class="number">1</span>) * (q - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> gmpy2.gcd(phi, <span class="number">65537</span>) != <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        d = gmpy2.invert(<span class="number">65537</span>, phi)</span><br><span class="line">        n = p * q</span><br><span class="line">        m = <span class="built_in">pow</span>(c, d, n)</span><br><span class="line">        flag = libnum.n2s(<span class="built_in">int</span>(m))</span><br><span class="line">        <span class="keyword">if</span> <span class="string">b&#x27;flag&#x27;</span> <span class="keyword">in</span> flag:</span><br><span class="line">            <span class="built_in">print</span>(flag)</span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure><p>得出flag为：<strong>flag{u_are_@_master_of_latt1ce_Crypt0gr@phy}</strong></p><h2 id="学以致用"><a href="#学以致用" class="headerlink" title="学以致用"></a>学以致用</h2><p><strong>题目</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pad</span>(<span class="params">msg, nbits</span>):</span><br><span class="line">    <span class="comment"># pad了一下，仔细看看，别好不容易解出来了却没看到flag👼</span></span><br><span class="line">    pad_length = nbits - <span class="built_in">len</span>(msg) * <span class="number">8</span> - <span class="number">16</span></span><br><span class="line">    <span class="keyword">assert</span> pad_length &gt;= <span class="number">0</span></span><br><span class="line">    pad = random.getrandbits(pad_length).to_bytes((pad_length + <span class="number">7</span>) // <span class="number">8</span>, <span class="string">&quot;big&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> pad[:<span class="built_in">len</span>(pad)//<span class="number">2</span>] + <span class="string">b&quot;*&quot;</span> + msg + <span class="string">b&quot;*&quot;</span> + pad[<span class="built_in">len</span>(pad)//<span class="number">2</span>:]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    p = getPrime(<span class="number">1024</span>)</span><br><span class="line">    q = getPrime(<span class="number">1024</span>)</span><br><span class="line">    n = p*q</span><br><span class="line">    e = <span class="number">3</span></span><br><span class="line">    Nbits = <span class="number">2048</span></span><br><span class="line">    flag = <span class="string">b&#x27;flag&#123;?????&#125;&#x27;</span></span><br><span class="line">    gift = <span class="string">b&#x27;GoOd_byE_nEw_5t@r&#x27;</span></span><br><span class="line">    </span><br><span class="line">    flag1 = bytes_to_long(pad(flag[:<span class="built_in">len</span>(flag)//<span class="number">2</span>], Nbits-<span class="number">1</span>))</span><br><span class="line">    flag2 = bytes_to_long(pad(flag[<span class="built_in">len</span>(flag)//<span class="number">2</span>:], Nbits-<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;n =&#x27;</span>,n)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;c1 =&#x27;</span>, <span class="built_in">pow</span>(flag1, e, n))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;c2 =&#x27;</span>, <span class="built_in">pow</span>(flag2, e, n))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;c3 =&#x27;</span>, <span class="built_in">pow</span>(flag1 + flag2 + bytes_to_long(gift), e, n))</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">n = 17072342544150714171879132077494975311237876365187751353863158074020024719122755004761547735987417065592254800869192615807192722193500063611855839293567948232939959753821265552288663615847715716482887552271575844394350597695771100384136647573934496089812758071894172682439278191678102960768874456521879228612030147515967603129172838399997929502420254427798644285909855414606857035622716853274887875327854429218889083561315575947852542496274004905526475639809955792541187225767181054156589100604740904889686749740630242668885218256352895323426975708439512538106136364251265896292820030381364013059573189847777297569447</span></span><br><span class="line"><span class="string">c1 = 8101607280875746172766350224846108949565038929638360896232937975003150339090901182469578468557951846695946788093600030667125114278821199071782965501023811374181199570231982146140558093531414276709503788909827053368206185816004954186722115752214445121933300663507795347827581212475501366473409732970429363451582182754416452300394502623461416323078625518733218381660019606631159370121924340238446442870526675388637840247597153414432589505667533462640554984002009801576552636432097311654946821118444391557368410974979376926427631136361612166670672126393485023374083079458502529640435635667010258110833498681992307452573</span></span><br><span class="line"><span class="string">c2 = 14065316670254822235992102489645154264346717769174145550276846121970418622727279704820311564029018067692096462028836081822787148419633716320984336571241963063899868344606864544582504200779938815500203097282542495029462627888080005688408399148971228321637101593575245562307799087481654331283466914448740771421597528473762480363235531826325289856465115044393153437766069365345615753845871983173987642746989559569021189014927911398163825342784515926151087560415374622389991673648463353143338452444851518310480115818005343166067775633021475978188567581820594153290828348099804042221601767330439504722881619147742710013878</span></span><br><span class="line"><span class="string">c3 = 8094336015065392504689373372598739049074197380146388624166244791783464194652108498071001125262374720857829973449322589841225625661419126346483855290185428811872962549590383450801103516360026351074061702370835578483728260907424050069246549733800397741622131857548326468990903316013060783020272342924805005685309618377803255796096301560780471163963183261626005358125719453918037250566140850975432188309997670739064455030447411193814358481031511873409200036846039285091561677264719855466015739963580639810265153141785946270781617266125399412714450669028767459800001425248072586059267446605354915948603996477113109045600</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>考点</strong>：groebner_basis()</p><p>虽说原理还不理解，但是解题代码看的七七八八了，就是用groebner_basis()这个函数可以求出多项式的解来，格式是x减去所求值的一个多项式，所以取负，再取系数，就可以得到所求值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sage</span></span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes, bytes_to_long</span><br><span class="line"></span><br><span class="line">n = <span class="number">17072342544150714171879132077494975311237876365187751353863158074020024719122755004761547735987417065592254800869192615807192722193500063611855839293567948232939959753821265552288663615847715716482887552271575844394350597695771100384136647573934496089812758071894172682439278191678102960768874456521879228612030147515967603129172838399997929502420254427798644285909855414606857035622716853274887875327854429218889083561315575947852542496274004905526475639809955792541187225767181054156589100604740904889686749740630242668885218256352895323426975708439512538106136364251265896292820030381364013059573189847777297569447</span></span><br><span class="line">c1 = <span class="number">8101607280875746172766350224846108949565038929638360896232937975003150339090901182469578468557951846695946788093600030667125114278821199071782965501023811374181199570231982146140558093531414276709503788909827053368206185816004954186722115752214445121933300663507795347827581212475501366473409732970429363451582182754416452300394502623461416323078625518733218381660019606631159370121924340238446442870526675388637840247597153414432589505667533462640554984002009801576552636432097311654946821118444391557368410974979376926427631136361612166670672126393485023374083079458502529640435635667010258110833498681992307452573</span></span><br><span class="line">c2 = <span class="number">14065316670254822235992102489645154264346717769174145550276846121970418622727279704820311564029018067692096462028836081822787148419633716320984336571241963063899868344606864544582504200779938815500203097282542495029462627888080005688408399148971228321637101593575245562307799087481654331283466914448740771421597528473762480363235531826325289856465115044393153437766069365345615753845871983173987642746989559569021189014927911398163825342784515926151087560415374622389991673648463353143338452444851518310480115818005343166067775633021475978188567581820594153290828348099804042221601767330439504722881619147742710013878</span></span><br><span class="line">c3 = <span class="number">8094336015065392504689373372598739049074197380146388624166244791783464194652108498071001125262374720857829973449322589841225625661419126346483855290185428811872962549590383450801103516360026351074061702370835578483728260907424050069246549733800397741622131857548326468990903316013060783020272342924805005685309618377803255796096301560780471163963183261626005358125719453918037250566140850975432188309997670739064455030447411193814358481031511873409200036846039285091561677264719855466015739963580639810265153141785946270781617266125399412714450669028767459800001425248072586059267446605354915948603996477113109045600</span></span><br><span class="line">gift = <span class="string">b&#x27;GoOd_byE_nEw_5t@r&#x27;</span></span><br><span class="line"></span><br><span class="line">x, y = PolynomialRing(Zmod(n), <span class="string">&#x27;x, y&#x27;</span>).gens()</span><br><span class="line">f1 = x**<span class="number">3</span> - c1</span><br><span class="line">f2 = y**<span class="number">3</span> - c2</span><br><span class="line">f3 = (x + y + bytes_to_long(gift))**<span class="number">3</span> - c3</span><br><span class="line"></span><br><span class="line">gb = Ideal(f1, f2, f3).groebner_basis()</span><br><span class="line">f1, f2 = gb    <span class="comment"># 返回一个多项式</span></span><br><span class="line"></span><br><span class="line">flag1 = <span class="built_in">int</span>(-f1.coefficients()[<span class="number">1</span>])    <span class="comment"># 取负是为了求出m，因为上面多项式是x减去我们所求</span></span><br><span class="line"></span><br><span class="line">flag2 = <span class="built_in">int</span>(-f2.coefficients()[<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(flag1)</span><br><span class="line"><span class="comment"># 出题的时候加了给pad，大家得注意一下，flag在一堆trash中间，别做出了却没看见flag</span></span><br><span class="line"><span class="built_in">print</span>((long_to_bytes(flag1)).split(<span class="string">b&#x27;*&#x27;</span>)[<span class="number">2</span>]+(long_to_bytes(flag2).split(<span class="string">b&#x27;*&#x27;</span>)[<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line"><span class="comment"># b&#x27;flag&#123;W1Sh_you_Bec0me_an_excelL3nt_crypt0G2@pher&#125;&#x27;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> Crypto </tag>
            
            <tag> 复现 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Coopersmith</title>
      <link href="/2025/02/02/Coopersmith/"/>
      <url>/2025/02/02/Coopersmith/</url>
      
        <content type="html"><![CDATA[<p>偶遇题目，拼尽全力无法战胜，故深入学习</p><blockquote><p>参考文章，建议细细研读</p><p><a href="https://zhuanlan.zhihu.com/p/4783052681">https://zhuanlan.zhihu.com/p/4783052681</a></p><p><a href="https://www.math.auckland.ac.nz/~sgal018/crypto-book/ch19.pdf">https://www.math.auckland.ac.nz/~sgal018/crypto-book/ch19.pdf</a></p><p><a href="https://doc.sagemath.org/html/en/reference/polynomial_rings/sage/rings/polynomial/polynomial_modn_dense_ntl.html#sage.rings.polynomial.polynomial_modn_dense_ntl.small_roots">https://doc.sagemath.org/html/en/reference/polynomial_rings/sage/rings/polynomial/polynomial_modn_dense_ntl.html#sage.rings.polynomial.polynomial_modn_dense_ntl.small_roots</a></p><p><a href="https://www.ruanx.net/coppersmith/">https://www.ruanx.net/coppersmith/</a></p></blockquote><h1 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h1><p>设N是一个大整数，$ p \geq N^\beta $是 N 的一个因子，设 $ f(x) $ 是一个d阶(次数为d)的多项式，令$ X=\frac{1}{2}N^{\frac{1}{d} - \varepsilon} $，其中$ 0\le\varepsilon\le min(0.18,\frac{1}{d}) $，那么对于给定的$ (N,f(x)) $，有</p><ul><li>在模N意义下，可以快速求出$ f(x)=0 $满足$ \left | x \right | \le X $的全体正整数解（就是求出X以内的根）</li><li>给定$ \beta $，可以快速求出模p意义下较小的根（就是求模因子意义下的根，可以解决低位丢失类题目）</li></ul><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>有了这个定理，相信大家一定好奇为什么，为什么可以这么做，但是这个原理挺复杂的，站长现水平无法深入理解，但是大家可以点击上面的推荐文章（尤其那本书，感觉找到宝贝了），下面会简单讲一下我的理解，不一定对，建议直接看截图</p><p>就是把一个多项式看成一个多维向量，再构造成一个格，之后再运用LLL格基规约找到一个范数最小的向量，然后根据一个引理，就可以找到这个多项式的一个根。</p><p><img src="https://cdn.nlark.com/yuque/0/2025/png/42554774/1738330147438-9ce88761-e403-45ca-9811-bb123b71efc9.png" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2025/png/42554774/1738330127252-455ad20f-96b0-42e7-8691-069701d5bf34.png" alt=""></p><h1 id="small-roots"><a href="#small-roots" class="headerlink" title="small_roots"></a>small_roots</h1><p>知道这么一个定理后我们期望在代码层面实现它，这就要用到Sagemath里的small_roots这个函数，下面会具体介绍这个函数，首先放一个具体实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">R.&lt;x&gt; = PolynomialRing(Zmod(n), implementation=<span class="string">&#x27;NTL&#x27;</span>)</span><br><span class="line">P = p + x</span><br><span class="line">low_p = P.monic().small_roots(X = <span class="number">2</span>**<span class="number">340</span>, beta = <span class="number">0.4</span>)</span><br><span class="line"><span class="built_in">print</span>(low_p)</span><br></pre></td></tr></table></figure><blockquote><p>PolynomialRing ：构造多项式环</p><p>Zmod(n) ：模运算</p><p>implementation=’NTL’ ：执行 NTL</p><p>small_roots( X=？ , beta=？ , epsilon=？)：计算多项式的小整数根，返回结果是一个列表</p><p>X：根的绝对上界，比如说下面那道题目，上界就是2**340</p><p>beta：coopersmith里的一个参数，给定$ \beta $，以快速求出模某个p意义下较小的根，其中$ p\ge n^\beta $，是n的因数，$ \beta $一般取0.4</p><p>epsilon：也是coopersmith里的一个参数，程序默认好像是$ \beta/8 $，平时不太会用到这个参数，需要时加在beta后面就行</p><p>monic()：用于将多项式的首项系数归一化为1。它接受一个多项式作为参数，然后返回一个新的多项式，其中首项系数已经被归一化为1。这个过程可以简化多项式的表达式，使其更易于计算和分析。</p></blockquote><p>这样简单的使用方法就了解了，可以看看下面的题目，自己运用一下</p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="1-where-is-P"><a href="#1-where-is-P" class="headerlink" title="1.where is P?"></a>1.where is P?</h2><p><strong>题目</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line">m=bytes_to_long(<span class="string">b&#x27;XXXX&#x27;</span>)</span><br><span class="line">e=<span class="number">65537</span></span><br><span class="line">p=getPrime(<span class="number">1024</span>)</span><br><span class="line">q=getPrime(<span class="number">1024</span>)</span><br><span class="line">n=p*q</span><br><span class="line"><span class="built_in">print</span>(p)</span><br><span class="line">c=<span class="built_in">pow</span>(m,e,n)</span><br><span class="line">P=p&gt;&gt;<span class="number">340</span></span><br><span class="line"><span class="built_in">print</span>(P)</span><br><span class="line">a=<span class="built_in">pow</span>(P,<span class="number">3</span>,n)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;n=&quot;</span>,n)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;c=&quot;</span>,c)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a=&quot;</span>,a)</span><br><span class="line"><span class="comment">#n= 24479907029118467064460793139240403258697681144532146836881997837526487637306591893357774423547391867013441147680031968367449693796015901951120514250935018725570026327610524687128709707340727799633444550317834481416507364804274266363478822257132586592232042108076935945436358397787891169163821061005102693505011197453089873909085170776511350713452580692963748763166981047023704528272230392479728897831538235554137129584665886878574314566549330671483636900134584707867654841021494106881794644469229030140144595938886437242375435914268001721437309283611088568191856208951867342004280893021653793820874747638264412653721</span></span><br><span class="line"><span class="comment">#c= 6566517934961780069851397787369134601399136324586682773286046135297104713708615112015588908759927424841719937322574766875308296258325687730658550956691921018605724308665345526807393669538103819281108643141723589363068859617542807984954436567078438099854340705208503317269397632214274507740533638883597409138972287275965697689862321166613821995226000320597560745749780942467497435742492468670016480112957715214640939272457886646483560443432985954141177463448896521810457886108311082101521263110578485768091003174683555938678346359150123350656418123918738868598042533211541966786594006129134087145798672161268647536724</span></span><br><span class="line"><span class="comment">#a= 22184346235325197613876257964606959796734210361241668065837491428527234174610482874427139453643569493268653377061231169173874401139203757698022691973395609028489121048788465356158531144787135876251872262389742175830840373281181905217510352227396545981674450409488394636498629147806808635157820030290630290808150235068140864601098322473572121965126109735529553247807211711005936042322910065304489093415276688746634951081501428768318098925390576594162098506572668709475140964400043947851427774550253257759990959997691631511262768785787474750441024242552456956598974533625095249106992723798354594261566983135394923063605</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>考点</strong>：已知p高位，求低位 ；coopersmith</p><p>根据题目我们可以知道，是将p右移了340位，我们再次左移后得到的p就会缺失低位的340位，这时候我们就得用到small_roots函数（原理是coopersmith）来获取低位。</p><p>总的来说就是这个函数可以求一个解，那么我们构造$ f=p_{high}+x $（在模n情况下的解，给定$ \beta $就可以快速求出模某个b意义下较小的根，其中$ b\ge n^\beta $，是n的因数）</p><p>这样我们就可以知道p的低位，然后就可以知道p，之后就可以知道q，然后就RSA解密就行，但是题目没有直接给我们p的高位，而是a，a满足下面这个式子</p><p>$ a=p^3\mod n $</p><p>所以$ p^3=a+k*n $我们爆破一下k，判断是否可以开三次方，就可以求出p（求出来的p要再左移一下才是高位）</p><p>代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sage</span></span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">n= <span class="number">24479907029118467064460793139240403258697681144532146836881997837526487637306591893357774423547391867013441147680031968367449693796015901951120514250935018725570026327610524687128709707340727799633444550317834481416507364804274266363478822257132586592232042108076935945436358397787891169163821061005102693505011197453089873909085170776511350713452580692963748763166981047023704528272230392479728897831538235554137129584665886878574314566549330671483636900134584707867654841021494106881794644469229030140144595938886437242375435914268001721437309283611088568191856208951867342004280893021653793820874747638264412653721</span></span><br><span class="line">c= <span class="number">6566517934961780069851397787369134601399136324586682773286046135297104713708615112015588908759927424841719937322574766875308296258325687730658550956691921018605724308665345526807393669538103819281108643141723589363068859617542807984954436567078438099854340705208503317269397632214274507740533638883597409138972287275965697689862321166613821995226000320597560745749780942467497435742492468670016480112957715214640939272457886646483560443432985954141177463448896521810457886108311082101521263110578485768091003174683555938678346359150123350656418123918738868598042533211541966786594006129134087145798672161268647536724</span></span><br><span class="line">a= <span class="number">22184346235325197613876257964606959796734210361241668065837491428527234174610482874427139453643569493268653377061231169173874401139203757698022691973395609028489121048788465356158531144787135876251872262389742175830840373281181905217510352227396545981674450409488394636498629147806808635157820030290630290808150235068140864601098322473572121965126109735529553247807211711005936042322910065304489093415276688746634951081501428768318098925390576594162098506572668709475140964400043947851427774550253257759990959997691631511262768785787474750441024242552456956598974533625095249106992723798354594261566983135394923063605</span></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">    p = a+k*n</span><br><span class="line">    <span class="keyword">if</span> gmpy2.iroot(p,<span class="number">3</span>)[<span class="number">1</span>]:</span><br><span class="line">        <span class="built_in">print</span>(k)</span><br><span class="line">        <span class="built_in">print</span>(gmpy2.iroot(p,<span class="number">3</span>)[<span class="number">0</span>])</span><br><span class="line">p=<span class="number">148500014720728755901835170447203030242113125689825190413979909224639701026120883281188694701625473553602289432755479244507504340127322979884849883842306663453018960250560834067472479033116264539127330613635903666209920113813160301513820286874124210921593865507657148933555053341577090100101684021531775022459</span></span><br><span class="line">p=p&lt;&lt;<span class="number">340</span></span><br><span class="line"><span class="built_in">print</span>(p)</span><br><span class="line">R.&lt;x&gt; = PolynomialRing(Zmod(n), implementation=<span class="string">&#x27;NTL&#x27;</span>)</span><br><span class="line"></span><br><span class="line">P = p + x</span><br><span class="line">low_p = P.monic().small_roots(X = <span class="number">2</span>**<span class="number">340</span>, beta = <span class="number">0.4</span>)[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(p+low_p)</span><br><span class="line">p=p+low_p</span><br><span class="line">q=n//p</span><br><span class="line">n = p * q</span><br><span class="line">phin = (p - <span class="number">1</span>)*(q - <span class="number">1</span>)          <span class="comment"># 欧拉函数</span></span><br><span class="line">d = gmpy2.invert(e,phin)</span><br><span class="line">m = <span class="built_in">pow</span>(c,d,n)</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(m))</span><br><span class="line"></span><br><span class="line"><span class="comment"># LitCTF&#123;Y0U_hAV3_g0T_Th3_r1ghT_AnsW3r&#125;</span></span><br></pre></td></tr></table></figure><h2 id="2-easy-ya"><a href="#2-easy-ya" class="headerlink" title="2.easy_ya"></a>2.easy_ya</h2><p><strong>题目</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> flag <span class="keyword">import</span> flag</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gen</span>():</span><br><span class="line">    e = <span class="number">3</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            p = getPrime(<span class="number">512</span>)</span><br><span class="line">            q = getPrime(<span class="number">512</span>)</span><br><span class="line">            n = p*q</span><br><span class="line">            phi = (p-<span class="number">1</span>)*(q-<span class="number">1</span>)</span><br><span class="line">            d = inverse(e,phi)</span><br><span class="line">            <span class="keyword">return</span> p,q,d,n,e</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">p,q,d,n,e = gen()</span><br><span class="line">r = getPrime(<span class="number">512</span>)</span><br><span class="line">m = bytes_to_long(flag+os.urandom(<span class="number">32</span>))</span><br><span class="line">M = m%r</span><br><span class="line">c = <span class="built_in">pow</span>(m,e,n)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;r = %d&quot;</span>%r)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;M = %d&quot;</span>%M)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;n = %d&quot;</span>%n)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;e = %d&quot;</span>%e)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;c = %d&quot;</span>%c)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">r = 7996728164495259362822258548434922741290100998149465194487628664864256950051236186227986990712837371289585870678059397413537714250530572338774305952904473</span></span><br><span class="line"><span class="string">M = 4159518144549137412048572485195536187606187833861349516326031843059872501654790226936115271091120509781872925030241137272462161485445491493686121954785558</span></span><br><span class="line"><span class="string">n = 131552964273731742744001439326470035414270864348139594004117959631286500198956302913377947920677525319260242121507196043323292374736595943942956194902814842206268870941485429339132421676367167621812260482624743821671183297023718573293452354284932348802548838847981916748951828826237112194142035380559020560287</span></span><br><span class="line"><span class="string">e = 3</span></span><br><span class="line"><span class="string">c = 46794664006708417132147941918719938365671485176293172014575392203162005813544444720181151046818648417346292288656741056411780813044749520725718927535262618317679844671500204720286218754536643881483749892207516758305694529993542296670281548111692443639662220578293714396224325591697834572209746048616144307282</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>考点</strong>：coopersmith</p><p>一开始看到e很小，想到会不会是低密指数加密，用了那个脚本发现不行，爆不出来，说明得用别的方法，那只能关注<code>M = m%r</code>这个式子，我们可以得到$ m=M+k*r $</p><p>再根据rsa加密的式子，我们就可以得到下面这个多项式</p><p>$ c=m^e\mod n $</p><p>$ m^e-c=(M+k*r)^3-c=0\mod n $</p><p>所以$ f=(M+k*r)^3-c $，这样我们就可以根据small_roots()函数求k，唯一有点挑战的是k的上限我们不知道，得猜一下，实测2**80到2**255都可以求出k，这也说明了这个上界参数不是越大越好</p><p>具体代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">r = <span class="number">7996728164495259362822258548434922741290100998149465194487628664864256950051236186227986990712837371289585870678059397413537714250530572338774305952904473</span></span><br><span class="line">M = <span class="number">4159518144549137412048572485195536187606187833861349516326031843059872501654790226936115271091120509781872925030241137272462161485445491493686121954785558</span></span><br><span class="line">n = <span class="number">131552964273731742744001439326470035414270864348139594004117959631286500198956302913377947920677525319260242121507196043323292374736595943942956194902814842206268870941485429339132421676367167621812260482624743821671183297023718573293452354284932348802548838847981916748951828826237112194142035380559020560287</span></span><br><span class="line">e = <span class="number">3</span></span><br><span class="line">c = <span class="number">46794664006708417132147941918719938365671485176293172014575392203162005813544444720181151046818648417346292288656741056411780813044749520725718927535262618317679844671500204720286218754536643881483749892207516758305694529993542296670281548111692443639662220578293714396224325591697834572209746048616144307282</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R.&lt;x&gt; = PolynomialRing(Zmod(n), implementation=<span class="string">&#x27;NTL&#x27;</span>)</span><br><span class="line"></span><br><span class="line">f = (M + x*r)**<span class="number">3</span>-c</span><br><span class="line">k = f.monic().small_roots(X = <span class="number">2</span>**<span class="number">80</span>, beta = <span class="number">0.4</span>)[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(k)</span><br><span class="line">k=<span class="number">810968823598060539864535</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(M+k*r))</span><br><span class="line"></span><br><span class="line"><span class="comment"># flag&#123;53a2e494-964d-4506-a2c4-c34b9475dedd&#125;</span></span><br></pre></td></tr></table></figure><h2 id="3-baby-xor"><a href="#3-baby-xor" class="headerlink" title="3.baby_xor"></a>3.baby_xor</h2><p><strong>题目</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag</span><br><span class="line"></span><br><span class="line">m = bytes_to_long(flag)</span><br><span class="line"><span class="keyword">assert</span> <span class="built_in">len</span>(flag)==<span class="number">32</span></span><br><span class="line">p = getPrime(<span class="number">512</span>)</span><br><span class="line">q = getPrime(<span class="number">512</span>)</span><br><span class="line">n = p*q</span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">c1 = p^m</span><br><span class="line">c2 = <span class="built_in">pow</span>(m,e,n)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;n = <span class="subst">&#123;n&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;c1 = <span class="subst">&#123;c1&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;c2 = <span class="subst">&#123;c2&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">n = 139167681803392690594490403105432649693546256181767408269202101512534988406137879788255103631885736461742577594980136624933914700779445704490217419248411578290305101891222576080645870988658334799437317221565839991979543660824098367011942169305111105129234902517835649895908656770416774539906212596072334423407</span></span><br><span class="line"><span class="string">c1 = 11201139662236758800406931253538295757259990870588609533820056210585752522925690049252488581929717556881067021381940083808024384402885422258545946243513996</span></span><br><span class="line"><span class="string">c2 = 112016152270171196606652761990170033221036025260883289104273504703557624964071464062375228351458191745141525003775876044271210498526920529385038130932141551598616579917681815276713386113932345056134302042399379895915706991873687943357627747262597883603999621939794450743982662393955266685255577026078256473601</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>考点</strong>：coopersmith</p><blockquote><p><a href="https://www.math.auckland.ac.nz/~sgal018/crypto-book/ch19.pdf">https://www.math.auckland.ac.nz/~sgal018/crypto-book/ch19.pdf</a> 很好的一本书，偶然发现</p></blockquote><p>很明显，我们得从<code>c1 = p^m</code>这个式子入手，因为<code>len(flag)==32</code>，这就相当于256位，所以p的前256位是正常的，就是低位缺失了，用small_roots函数求低位，但是发现求不出来，后面查了一下才发现是知道应该是高位不够，得再爆破出一部分（看了文献才知道小根好像得小于$ \frac{1}{2\sqrt2}N^{\frac{1}{4}-\varepsilon} $）</p><p>网上查了代码，如下（导入的tqdm库就是给一个进度条，好看一点，真的爆了好久好久）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">n = <span class="number">139167681803392690594490403105432649693546256181767408269202101512534988406137879788255103631885736461742577594980136624933914700779445704490217419248411578290305101891222576080645870988658334799437317221565839991979543660824098367011942169305111105129234902517835649895908656770416774539906212596072334423407</span></span><br><span class="line">c1 = <span class="number">11201139662236758800406931253538295757259990870588609533820056210585752522925690049252488581929717556881067021381940083808024384402885422258545946243513996</span></span><br><span class="line">e=<span class="number">65537</span></span><br><span class="line">pbits = <span class="number">512</span></span><br><span class="line">p_high = c1 &gt;&gt; <span class="number">256</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> trange(<span class="number">2</span>**<span class="number">8</span>):</span><br><span class="line">     p4 = p_high&lt;&lt;<span class="number">8</span></span><br><span class="line">     p4 = p4 + i</span><br><span class="line">     kbits = pbits - p4.nbits()</span><br><span class="line">     p4 = p4 &lt;&lt; kbits</span><br><span class="line">     PR.&lt;x&gt; = PolynomialRing(Zmod(n))</span><br><span class="line">     f = x + p4</span><br><span class="line">     roots = f.small_roots(X=<span class="number">2</span>^kbits, beta=<span class="number">0.4</span>, epsilon=<span class="number">0.01</span>)</span><br><span class="line">     <span class="keyword">if</span> roots:</span><br><span class="line">         p = p4 + <span class="built_in">int</span>(roots[<span class="number">0</span>])</span><br><span class="line">         <span class="keyword">break</span></span><br><span class="line"><span class="built_in">print</span>(p)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 11201139662236758800406931253538295757259990870588609533820056210585752522925662842097418194280333596411677923137891577493678147771013147838272857867768049</span></span><br></pre></td></tr></table></figure><p>爆出来p就可以基本RSA解密了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="number">139167681803392690594490403105432649693546256181767408269202101512534988406137879788255103631885736461742577594980136624933914700779445704490217419248411578290305101891222576080645870988658334799437317221565839991979543660824098367011942169305111105129234902517835649895908656770416774539906212596072334423407</span></span><br><span class="line">e=<span class="number">65537</span></span><br><span class="line">p=<span class="number">11201139662236758800406931253538295757259990870588609533820056210585752522925662842097418194280333596411677923137891577493678147771013147838272857867768049</span></span><br><span class="line">q=n//p</span><br><span class="line">c = <span class="number">112016152270171196606652761990170033221036025260883289104273504703557624964071464062375228351458191745141525003775876044271210498526920529385038130932141551598616579917681815276713386113932345056134302042399379895915706991873687943357627747262597883603999621939794450743982662393955266685255577026078256473601</span></span><br><span class="line"></span><br><span class="line">phin = (p - <span class="number">1</span>)*(q - <span class="number">1</span>)          </span><br><span class="line">d = gmpy2.invert(e,phin)       </span><br><span class="line"></span><br><span class="line">m = <span class="built_in">pow</span>(c,d,n)</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(m))</span><br><span class="line"></span><br><span class="line"><span class="comment"># LitCTF&#123;oh!!!!coppersmith_is_fun&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> coopersmith </tag>
            
            <tag> CTF </tag>
            
            <tag> Crypto </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对称密码—流密码</title>
      <link href="/2025/01/22/%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%81%E2%80%94%E6%B5%81%E5%AF%86%E7%A0%81/"/>
      <url>/2025/01/22/%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%81%E2%80%94%E6%B5%81%E5%AF%86%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h1 id="RC4"><a href="#RC4" class="headerlink" title="RC4"></a>RC4</h1><h2 id="加密流程"><a href="#加密流程" class="headerlink" title="加密流程"></a>加密流程</h2><h3 id="初始化算法-KSA"><a href="#初始化算法-KSA" class="headerlink" title="初始化算法(KSA)"></a><strong>初始化算法(KSA)</strong></h3><p><strong>Step</strong>1：先生成一个key，自定义。</p><p><strong>Step2</strong>：生成一个S盒，S盒有256个元素，分别是0，1，2，······，255。</p><p><img src="https://cdn.nlark.com/yuque/0/2025/png/42554774/1737530118391-e6a0f588-432c-419e-8d43-7dac2223eaff.png" alt=""></p><p><strong>Step3</strong>：生成一个K盒，同样是256个元素，这个K盒用key来填充，如果key是345，那么就3，4，5，3，4，5，3，4，5······这样一直重复填充下去。</p><p><img src="https://cdn.nlark.com/yuque/0/2025/png/42554774/1737530138496-f233326e-ce25-4e35-a533-5e8e827558d1.png" alt=""></p><p><strong>Step4</strong>：利用K盒来打乱我们刚刚生成的S盒，这个是通过一个规定的转换式子，每做一次，就交换S盒里的两个值。</p><p><img src="https://cdn.nlark.com/yuque/0/2025/png/42554774/1737439889235-473701e8-5e24-4bab-b845-3c8eaad335bf.png?x-oss-process=image%2Fformat%2Cwebp" alt=""></p><p>eg：按上面我们那个K表打乱后的S表如下，大家可以自己试一下（循环了七次）</p><p><img src="https://cdn.nlark.com/yuque/0/2025/png/42554774/1737530320751-f4ff1e23-f968-42bb-94c7-88b6055188d4.png" alt=""></p><h3 id="伪随机子密码生成算法（PRGA"><a href="#伪随机子密码生成算法（PRGA" class="headerlink" title="伪随机子密码生成算法（PRGA)"></a><strong>伪随机子密码生成算法（PRGA)</strong></h3><p>这一步是为了生成一个新盒，这个新盒里是一些伪随机的子密码，用来加密我们的明文，这个生成过程也有规定的式子，如下</p><p><img src="https://cdn.nlark.com/yuque/0/2025/png/42554774/1737440962165-c5c6764c-3539-4afa-8620-194787c452dc.png?x-oss-process=image%2Fformat%2Cwebp" alt=""></p><p>上图是用我们之前的K盒直接存储新生成的伪随机子密码，这无可厚非，只要S盒初始化过后（打乱后）K盒就没什么用了。</p><p>之后就是加密过程，就是用我们最后得到的那个子密码来和明文做异或，得到密文。</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="notRC4"><a href="#notRC4" class="headerlink" title="notRC4"></a>notRC4</h3><p><strong>题目</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> md5</span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Oo0</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.O0 = [<span class="number">0</span>] * <span class="number">256</span></span><br><span class="line">        <span class="variable language_">self</span>.Ooo = <span class="number">0</span></span><br><span class="line">        <span class="variable language_">self</span>.Ooo0 = [<span class="number">0</span>] * <span class="number">256</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">            <span class="variable language_">self</span>.O0[i] = i</span><br><span class="line">        <span class="variable language_">self</span>.oO0 = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">OO0</span>(<span class="params">self, oO0</span>):</span><br><span class="line">        l = <span class="built_in">len</span>(oO0)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">            <span class="variable language_">self</span>.Ooo0[i] = oO0[i % l]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">            <span class="variable language_">self</span>.oO0 = (<span class="variable language_">self</span>.oO0 + <span class="variable language_">self</span>.O0[i] + <span class="variable language_">self</span>.Ooo0[i]) % <span class="number">256</span></span><br><span class="line">            <span class="variable language_">self</span>.O0[i], <span class="variable language_">self</span>.O0[<span class="variable language_">self</span>.oO0] = <span class="variable language_">self</span>.O0[<span class="variable language_">self</span>.oO0], <span class="variable language_">self</span>.O0[i]</span><br><span class="line">        <span class="variable language_">self</span>.Ooo = <span class="variable language_">self</span>.oO0 = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">OO0o</span>(<span class="params">self, length</span>):</span><br><span class="line">        O = []</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">            <span class="variable language_">self</span>.Ooo = (<span class="variable language_">self</span>.Ooo + <span class="number">1</span>) % <span class="number">256</span></span><br><span class="line">            <span class="variable language_">self</span>.oO0 = (<span class="variable language_">self</span>.oO0 + <span class="variable language_">self</span>.O0[<span class="variable language_">self</span>.Ooo]) % <span class="number">256</span></span><br><span class="line">            <span class="variable language_">self</span>.O0[<span class="variable language_">self</span>.Ooo], <span class="variable language_">self</span>.O0[<span class="variable language_">self</span>.oO0] = <span class="variable language_">self</span>.O0[<span class="variable language_">self</span>.oO0], <span class="variable language_">self</span>.O0[<span class="variable language_">self</span>.Ooo]</span><br><span class="line">            t = (<span class="variable language_">self</span>.O0[<span class="variable language_">self</span>.Ooo] + <span class="variable language_">self</span>.O0[<span class="variable language_">self</span>.oO0]) % <span class="number">256</span></span><br><span class="line">            O.append(<span class="variable language_">self</span>.O0[t])</span><br><span class="line">        <span class="built_in">print</span>(<span class="variable language_">self</span>.O0)</span><br><span class="line">        <span class="keyword">return</span> O</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">xor</span>(<span class="params">s1, s2</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">bytes</span>(<span class="built_in">map</span>((<span class="keyword">lambda</span> x: x[<span class="number">0</span>] ^ x[<span class="number">1</span>]), <span class="built_in">zip</span>(s1, s2)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">enc</span>(<span class="params">msg</span>):</span><br><span class="line">    Oo0oO = Oo0()</span><br><span class="line">    Oo0oO.OO0(md5(msg).digest()[:<span class="number">8</span>])</span><br><span class="line">    O0O = Oo0oO.OO0o(<span class="built_in">len</span>(msg))</span><br><span class="line">    <span class="keyword">return</span> xor(msg, O0O)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(enc(flag))</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">s = [166, 163, 208, 147, 181, 152, 69, 90, 253, 114, 150, 255, 218, 220, 34, 74, 63, 201, 70, 115, 233, 96, 43, 169, 103, 191, 14, 149, 143, 25, 105, 93, 199, 246, 51, 75, 20, 5, 107, 3, 52, 135, 111, 139, 113, 47, 184, 76, 161, 174, 23, 30, 173, 72, 198, 56, 85, 55, 106, 126, 244, 223, 104, 29, 112, 148, 219, 118, 165, 59, 98, 175, 125, 100, 17, 16, 108, 6, 214, 140, 130, 206, 89, 62, 4, 236, 251, 91, 28, 45, 18, 53, 1, 144, 193, 133, 73, 44, 57, 88, 250, 204, 177, 67, 120, 21, 79, 71, 2, 185, 211, 200, 65, 234, 117, 9, 226, 142, 230, 209, 132, 248, 242, 196, 101, 81, 238, 247, 119, 179, 131, 229, 94, 50, 22, 183, 24, 158, 190, 222, 155, 172, 19, 12, 225, 10, 189, 232, 146, 227, 212, 210, 31, 164, 138, 78, 122, 176, 121, 0, 194, 186, 162, 160, 188, 168, 216, 153, 37, 252, 127, 145, 33, 82, 58, 170, 61, 254, 136, 207, 8, 237, 159, 36, 239, 95, 178, 167, 182, 102, 27, 123, 60, 129, 42, 26, 99, 39, 97, 40, 235, 205, 7, 49, 202, 197, 109, 195, 245, 171, 180, 15, 46, 83, 48, 156, 92, 249, 38, 32, 203, 41, 124, 54, 217, 134, 154, 35, 157, 128, 137, 221, 84, 86, 215, 213, 80, 11, 116, 141, 241, 64, 224, 87, 77, 187, 68, 192, 151, 240, 13, 228, 231, 66, 110, 243]</span></span><br><span class="line"><span class="string">enc = b&quot;]7\xab\xc9\xd8\x90\x1f\xd2OP\xad\x87&#x27;0\xe1\xff=~&quot;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>考点</strong>：rc4，异或</p><blockquote><p><a href="https://cn-sec.com/archives/3093479.html">https://cn-sec.com/archives/3093479.html</a> 可以参考这篇博客理解</p><p><a href="https://www.bilibili.com/video/BV1G64y1Y7p4/?spm_id_from=333.337.search-card.all.click&amp;vd_source=a01a62f772bf2e577e11004dfef0bde1">https://www.bilibili.com/video/BV1G64y1Y7p4/?spm_id_from=333.337.search-card.all.click&amp;vd_source=a01a62f772bf2e577e11004dfef0bde1</a> 这个视频也很棒</p></blockquote><p>虽然题目是notRC4，但流程上就是RC4，所以先了解一下RC4的过程。</p><p>首先是<strong>初始化算法(KSA)</strong></p><p>首先生成一个S盒，S盒有256个元素，分别是0，1，2，······，255，对应题目以下代码（代码只截取重要部分，建议定位到题目中分析）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">self</span>.O0 = [<span class="number">0</span>] * <span class="number">256</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">            <span class="variable language_">self</span>.O0[i] = i</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>再生成一个K盒，同样是256个元素，这个K盒用key来填充，如果key是123，那么就1，2，3，1，2，3，1，2，3······这样一直重复填充下去，直到填充完毕，对应下面代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">self</span>.Ooo0 = [<span class="number">0</span>] * <span class="number">256</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">OO0</span>(<span class="params">self, oO0</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">        <span class="variable language_">self</span>.Ooo0[i] = oO0[i % l]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接着我们要利用K盒来打乱我们刚刚生成的S盒，这个是通过一个规定的转换式子，每做一次，就交换S盒里的两个值，如下</p><p><img src="https://cdn.nlark.com/yuque/0/2025/png/42554774/1737439889235-473701e8-5e24-4bab-b845-3c8eaad335bf.png" alt=""></p><p>因为S[i]是固定的，所以打乱完全取决于K盒，打乱后的S盒我们称为初始化后的S盒，对应以下代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">           <span class="variable language_">self</span>.oO0 = (<span class="variable language_">self</span>.oO0 + <span class="variable language_">self</span>.O0[i] + <span class="variable language_">self</span>.Ooo0[i]) % <span class="number">256</span></span><br><span class="line">           <span class="variable language_">self</span>.O0[i], <span class="variable language_">self</span>.O0[<span class="variable language_">self</span>.oO0] = <span class="variable language_">self</span>.O0[<span class="variable language_">self</span>.oO0], <span class="variable language_">self</span>.O0[i]</span><br><span class="line">       <span class="variable language_">self</span>.Ooo = <span class="variable language_">self</span>.oO0 = <span class="number">0</span><span class="comment"># 这里是为了后面的使用，所以再次赋0，主要是上面部分</span></span><br></pre></td></tr></table></figure><p>接着是<strong>伪随机子密码生成算法（PRGA)、加密阶段</strong></p><p>这一步是为了生成一个新盒，这个新盒里是一些伪随机的子密码，用来加密我们的明文，这个生成过程也有规定的式子，如下</p><p><img src="https://cdn.nlark.com/yuque/0/2025/png/42554774/1737440962165-c5c6764c-3539-4afa-8620-194787c452dc.png" alt=""></p><p>上图是用我们之前的K盒直接存储新生成的伪随机子密码，这无可厚非，只要S盒初始化过后（打乱后）K盒就没什么用了。这一部分对应题目代码如下（题目是用一个新的列表放子密码的，即O）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">OO0o</span>(<span class="params">self, length</span>):</span><br><span class="line">        O = []</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">            <span class="variable language_">self</span>.Ooo = (<span class="variable language_">self</span>.Ooo + <span class="number">1</span>) % <span class="number">256</span></span><br><span class="line">            <span class="variable language_">self</span>.oO0 = (<span class="variable language_">self</span>.oO0 + <span class="variable language_">self</span>.O0[<span class="variable language_">self</span>.Ooo]) % <span class="number">256</span></span><br><span class="line">            <span class="variable language_">self</span>.O0[<span class="variable language_">self</span>.Ooo], <span class="variable language_">self</span>.O0[<span class="variable language_">self</span>.oO0] = <span class="variable language_">self</span>.O0[<span class="variable language_">self</span>.oO0], <span class="variable language_">self</span>.O0[<span class="variable language_">self</span>.Ooo]</span><br><span class="line">            t = (<span class="variable language_">self</span>.O0[<span class="variable language_">self</span>.Ooo] + <span class="variable language_">self</span>.O0[<span class="variable language_">self</span>.oO0]) % <span class="number">256</span></span><br><span class="line">            O.append(<span class="variable language_">self</span>.O0[t])</span><br><span class="line">        <span class="built_in">print</span>(<span class="variable language_">self</span>.O0)</span><br><span class="line">        <span class="keyword">return</span> O</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>之后就是加密过程，就是用我们最后得到的那个子密码来和明文做异或，得到密文。对应下面这段代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">xor</span>(<span class="params">s1, s2</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">bytes</span>(<span class="built_in">map</span>((<span class="keyword">lambda</span> x: x[<span class="number">0</span>] ^ x[<span class="number">1</span>]), <span class="built_in">zip</span>(s1, s2)))<span class="comment"># zip会返回一个元组的列表，返回列表长度与最短的对象相同</span></span><br><span class="line">xor(msg, O0O)<span class="comment"># O0O就是上面return的O</span></span><br></pre></td></tr></table></figure><p>到此，题目的加密过程完毕，输出了最后的S盒和密文</p><p>这道题感觉难就难变量定义的稀奇古怪，让人没有看下去的欲望，如果分析不下去了建议休息会再看，不然真的脑壳痛（恼）</p><p>那么我们要怎么求解明文呢？就要用到异或的知识。密文是通过异或得到的，要变回去，我们就得知道子密码盒，然后再异或一次就可以得到flag了，所以现在目的是求子密码盒。</p><p>这里我们就得考虑flag的格式，我们可以想到flag肯定是以’}’结尾的，这个已知，我们和密文异或，就可以得到一个子密码，即S[t]，知道S[t]以后，我们通过index函数就可以查列表的下标，于是我们就可以知道t</p><p>t知道以后我们关注这个式子<code>t = (self.O0[self.Ooo] + self.O0[self.oO0]) % 256</code>我们换种写法可能好看一点<code>t = (S[i] + S[j]) %256</code>，S[i]是已知的（最后一次i就是明文的长度，S盒又是知道的，所以S[i]已知）我们就可以得出S[j]，这样我们通过index就可以知道j，i和j都知道以后我们就可以逆推回去，把每一次的S[t]都算出来，这样和密文异或就可以把明文求出了，可以在纸上写一下，会很清晰</p><p><img src="https://cdn.nlark.com/yuque/0/2025/jpeg/42554774/1737444427312-6ad0c4ab-1185-4814-ad0e-98dbf1409cb1.jpeg" alt=""></p><p>代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">s = [<span class="number">166</span>, <span class="number">163</span>, <span class="number">208</span>, <span class="number">147</span>, <span class="number">181</span>, <span class="number">152</span>, <span class="number">69</span>, <span class="number">90</span>, <span class="number">253</span>, <span class="number">114</span>, <span class="number">150</span>, <span class="number">255</span>, <span class="number">218</span>, <span class="number">220</span>, <span class="number">34</span>, <span class="number">74</span>, <span class="number">63</span>, <span class="number">201</span>, <span class="number">70</span>, <span class="number">115</span>, <span class="number">233</span>, <span class="number">96</span>, <span class="number">43</span>, <span class="number">169</span>, <span class="number">103</span>, <span class="number">191</span>, <span class="number">14</span>, <span class="number">149</span>, <span class="number">143</span>, <span class="number">25</span>, <span class="number">105</span>, <span class="number">93</span>, <span class="number">199</span>, <span class="number">246</span>, <span class="number">51</span>, <span class="number">75</span>, <span class="number">20</span>, <span class="number">5</span>, <span class="number">107</span>, <span class="number">3</span>, <span class="number">52</span>, <span class="number">135</span>, <span class="number">111</span>, <span class="number">139</span>, <span class="number">113</span>, <span class="number">47</span>, <span class="number">184</span>, <span class="number">76</span>, <span class="number">161</span>, <span class="number">174</span>, <span class="number">23</span>, <span class="number">30</span>, <span class="number">173</span>, <span class="number">72</span>, <span class="number">198</span>, <span class="number">56</span>, <span class="number">85</span>, <span class="number">55</span>, <span class="number">106</span>, <span class="number">126</span>, <span class="number">244</span>, <span class="number">223</span>, <span class="number">104</span>, <span class="number">29</span>, <span class="number">112</span>, <span class="number">148</span>, <span class="number">219</span>, <span class="number">118</span>, <span class="number">165</span>, <span class="number">59</span>, <span class="number">98</span>, <span class="number">175</span>, <span class="number">125</span>, <span class="number">100</span>, <span class="number">17</span>, <span class="number">16</span>, <span class="number">108</span>, <span class="number">6</span>, <span class="number">214</span>, <span class="number">140</span>, <span class="number">130</span>, <span class="number">206</span>, <span class="number">89</span>, <span class="number">62</span>, <span class="number">4</span>, <span class="number">236</span>, <span class="number">251</span>, <span class="number">91</span>, <span class="number">28</span>, <span class="number">45</span>, <span class="number">18</span>, <span class="number">53</span>, <span class="number">1</span>, <span class="number">144</span>, <span class="number">193</span>, <span class="number">133</span>, <span class="number">73</span>, <span class="number">44</span>, <span class="number">57</span>, <span class="number">88</span>, <span class="number">250</span>, <span class="number">204</span>, <span class="number">177</span>, <span class="number">67</span>, <span class="number">120</span>, <span class="number">21</span>, <span class="number">79</span>, <span class="number">71</span>, <span class="number">2</span>, <span class="number">185</span>, <span class="number">211</span>, <span class="number">200</span>, <span class="number">65</span>, <span class="number">234</span>, <span class="number">117</span>, <span class="number">9</span>, <span class="number">226</span>, <span class="number">142</span>, <span class="number">230</span>, <span class="number">209</span>, <span class="number">132</span>, <span class="number">248</span>, <span class="number">242</span>, <span class="number">196</span>, <span class="number">101</span>, <span class="number">81</span>, <span class="number">238</span>, <span class="number">247</span>, <span class="number">119</span>, <span class="number">179</span>, <span class="number">131</span>, <span class="number">229</span>, <span class="number">94</span>, <span class="number">50</span>, <span class="number">22</span>, <span class="number">183</span>, <span class="number">24</span>, <span class="number">158</span>, <span class="number">190</span>, <span class="number">222</span>, <span class="number">155</span>, <span class="number">172</span>, <span class="number">19</span>, <span class="number">12</span>, <span class="number">225</span>, <span class="number">10</span>, <span class="number">189</span>, <span class="number">232</span>, <span class="number">146</span>, <span class="number">227</span>, <span class="number">212</span>, <span class="number">210</span>, <span class="number">31</span>, <span class="number">164</span>, <span class="number">138</span>, <span class="number">78</span>, <span class="number">122</span>, <span class="number">176</span>, <span class="number">121</span>, <span class="number">0</span>, <span class="number">194</span>, <span class="number">186</span>, <span class="number">162</span>, <span class="number">160</span>, <span class="number">188</span>, <span class="number">168</span>, <span class="number">216</span>, <span class="number">153</span>, <span class="number">37</span>, <span class="number">252</span>, <span class="number">127</span>, <span class="number">145</span>, <span class="number">33</span>, <span class="number">82</span>, <span class="number">58</span>, <span class="number">170</span>, <span class="number">61</span>, <span class="number">254</span>, <span class="number">136</span>, <span class="number">207</span>, <span class="number">8</span>, <span class="number">237</span>, <span class="number">159</span>, <span class="number">36</span>, <span class="number">239</span>, <span class="number">95</span>, <span class="number">178</span>, <span class="number">167</span>, <span class="number">182</span>, <span class="number">102</span>, <span class="number">27</span>, <span class="number">123</span>, <span class="number">60</span>, <span class="number">129</span>, <span class="number">42</span>, <span class="number">26</span>, <span class="number">99</span>, <span class="number">39</span>, <span class="number">97</span>, <span class="number">40</span>, <span class="number">235</span>, <span class="number">205</span>, <span class="number">7</span>, <span class="number">49</span>, <span class="number">202</span>, <span class="number">197</span>, <span class="number">109</span>, <span class="number">195</span>, <span class="number">245</span>, <span class="number">171</span>, <span class="number">180</span>, <span class="number">15</span>, <span class="number">46</span>, <span class="number">83</span>, <span class="number">48</span>, <span class="number">156</span>, <span class="number">92</span>, <span class="number">249</span>, <span class="number">38</span>, <span class="number">32</span>, <span class="number">203</span>, <span class="number">41</span>, <span class="number">124</span>, <span class="number">54</span>, <span class="number">217</span>, <span class="number">134</span>, <span class="number">154</span>, <span class="number">35</span>, <span class="number">157</span>, <span class="number">128</span>, <span class="number">137</span>, <span class="number">221</span>, <span class="number">84</span>, <span class="number">86</span>, <span class="number">215</span>, <span class="number">213</span>, <span class="number">80</span>, <span class="number">11</span>, <span class="number">116</span>, <span class="number">141</span>, <span class="number">241</span>, <span class="number">64</span>, <span class="number">224</span>, <span class="number">87</span>, <span class="number">77</span>, <span class="number">187</span>, <span class="number">68</span>, <span class="number">192</span>, <span class="number">151</span>, <span class="number">240</span>, <span class="number">13</span>, <span class="number">228</span>, <span class="number">231</span>, <span class="number">66</span>, <span class="number">110</span>, <span class="number">243</span>]</span><br><span class="line">a = <span class="string">b&quot;]7\xab\xc9\xd8\x90\x1f\xd2OP\xad\x87&#x27;0\xe1\xff=~&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">t=s.index(<span class="built_in">ord</span>(<span class="string">&#x27;&#125;&#x27;</span>)^<span class="built_in">ord</span>(<span class="string">&#x27;~&#x27;</span>))</span><br><span class="line">i=<span class="number">18</span></span><br><span class="line">sj=(t-s[i])%<span class="number">256</span></span><br><span class="line">j=s.index(sj)</span><br><span class="line">s[i],s[j]=s[j],s[i]</span><br><span class="line">j=(j-s[i])%<span class="number">256</span></span><br><span class="line">i=i-<span class="number">1</span></span><br><span class="line">t=(s[i]+s[j])%<span class="number">256</span></span><br><span class="line">flag=<span class="string">&#x27;&#125;&#x27;</span></span><br><span class="line"><span class="keyword">while</span> i&gt;<span class="number">0</span>:</span><br><span class="line">    flag+=(<span class="built_in">chr</span>((a[i-<span class="number">1</span>])^s[t]))</span><br><span class="line">    s[i],s[j]=s[j],s[i]</span><br><span class="line">    j=(j-s[i])%<span class="number">256</span></span><br><span class="line">    i=i-<span class="number">1</span></span><br><span class="line">    t=(s[i]+s[j])%<span class="number">256</span></span><br><span class="line"></span><br><span class="line">flag=flag[::-<span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br><span class="line"></span><br><span class="line"><span class="comment"># flag&#123;einfache_rc4&#125;</span></span><br></pre></td></tr></table></figure><h1 id="LCG"><a href="#LCG" class="headerlink" title="LCG"></a>LCG</h1><blockquote><p><a href="https://www.cnblogs.com/vancasola/p/9942583.html">https://www.cnblogs.com/vancasola/p/9942583.html</a></p><p><a href="https://en.wikipedia.org/wiki/Linear_congruential_generator">https://en.wikipedia.org/wiki/Linear_congruential_generator</a></p><p><a href="https://blog.csdn.net/m0_74345946/article/details/132888135?ops_request_misc=%257B%2522request%255Fid%2522%253A%25221dd70df47b55af8763c80a26c08369d7%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=1dd70df47b55af8763c80a26c08369d7&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-132888135-null-null.142^v101^pc_search_result_base7&amp;utm_term=lcg&amp;spm=1018.2226.3001.4187">LCG入门-CSDN博客</a></p></blockquote><h2 id="加密流程-1"><a href="#加密流程-1" class="headerlink" title="加密流程"></a>加密流程</h2><p>LCG（linear congruential generator）线性同余算法由以下参数组成：</p><div class="table-container"><table><thead><tr><th>参数</th><th>m</th><th>a</th><th>b</th><th>X</th></tr></thead><tbody><tr><td>性质</td><td>模数</td><td>乘数</td><td>加数</td><td>随机数</td></tr><tr><td>作用</td><td>取模</td><td>移位</td><td>偏移</td><td>作为结果</td></tr></tbody></table></div><p>LCG算法是如下的一个递推公式，每下一个随机数是当前随机数向左移动 $ log_2a<br> $ 位，加上一个 b，最后对 m 取余，使随机数限制在 0 ~ m-1 内</p><p>$ X_{n+1}=(aX_{n}+b)\mod m $</p><p>只要我们知道上面的重要参数，要求哪个都很轻松，所以要知道以下公式</p><p><strong>公式1</strong>：反推$ X_n $</p><p>$ X_{n}=(X_{n+1}-b)*a^{-1}\mod m $</p><p><strong>公式2</strong>：求a</p><p>$ a=(X_{i-1}-X_{i-2})^{-1}*(X_{i}-X_{i-1})\mod p $</p><p><strong>公式3</strong>：求b</p><p>$ b=(X_{i+1}-aX_i)\mod m $</p><p><strong>公式4</strong>：求m</p><p>$ t_i=(X_i-X_{i-1})=a(X_{i-1}-X_{i-2})=a*t_{i-1}\mod m $</p><p>$ t_{i+1}t_{i-1}-t_it_i=a^2t_{i-1}-at_{i-1}at_{i-1}=0\mod m $</p><p>上面这个式子就说明了 $ t_{i+1}*t_{i-1}-t_i*t_i $ 是p的倍数，那么我们只要改变i，得到两个值，求一下公因子，就可以求出来m</p><h2 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h2><h3 id="babyLCG"><a href="#babyLCG" class="headerlink" title="babyLCG"></a>babyLCG</h3><p><strong>题目</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag</span><br><span class="line"></span><br><span class="line">m = bytes_to_long(flag)</span><br><span class="line">bit_len = m.bit_length()</span><br><span class="line">a = getPrime(bit_len)</span><br><span class="line">b = getPrime(bit_len)</span><br><span class="line">p = getPrime(bit_len+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">seed = m</span><br><span class="line">result = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    seed = (a*seed+b)%p</span><br><span class="line">    result.append(seed)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">result = [34162247026397342478798569901414759621400, 48622925600981805953284319521855204943516, 873946493924376814098626588792484831751, 55835889122403142019357216062663278735799, 78197983655527534886328482392841803329879, 7826910556079551454813328357787595898220, 48420932174201345880210110234297855524418, 41702494213414751668850237022097487126943, 53964978232593731384060231097661907644428, 41614447441497057710125709202129649216700]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><p><strong>考点</strong>：LCG</p><p>只要知道关于LCG的三个基础公式，这道题就很简单，建议自己推导一遍</p><p>$ seed_i=（a*seed_{i-1}+b）\mod p $</p><p>设$ t_i=(seed_i-seed_{i-1})=a(seed_{i-1}-seed_{i-2})=a*t_{i-1}\mod p $</p><p>$ t_{i+1}*t_{i-1}-t_i*t_i=a^2t_{i-1}-a*t_{i-1}*a*t_{i-1}=0\mod p $</p><p>上面这个式子就说明了 $ t_{i+1}*t_{i-1}-t_i*t_i $ 是p的倍数，那么我们只要改变i，得到两个值，求一下公因子，就可以求出来p，p有了a也很好求</p><p>$ a=(seed_{i-1}-seed_{i-2})^{-1}*t_i\mod p $</p><p>a有了随便套一个式子就可以求b了，这样LCG的三个重要参数就都有了，第一个值逆回去就可以求出明文了</p><p>代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">result = [<span class="number">34162247026397342478798569901414759621400</span>, <span class="number">48622925600981805953284319521855204943516</span>, <span class="number">873946493924376814098626588792484831751</span>, <span class="number">55835889122403142019357216062663278735799</span>, <span class="number">78197983655527534886328482392841803329879</span>, <span class="number">7826910556079551454813328357787595898220</span>, <span class="number">48420932174201345880210110234297855524418</span>, <span class="number">41702494213414751668850237022097487126943</span>, <span class="number">53964978232593731384060231097661907644428</span>, <span class="number">41614447441497057710125709202129649216700</span>]</span><br><span class="line">t1=result[<span class="number">1</span>]-result[<span class="number">0</span>]</span><br><span class="line">t2=result[<span class="number">2</span>]-result[<span class="number">1</span>]</span><br><span class="line">t3=result[<span class="number">3</span>]-result[<span class="number">2</span>]</span><br><span class="line">t4=result[<span class="number">4</span>]-result[<span class="number">3</span>]</span><br><span class="line">t5=result[<span class="number">5</span>]-result[<span class="number">4</span>]</span><br><span class="line">t6=result[<span class="number">6</span>]-result[<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">p = gcd((t6*t4-t5*t5),(t5*t3-t4*t4))</span><br><span class="line"><span class="built_in">print</span>(p)</span><br><span class="line">a=(t3*gmpy2.invert(t2,p))%p</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">b=(result[<span class="number">1</span>]-a*result[<span class="number">0</span>])%p</span><br><span class="line">m = ((result[<span class="number">0</span>]-b)*gmpy2.invert(a,p))%p</span><br><span class="line"><span class="built_in">print</span>(m)</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(m))</span><br><span class="line"></span><br><span class="line"><span class="comment"># flag&#123;gratulieren&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> CTF </tag>
            
            <tag> Crypto </tag>
            
            <tag> 对称密码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>椭圆曲线</title>
      <link href="/2024/11/24/%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF/"/>
      <url>/2024/11/24/%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="椭圆曲线"><a href="#椭圆曲线" class="headerlink" title="椭圆曲线"></a>椭圆曲线</h1><p>下面进行椭圆曲线相关知识的学习（基于crypto hack），中间穿插了一些数论和近世代数的几个知识点。</p><h2 id="一-预备知识"><a href="#一-预备知识" class="headerlink" title="一. 预备知识"></a>一. 预备知识</h2><p>学习的时候碰到了数论和近世代数的几个知识点，因为这两门我都没学完（尤其近世代数，完全没开始看），所有只能求尽量讲清楚吧。</p><h3 id="群"><a href="#群" class="headerlink" title="群"></a>群</h3><p>近世代数是主要研究代数系统（即非空集合）的学科，我们会在这个非空集合上定义满足一定条件的一种或多种二元运算（代数运算）。群是近世代数里面一个重要的概念。下面放一个课本上的定义。</p><p><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/42554774/1731940824047-20ebce66-31a9-433b-8dd2-0b15645a016f.jpeg" alt=""></p><p>简单解释一下就是在一个非空集合里定义一个二元运算，这个运算对于这个集合内的元素都满足</p><p>(1)<strong>结合率</strong>        (2)<strong>单位元</strong>    (3)<strong>逆元</strong></p><p>其实还有一个<strong>封闭性</strong>，就是运算结果还是在这个集合里。</p><p><strong>举一个例子</strong>，对于所有非零有理数（非空集合），和普通乘法（二元运算）构成了一个群，这个群满足结合律（是显然的），有单位元1（任意数与1做这个二元运算都等于它本身，且交换也满足），且对于任意一个a，都有$ \frac{1}{a} $与a做这个二元运算后等于单位元1（交换也满足)</p><h3 id="阿贝尔群（Abel-群）"><a href="#阿贝尔群（Abel-群）" class="headerlink" title="阿贝尔群（Abel 群）"></a>阿贝尔群（Abel 群）</h3><p>阿贝尔群是在群的基础上加上一个条件得到的，即<strong>交换率</strong></p><p>普通的群满足结合率，但是是不一定满足交换率的（目前我举不出具体例子，但是我是联想矩阵运算去理解的，不过可能不准确，感兴趣可以去查一下有没有具体例子）</p><p>所以一旦一个群满足<strong>交换律</strong>，这个群就是<strong>阿贝尔群</strong>，也叫<strong>交换群</strong></p><p>交换群的概念在后面椭圆曲线的运算上会有比较重要的运用。一旦满足结合律和交换律，那么运算时的次序就没那么重要了，这是<strong>基于椭圆曲线的DH密钥交换</strong>的一个重要基础。</p><h3 id="二次剩余"><a href="#二次剩余" class="headerlink" title="二次剩余"></a>二次剩余</h3><blockquote><p><a href="https://oi-wiki.org/math/number-theory/quad-residue/">https://oi-wiki.org/math/number-theory/quad-residue/</a></p></blockquote><p>是数论里面解同余方程那里的一个比较重要的概念，我们有以下定义：</p><p>令整数a，p满足（a，p）= 1，若存在x使得</p><p>$ x^{2} \equiv a\mod p $</p><p>则称a为模p的二次剩余，否则称a为模p的二次非剩余</p><p>这里面还是有挺多概念的东西的，但是上面博客里面讲的十分详细，可以看一看</p><p>所以这里我只强调一个特殊情况下的求解，即$ p \equiv 3\mod 4 $</p><p>满足上面所说情况，且我们知道a是p的二次剩余（怎么验证是不是二次剩余可以看看那个网站里，讲的很详细，数论我没学完，怕讲不清楚），就可以用下图方法来求一个解（可以求出x的值）</p><p><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/42554774/1732103648533-7e560906-4c9c-464a-a188-22d21af569ef.jpeg" alt=""></p><p>我们可以验证一下（自己推了一下，字有点丑，流泪猫猫）</p><p><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/42554774/1732104617404-6926d99e-b246-4eb0-af0d-9ce5036d251e.jpeg" alt=""></p><p>这里因为p+1是4的倍数，指数部分就是整数，所以会很好算。大家也可以试试自己推一下加深理解</p><p>至于其他的情况我还没学完（流泪猫猫头），拜托，数论太难了，但是那个网站里面真的很详细！可以仔细研读</p><h2 id="二-椭圆曲线入门"><a href="#二-椭圆曲线入门" class="headerlink" title="二. 椭圆曲线入门"></a>二. 椭圆曲线入门</h2><blockquote><p><a href="https://www.cnblogs.com/Kalafinaian/p/7392505.html">https://www.cnblogs.com/Kalafinaian/p/7392505.html</a></p></blockquote><p>要研究椭圆曲线就要知道维尔特拉斯方程（Weierstrass），这个方程的形式挺复杂的，感兴趣可以去查一下，然后我们主要运用它的普通形式，即</p><p>$ y^{2} = x^{3} +ax +b $</p><p>大致图像如下</p><p><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/42554774/1732106124295-85739cb9-d47b-46fa-ad13-8b30984d7734.jpeg" alt=""></p><p>像什么曲线每个点是非奇异的（光滑的）这样的性质我就不强调了，这里先知道长什么样就行</p><h3 id="椭圆曲线上的点加法"><a href="#椭圆曲线上的点加法" class="headerlink" title="椭圆曲线上的点加法"></a>椭圆曲线上的点加法</h3><p>我们知道椭圆曲线长什么样子后，就会期望在上面做一些运算，而它确实也提供了点加法运算。其原理是</p><p>假设A=（x1，y1）B=（x2，y2）是曲线上的两个点</p><p>那么P + Q的结果，就是<strong>PQ连线</strong>与椭圆曲线的交点<strong>R</strong>‘关于x轴的<strong>对称点R</strong>，如下图</p><p><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/42554774/1732106828572-99020cec-0105-4fc8-8f25-61689f557c4c.jpeg" alt=""></p><p>倘若是A + A，则我们考虑<strong>A点的切线</strong>，切线与椭圆曲线的交点R’关于x轴的<strong>对称点R</strong>即为结果，如下图</p><p><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/42554774/1732106983277-08aef9d8-3a9a-4f68-85ba-5fca4c0f413f.jpeg" alt=""></p><p>下面是一个具体的计算方法</p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/42554774/1732110476331-aeff5e4d-b778-4574-bc3e-4796656c3024.png" alt=""></p><h3 id="单位元和逆元"><a href="#单位元和逆元" class="headerlink" title="单位元和逆元"></a>单位元和逆元</h3><p>我们知道了椭圆曲线上的点加法运算后，我们会期望它具备群属性，以便于我们研究，这就要找到一个单位元O，使得</p><p>$ P +O=P $</p><p>但我们会发现没有一个点是满足这个条件的，那么我们就规定一个无穷远处的抽象点为单位元O（可以想象一下，一个点和无穷远处点的连线与曲线的交点还是这个点，满足条件）。这个无穷远点可以看成在y轴的正（负）半轴的无穷远处。这就有了单位元了。</p><p>有了单位元后我们来找逆元，即存在-P使得</p><p>$ P +（-P）=O $</p><p>其实回顾一下点加法的定义，我们很容易就能找到逆元就是关于x轴对称的那个点</p><p>例如R=（x3，y3）那么逆元R’=（x3，-y3）</p><p>也可以想象一下，这两个点的连线就是交在无穷远处，满足定义。</p><p>到这里，椭圆曲线上的点加法满足了群的所以性质，所以满足椭圆曲线的所有点加上一个无穷大的虚数点O，就构成了一个群。实际是，这个群也是满足交换率的，而满足交换率的群我们称之为阿贝尔群。</p><p>然后我们真正研究的时候，其实会希望在一个有限域内去研究，特别是素数域，所有我们对方程取模，这样以后，我们研究的就是一些对称的点，而不是连续的线</p><p>取模后逆元那里就有点小区别因为-y = p - y mod p，所以在有限域上的逆元表示成 R’（x，p - y）</p><h3 id="椭圆曲线构建离散对数问题（ECDLP）"><a href="#椭圆曲线构建离散对数问题（ECDLP）" class="headerlink" title="椭圆曲线构建离散对数问题（ECDLP）"></a>椭圆曲线构建离散对数问题（ECDLP）</h3><p>对于一个给定的椭圆曲线E，考虑椭圆曲线上的两个元素P和T，DL问题就是找到整数d，使得</p><p>$ P+P+\dots+P =dP=T $</p><p>很多时候，这个d就是私钥（如在ECC加密体系里）</p><p>（d*P就是椭圆曲线上的标量乘法，不过理解上还是要当成点加法的重复进行）</p><p>很多时候，知道T来求d是十分困难的，相当于一个离散对数问题。这确保了椭圆曲线加密的安全性。</p><h3 id="基于椭圆曲线的DH密钥交换"><a href="#基于椭圆曲线的DH密钥交换" class="headerlink" title="基于椭圆曲线的DH密钥交换"></a>基于椭圆曲线的DH密钥交换</h3><p>知道了椭圆曲线，我们要用来做一些和密码有关的事情</p><p>于是Alice和Bob协商做下面这些事</p><p><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/42554774/1732114355132-c04e044e-3946-4877-8a2a-275ef34626ed.jpeg" alt=""></p><p>两个人并用分别用自己随机生成的整数a和b与P（公开）做标量乘法得到A（公开）和B（公开），并把得到的值分别传给对方。</p><p>Alice得到B并用自己一开始的那个随机数a与B做标量乘法，得到T，Bob同理。两人把得到的T作为共享密钥。</p><p>对于Alice：T = a <em> （b </em> P）</p><p>对于Bob：  T =  b <em>（a </em> P）</p><p>因为椭圆曲线是一个阿贝尔群，所以运算次序对结果不影响，所以两个人得到的T相同，这确保了交换的可行性</p><p>这个过程里面，外人只可能得到P、A和B（这三个是公开的），但是仅仅通过这三个是算不出a和b的（即算不出T），这确保了这个交换过程的安全性。</p><p>这样Alice和Bob就可以用这个联合密钥去加密一些东西</p><p>之后Alice和Bob进行了思考，他们认为，既然椭圆曲线方程已知，那干嘛还要传递y呀？（欸！我有一个好主意）于是他们觉得只传递x就可以了，以实现高效传递</p><p>事实上只传递x也确实是可行的，我们考虑把已知的x值代入曲线方程就可以得到    y<sup>2</sup> = k mod p    的形式</p><p>其中k是带入x后的算出值，这就是一个二次剩余问题（数论的知识点），这样就是一个比较简单解决的问题（课本上这么说的，虽然在我看来还是很难），很容易就可以求出y。</p><p>但这里会有一个小问题，那就是如果数对（x，y）满足上面那个式子，那么显然的（x，p - y）也是满足的，所以实际生活中，我们在传递x坐标时，会附带传递一个指定y的奇偶性的标志位，以此来达到区分到底是哪个点（感兴趣可以查一下，挺复杂的，没看懂）</p><h2 id="三-题目"><a href="#三-题目" class="headerlink" title="三. 题目"></a>三. 题目</h2><h3 id="Efficient-Exchange"><a href="#Efficient-Exchange" class="headerlink" title="Efficient Exchange"></a>Efficient Exchange</h3><p><strong>题目</strong>：</p><p><code>E: Y2=X3 +497X+1768 mod 9739</code></p><p><code>Calculate the shared secret after Alice sends you x(QA)=4726, with your secret integer nB=6534.</code></p><p><code>Use the file to decode the flag decrypt.py</code></p><p><code>&#123;&#39;iv&#39;: &#39;cd9da9f1c60925922377ea952afc212c&#39;, &#39;encrypted_flag&#39;: &#39;febcbe3a3414a730b125931dccf912d2239f3e969c4334d95ed0ec86f6449ad8&#39;&#125;</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.Padding <span class="keyword">import</span> pad, unpad</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">is_pkcs7_padded</span>(<span class="params">message</span>):</span><br><span class="line">    padding = message[-message[-<span class="number">1</span>]:]</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">all</span>(padding[i] == <span class="built_in">len</span>(padding) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(padding)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decrypt_flag</span>(<span class="params">shared_secret: <span class="built_in">int</span>, iv: <span class="built_in">str</span>, ciphertext: <span class="built_in">str</span></span>):</span><br><span class="line">    <span class="comment"># Derive AES key from shared secret</span></span><br><span class="line">    sha1 = hashlib.sha1()</span><br><span class="line">    sha1.update(<span class="built_in">str</span>(shared_secret).encode(<span class="string">&#x27;ascii&#x27;</span>))</span><br><span class="line">    key = sha1.digest()[:<span class="number">16</span>]</span><br><span class="line">    <span class="comment"># Decrypt flag</span></span><br><span class="line">    ciphertext = <span class="built_in">bytes</span>.fromhex(ciphertext)</span><br><span class="line">    iv = <span class="built_in">bytes</span>.fromhex(iv)</span><br><span class="line">    cipher = AES.new(key, AES.MODE_CBC, iv)</span><br><span class="line">    plaintext = cipher.decrypt(ciphertext)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> is_pkcs7_padded(plaintext):</span><br><span class="line">        <span class="keyword">return</span> unpad(plaintext, <span class="number">16</span>).decode(<span class="string">&#x27;ascii&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> plaintext.decode(<span class="string">&#x27;ascii&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">shared_secret = ?</span><br><span class="line">iv = ?</span><br><span class="line">ciphertext = ?</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(decrypt_flag(shared_secret, iv, ciphertext))</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>考点</strong>：二次剩余，AES解密，ECDH的高效传递</p><p>这里主要考察对ECDH的高效传递的理解，Alice和Bob认为，椭圆曲线方程已知，那干嘛还要传递y呀？（欸！我有一个好主意）于是他们觉得只传递x就可以了。于是Alice给我发了一个x值，希望我能够以此知道共享密钥。并且Alice用共享密钥通过AES加密了flag</p><p>事实上只传递x也确实是可行的，我们考虑把已知的x值代入曲线方程就可以得到    y2 = k mod p    的形式</p><p>其中k是带入x后的算出值，这就是一个二次剩余问题（数论的知识点），这样就是一个比较简单解决的问题（课本上这么说的，虽然在我看来还是很难），很容易就可以求出y</p><p>但这里会有一个小问题，那就是如果数对（x，y）满足上面那个式子，那么显然的（x，p - y）也是满足的，所以实际生活中，我们在传递x坐标时，会附带传递一个指定y的奇偶性的标志位，以此来达到区分到底是哪个点（感兴趣可以查一下，挺复杂的，没看懂）</p><p>不过这道题会相对简单，因为我们最后只用x来做文章，所以y的值我们不关心，那么对于同一个x，即使两个人最后算出来的y不一样（一个是y，一个是p-y），经过运算后也不会影响x的值（可能画个图会好理解一点，两个对称的点，画斜率，与曲线的交点的x还是一样的），所以我们任意求出一个y来进行计算就行</p><p>现在来进行y的计算，题目给了提示p = 3 mod 4，这就可以运用二次剩余的知识点来解决，下面是原理图</p><p><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/42554774/1732085889491-3c78c1ef-668a-4c38-af7c-ba3b30ef22a4.jpeg" alt=""></p><p>这里直接用</p><p>$ y = a^\frac{p+1}{4}\mod p $</p><p>当然你也可以直接遍历p（遍历完总能找到一个解），因为这题p确实不大，两个办法都行，都可以求p（我一开始用的第二个，觉得不是预期解法才去查的第一个），求出y了就没什么难度了，套那个解密文件就行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sage</span></span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.Padding <span class="keyword">import</span> pad, unpad</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">is_pkcs7_padded</span>(<span class="params">message</span>):</span><br><span class="line">    padding = message[-message[-<span class="number">1</span>]:]</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">all</span>(padding[i] == <span class="built_in">len</span>(padding) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(padding)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decrypt_flag</span>(<span class="params">shared_secret: <span class="built_in">int</span>, iv: <span class="built_in">str</span>, ciphertext: <span class="built_in">str</span></span>):</span><br><span class="line">    <span class="comment"># Derive AES key from shared secret</span></span><br><span class="line">    sha1 = hashlib.sha1()</span><br><span class="line">    sha1.update(<span class="built_in">str</span>(shared_secret).encode(<span class="string">&#x27;ascii&#x27;</span>))</span><br><span class="line">    key = sha1.digest()[:<span class="number">16</span>]</span><br><span class="line">    <span class="comment"># Decrypt flag</span></span><br><span class="line">    ciphertext = <span class="built_in">bytes</span>.fromhex(ciphertext)</span><br><span class="line">    iv = <span class="built_in">bytes</span>.fromhex(iv)</span><br><span class="line">    cipher = AES.new(key, AES.MODE_CBC, iv)</span><br><span class="line">    plaintext = cipher.decrypt(ciphertext)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> is_pkcs7_padded(plaintext):</span><br><span class="line">        <span class="keyword">return</span> unpad(plaintext, <span class="number">16</span>).decode(<span class="string">&#x27;ascii&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> plaintext.decode(<span class="string">&#x27;ascii&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p = <span class="number">9739</span></span><br><span class="line">y = <span class="built_in">int</span>(((<span class="number">4726</span>**<span class="number">3</span>+<span class="number">497</span>*<span class="number">4726</span>+<span class="number">1768</span>)**((p+<span class="number">1</span>)//<span class="number">4</span>))%p)</span><br><span class="line"><span class="built_in">print</span>(y)</span><br><span class="line">E = EllipticCurve(GF(<span class="number">9739</span>),[<span class="number">497</span>,<span class="number">1768</span>])</span><br><span class="line">P = E([<span class="number">4726</span>,<span class="number">6287</span>])</span><br><span class="line">shared_secret = (<span class="number">6534</span>*P)[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(shared_secret)</span><br><span class="line"></span><br><span class="line">iv = <span class="string">&#x27;cd9da9f1c60925922377ea952afc212c&#x27;</span></span><br><span class="line">ciphertext = <span class="string">&#x27;febcbe3a3414a730b125931dccf912d2239f3e969c4334d95ed0ec86f6449ad8&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(decrypt_flag(shared_secret, iv, ciphertext))</span><br><span class="line"> </span><br><span class="line"><span class="comment"># crypto&#123;3ff1c1ent_k3y_3xch4ng3&#125;</span></span><br></pre></td></tr></table></figure><p><strong>flag</strong>：crypto{3ff1c1ent_k3y_3xch4ng3}</p><h2 id="四-总结"><a href="#四-总结" class="headerlink" title="四. 总结"></a>四. 总结</h2><p>到这里，我们对椭圆曲线就有了简单认识，但其实还并没有接触到真正的一些加密算法，比如说ECC（但是原理懂了这个也就很好理解了，所以问题不大）。而且椭圆曲线加密也不是绝对安全的，后面还要学习各种攻击方式（像之前我瞥到的光滑数攻击），总的来说，道阻且长。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> CTF </tag>
            
            <tag> Crypto </tag>
            
            <tag> 椭圆曲线 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>格入门</title>
      <link href="/2024/11/15/%E6%A0%BC%E5%85%A5%E9%97%A8/"/>
      <url>/2024/11/15/%E6%A0%BC%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="格入门"><a href="#格入门" class="headerlink" title="格入门"></a>格入门</h1><p>这两周就是学习了一些格的基本知识，因为临近期中考，学的有点仓促，但总算是了解了一点，我把学到知识点也写了写，作业的解题思路会放在后面题目运用那里，可以跳转去看</p><h2 id="一-预备知识"><a href="#一-预备知识" class="headerlink" title="一. 预备知识"></a>一. 预备知识</h2><p>要学习格，是得有线性代数的知识才行的。（反正我看到那些矩阵向量什么的就回忆起上学期被线代支配的恐惧）因为我上学期线代学的也不好，忘的也差不多了，加上这里篇幅也有限，我也只能点一下cryptohack上面提到的一些线代知识，目前来看够用，不过强烈建议系统的学习一下线代。</p><h3 id="向量和向量空间"><a href="#向量和向量空间" class="headerlink" title="向量和向量空间"></a>向量和向量空间</h3><p>以二维向量空间举例，我们可以任意取一个点A，连接原点O和A点，这就构成成了一个向量。我们也可以用A点的坐标来表示这个向量,就像这样<strong>v=</strong>(x,y)</p><p>向量满足加减、数乘和点积运算，下面举例说明（加粗表示向量）</p><p><strong>v</strong>=(a , b)，<strong>w</strong>=(c , d)</p><p><strong>v</strong> + <strong>w</strong> = （a + c，b + d） （减法同理）</p><p>c * <strong>w </strong>= （c * a， c * b ）      （数乘）</p><p><strong>v</strong> * <strong>w</strong> = a * c + b * d        （点积）</p><p>多维是同理的</p><p>然后向量还分行向量和列向量，可以简单理解为行向量就是在纸上横着写的向量（确信），列向量就是在纸上竖着写的向量（确信）</p><h3 id="向量大小和基"><a href="#向量大小和基" class="headerlink" title="向量大小和基"></a>向量大小和基</h3><p>$ \begin{Vmatrix}v\ \end{Vmatrix} $用来表示向量的长度，其大小是$ \begin{align}<br>\sqrt{v*v}<br>\end{align} $(高中应该就有这个知识点的)</p><p>这里还有一些关于线性独立的知识点，比如向量空间里有一组向量$ v_i $</p><p>满足方程$ \begin{align} a_1⋅v_1+a_2⋅v_2+…+a_k⋅v_k=0 \end{align} $</p><p>当$ a_i<br> $全为零时等式才成立，那么这k个向量就是线性无关的，反之线性相关</p><p>而向量空间的基底会要求是一组线性无关的向量，当我们有了这一组向量基，我们就可以用这个基底来表示这个向量空间中的任意向量</p><p>拿二维空间举例</p><p>$ \begin{align} i=(0,1)\end{align} $ $ \begin{align} j = (1,0)\end{align} $就是一组线性无关的基底，这两个向量就可以表示整个二维平面</p><p>其实了解一下矩阵会更有帮助，但是我就不介绍了（有试着想写一下，但是发现讲不清楚，还是留给大家的线代老师吧）</p><p><a href="https://www.bilibili.com/video/BV1aW411Q7x1/?spm_id_from=333.1007.top_right_bar_window_custom_collection.content.click&amp;vd_source=a01a62f772bf2e577e11004dfef0bde1">线代课程</a>（放一个宋浩老师线代课的链接吧）</p><h3 id="施密特正交化"><a href="#施密特正交化" class="headerlink" title="施密特正交化"></a>施密特正交化</h3><p>这个东西感觉只可意会不可言传了，我就放个图，<del>大家自己悟吧</del>（主要我也不知道为什么，只会套公式）</p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/42554774/1730734509235-c52c5bf3-4af8-4401-9542-e0c44579ad40.png" alt=""></p><p>这个正交化就是可以构造一个正交基，正交的概念就是向量相互垂直，上面我举的二维空间的基底就是一组正交基，因为点乘为零（两个向量垂直，点乘为零）</p><p>正交化会有挺多好处的（应该，反正没学懂，就会套公式）</p><p>这个就是解决一下crypto hack上的一道题，其他地方好像和那个高斯晶格规约有点像，但那里我们会四舍五入，所以还是有点区别的</p><p>下面放一个求解代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sage</span></span><br><span class="line"><span class="keyword">from</span> sympy.matrices <span class="keyword">import</span> Matrix, GramSchmidt</span><br><span class="line">l = [Matrix([<span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>, -<span class="number">1</span>]), Matrix([<span class="number">2</span>, <span class="number">1</span>, -<span class="number">3</span>, <span class="number">4</span>]), Matrix([<span class="number">1</span>, <span class="number">0</span>, -<span class="number">2</span>, <span class="number">7</span>]), Matrix([<span class="number">6</span>, <span class="number">2</span>, <span class="number">9</span>, -<span class="number">5</span>])]</span><br><span class="line"><span class="comment"># 注意：将数据转为Matrix格式，否则调用GramSchmidt函数会报错！</span></span><br><span class="line"><span class="comment"># 返回未单位化结果</span></span><br><span class="line">o1 = GramSchmidt(l) <span class="comment"># 注意：orthonormal默认为False，不执行单位化操作</span></span><br><span class="line"><span class="built_in">print</span>(o1)</span><br><span class="line"><span class="comment"># 返回单位化结果</span></span><br><span class="line">o2 = GramSchmidt(l,orthonormal=<span class="literal">True</span>) <span class="comment"># 注意：orthonormal设为True，执行单位化操作</span></span><br><span class="line"><span class="built_in">print</span>(o2)</span><br></pre></td></tr></table></figure><h2 id="二-格的初步认识"><a href="#二-格的初步认识" class="headerlink" title="二. 格的初步认识"></a>二. 格的初步认识</h2><blockquote><p>参考文档</p><p><a href="https://tover.xyz/p/LLL-attack-equation/">格攻击之小未知数方程求解入门——原理与例子 | Tover’s Blog</a></p><p>这个博客里讲的真的很好！</p></blockquote><h3 id="格定义"><a href="#格定义" class="headerlink" title="格定义"></a>格定义</h3><p>这里先放一个课本上的定义</p><p><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/42554774/1731031878819-11983b36-e144-4468-acf9-e5961f9a255a.jpeg" alt=""></p><p>可能看起来比较难懂，但是我们还是从上面那个二维平面出发，我们已经知道了我们可以用一组基底来表示整个二维平面（基底不唯一），我们是通过把这两个向量乘以不同的系数后相加得到的，那么想象一下，我们如果令系数只为整数会怎么样呢？</p><p>这个时候，我们通过这个基底，就只能得到空间里的一些点，那么这个就是一个整数格</p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/42554774/1731033008919-7ec8338d-05df-4c71-8650-b0c08eb23041.png" alt=""></p><p>我们把基底写成一个矩阵，那么就可以得到上面定义里的写法，同时这个矩阵的<strong>行列式</strong>的值，叫做这个<strong>基本域的容积</strong></p><p>同时如果我们扩展到n维向量空间，就是定义里的表示</p><h3 id="格常见问题"><a href="#格常见问题" class="headerlink" title="格常见问题"></a>格常见问题</h3><p>通过上面我们简单了解了一下格是什么，长什么样，那么就要考虑能拿它干什么</p><p>这就得提一下格上的两个常见问题，一个是最短向量问题（SVP），另一个是最近向量问题（CVP）</p><p>SVP是指我们要在格L上找到一个最短的非零向量$ v $，使得$ \begin{Vmatrix}v\ \end{Vmatrix} $最小</p><p>可能在二维空间里你一下就可以看出来哪个是最短的向量，但是一旦扩展到多维时，这就是一个困难的问题了。这里补一个课本上看到的存在性定理，感兴趣可以看一下</p><p><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/42554774/1731034540889-80fdac9a-282b-49e1-b5ab-8cbfa0c984fe.jpeg" alt=""></p><p>那么为了找到这个最短向量，我们有以下规约</p><h4 id="高斯格基规约"><a href="#高斯格基规约" class="headerlink" title="高斯格基规约"></a>高斯格基规约</h4><p>这个是适用于二维平面，通过算法可以找到二维平面里的最短向量，感觉是LLL的特殊情况（因为好像sage上用LLL的算法也可以解这个），下面放个算法图</p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/42554774/1731034151787-c932dad2-cf3a-40a6-bd0a-392a94db460c.png" alt=""></p><p>如果你仔细看一下的话就会发现这个算法和那个施密特正交化是有一点像的，但是我们知道在施密特正交化里，m不一定是整数，这就会导致得到的向量不在格里，所以我们对m四舍五入取整，这样来得到</p><h4 id="LLL格基规约"><a href="#LLL格基规约" class="headerlink" title="LLL格基规约"></a>LLL格基规约</h4><p>原理其实感觉差不了太多，就是去找最短向量</p><p>这里的运用就是根据关系找到一个基底的矩阵，矩阵中所有数是已知的，然后我们要求解的向量（要求解的未知数构成的向量）是一些数作用在这个矩阵后得到，这个向量就在格上，然后我们期望这个向量是最短向量，以此来求解未知数，下面放一个newstar时候用过的代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># sage</span><br><span class="line">from gmpy2 import *</span><br><span class="line">from Crypto.Util.number import *</span><br><span class="line">#from tqdm import *</span><br><span class="line"> </span><br><span class="line">a = 134812492661960841508904741709490501744478747431860442812349873283670029478557996515894514952323891966807395438595833662645026902457124893765483848187664404810892289353889878515048084718565523356944401254704006179297186883488636493997227870769852726117603572452948662628907410024781493099700499334357552050587</span><br><span class="line">b = 1522865915656883867403482317171460381324798227298365523650851184567802496240011768078593938858595296724393891397782658816647243489780661999411811900439319821784266117539188498407648397194849631941074737391852399318951669593881907935220986282638388656503090963153968254244131928887025800088609341714974103921219202972691321661198135553928411002184780139571149772037283749086504201758438589417378336940732926352806256093865255824803202598635567105242590697162972609</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">mat = [[b,0],[a,1]]</span><br><span class="line">M = Matrix(ZZ,mat)</span><br><span class="line">qq,pp= M.LLL()[0]   # 最短向量</span><br><span class="line"> </span><br><span class="line">print(pp)</span><br><span class="line">print(qq)</span><br></pre></td></tr></table></figure><p>然而要运用LLL算法是有条件的，就是我们要通过这个算法来求最短向量，那么我们要求的向量起码得是最短向量，这就得看一下上面的最短向量存在定理，我们要求解的向量长度满足条件后才是最短向量，才可以用LLL算法，然后格的维数也不能太高，不然准确度不高，耗时也会长。</p><p>具体解一下题应该就能理解，可以往后看</p><h2 id="三-题目及运用"><a href="#三-题目及运用" class="headerlink" title="三. 题目及运用"></a>三. 题目及运用</h2><p>我们来具体分析一下下面这一题</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> getPrime, inverse, bytes_to_long, long_to_bytes</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> Tools.scripts.var_access_benchmark <span class="keyword">import</span> make_nonlocal_writer</span><br><span class="line"></span><br><span class="line">FLAG = <span class="string">b&#x27;crypto&#123;?????????????????????&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gen_key</span>():</span><br><span class="line">    q = getPrime(<span class="number">512</span>)</span><br><span class="line">    upper_bound = <span class="built_in">int</span>(math.sqrt(q // <span class="number">2</span>))</span><br><span class="line">    lower_bound = <span class="built_in">int</span>(math.sqrt(q // <span class="number">4</span>))</span><br><span class="line">    f = random.randint(<span class="number">2</span>, upper_bound)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        g = random.randint(lower_bound, upper_bound)</span><br><span class="line">        <span class="keyword">if</span> math.gcd(f, g) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    h = (inverse(f, q)*g) % q</span><br><span class="line">    <span class="keyword">return</span> (q, h), (f, g)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encrypt</span>(<span class="params">q, h, m</span>):</span><br><span class="line">    <span class="keyword">assert</span> m &lt; <span class="built_in">int</span>(math.sqrt(q // <span class="number">2</span>))</span><br><span class="line">    r = random.randint(<span class="number">2</span>, <span class="built_in">int</span>(math.sqrt(q // <span class="number">2</span>)))</span><br><span class="line">    e = (r*h + m) % q</span><br><span class="line">    <span class="keyword">return</span> e</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decrypt</span>(<span class="params">q, h, f, g, e</span>):</span><br><span class="line">    a = (f*e) % q</span><br><span class="line">    m = (a*inverse(f, g)) % g</span><br><span class="line">    <span class="keyword">return</span> m</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public, private = gen_key()</span><br><span class="line">q, h = public</span><br><span class="line">f, g = private</span><br><span class="line"></span><br><span class="line">m = bytes_to_long(FLAG)</span><br><span class="line">e = encrypt(q, h, m)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;Public key: <span class="subst">&#123;(q,h)&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;Encrypted Flag: <span class="subst">&#123;e&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure><p>因为我在newstar的时候有简单看看格，那个时候认识不够全面，以为只要构造出一个矩阵就行，所有下面分享一个错误思路</p><p>就是我一看到就定睛在e = (r*h + m) % q这个式子上</p><p>然后e - m = q*k + r*h</p><p>所以$ \begin{align}(k,r)\begin{pmatrix}q&amp;0 \\ h&amp;1 \end{pmatrix} =(e-m,r)\end{align} $</p><p>我们写成  v*B = w</p><p><del>想着这个式子构造出格，直接求明文，简单简单</del></p><p>但是这个思路是错误的，因为没有考虑我们通过（k，r）作用到矩阵后得到的这个向量到底是不是最短向量</p><p>我们可以算一下$ \begin{Vmatrix}w\ \end{Vmatrix} $和$ \sqrt2{det(B)}^\frac{1}{2} $（根据上面最短向量存在定理比较一下，就可以判断w是不是最短向量），其实这里没有明显的算出值（因为我们不知道m，但大概率这个w的长度是大的）所以大小都不知道，我们根本无法判断w是不是最短向量，所有LLL规约求出来的不是w。这里根本还是因为我违背这种题目的初衷，就是本来是用格攻击求小未知数，但是我求的不是小未知数</p><p><strong>上面错误思路告诉我们，不是所有的式子都可以通过构造格来求解，只有当我们要求解的未知数所构成的向量恰好在格上，且这个向量恰好是最短向量时（小未知数），才可以求解</strong></p><p>那么下面来看正确做法</p><p>既然上面那个式子构造出来的格不对，那么我们转战另一个式子</p><p>h = (inverse(f, q)*g) % q</p><p>即 h = k * q + f<sup> -1</sup> * g mod（q）</p><p>这么看有个f关于q的逆元，那么两边乘个f，得到</p><p>h * f = k * q * f + g  </p><p>我们试着移项得到 g = h*f + k<sub>1</sub> *q*f   （为什么要移项？因为我们要把已知的两个数h和q放在一边，来构造矩阵）</p><p>这个时候就很清晰了，加上  kf * 0 + f = f （感觉是一类比较固定的式子，一个恒等式，方便构造矩阵）这个式子就可以得到</p><p>$ \begin{align}(k_1f,f) \begin{pmatrix} q&amp;0 \\ h&amp;1 \end{pmatrix} =(g,f)\end{align} $</p><p>我们写成  v*B = w</p><p>这个时候我们再验证一下$ \left \| w \right \| = \sqrt{f^{2} * g^{2}} ＜\sqrt{(\frac{q}{2})^{2} *(\frac{q}{2})^{2}  } ＜\sqrt{2}\sqrt{q}＜\sqrt{2} det(B)^{\frac{1}{2} } $</p><p>f和g小于q的一半应该是显然的，因为题目定义的时候就是小于的，不理解可以返回去再看一下题目定义f和g那里</p><p>这个时候w大概率就是最小向量，这个时候，我们运用LLL格级规约就可以求出w，即密钥，然后通过解密代码（题目已给）就可以求出明文</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sage</span></span><br><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#from tqdm import *</span></span><br><span class="line"></span><br><span class="line">a = <span class="number">2163268902194560093843693572170199707501787797497998463462129592239973581462651622978282637513865274199374452805292639586264791317439029535926401109074800</span></span><br><span class="line"></span><br><span class="line">b = <span class="number">7638232120454925879231554234011842347641017888219021175304217358715878636183252433454896490677496516149889316745664606749499241420160898019203925115292257</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mat = [[b,<span class="number">0</span>],[a,<span class="number">1</span>]]</span><br><span class="line">M = Matrix(ZZ,mat)</span><br><span class="line">g,f= M.LLL()[<span class="number">0</span>] </span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(f)</span><br><span class="line"><span class="built_in">print</span>(g)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decrypt</span>(<span class="params">q, h, f, g, e</span>):</span><br><span class="line">    a = (f*e) % q</span><br><span class="line">    m = (a*inverse(f, g)) % g</span><br><span class="line">    <span class="keyword">return</span> m</span><br><span class="line">    </span><br><span class="line">Publickey=(<span class="number">7638232120454925879231554234011842347641017888219021175304217358715878636183252433454896490677496516149889316745664606749499241420160898019203925115292257</span>, <span class="number">2163268902194560093843693572170199707501787797497998463462129592239973581462651622978282637513865274199374452805292639586264791317439029535926401109074800</span>)</span><br><span class="line">q = Publickey[<span class="number">0</span>]</span><br><span class="line">h = Publickey[<span class="number">1</span>]</span><br><span class="line">e = <span class="number">5605696495253720664142881956908624307570671858477482119657436163663663844731169035682344974286379049123733356009125671924280312532755241162267269123486523</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">g = <span class="number">43997957885147078115851147456370880089696256470389782348293341937915504254589</span></span><br><span class="line"></span><br><span class="line">f = <span class="number">47251817614431369468151088301948722761694622606220578981561236563325808178756</span></span><br><span class="line"></span><br><span class="line">m =decrypt(q, h, f, g, e)</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(m))</span><br></pre></td></tr></table></figure><p>就可以解出明文了</p><h2 id="四-总结"><a href="#四-总结" class="headerlink" title="四. 总结"></a>四. 总结</h2><p>最后简单总结一下用格解小未知数方程的过程</p><p>首先找到一个式子，转化成一个向量（感觉可以叫系数向量，因为就是这个向量作用于矩阵，以此来得到一个在格上的向量）乘以一个矩阵（基底），得到另一个向量（我们要求解的小未知数所构成的向量）的形式</p><p>然后可以简单判断一下是不是最短向量（根据最短向量存在定理）</p><p>之后就可以用LLL规约解出最短向量，这个向量里的就是我们要求的小未知数了。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> CTF </tag>
            
            <tag> Crypto </tag>
            
            <tag> 格 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>个人博客搭建</title>
      <link href="/2024/11/02/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
      <url>/2024/11/02/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="个人博客搭建"><a href="#个人博客搭建" class="headerlink" title="个人博客搭建"></a>个人博客搭建</h1><blockquote><p>参考文章</p><p><a href="https://blog.fiveth.cc/p/bb32/">https://blog.fiveth.cc/p/bb32/</a></p><p><a href="https://www.bilibili.com/video/BV1Ju4m1c7WR/?spm_id_from=333.1007.top_right_bar_window_default_collection.content.click&amp;vd_source=a01a62f772bf2e577e11004dfef0bde1">【零成本】Hexo个人博客搭建教程 | 无需服务器_哔哩哔哩_bilibili</a></p></blockquote><p>记录一下个人博客的搭建过程，我的是Hexo框架，参考的就是上面的视频和博客，中间有一点问题，然后我看了另外一位大佬的博客解决的，等到具体步骤具体说，然后我搭好的结果就是<a href="https://mondaying.cn">mondaying.cn</a>（就是简单搞出来，主题什么的还是没搞懂），下面就简单讲一下过程。</p><h2 id="一-准备工作"><a href="#一-准备工作" class="headerlink" title="一. 准备工作"></a>一. 准备工作</h2><blockquote><p>参考文章</p><p><a href="https://www.cnblogs.com/liuqiyun/p/8133904.html">https://www.cnblogs.com/liuqiyun/p/8133904.html</a></p><p><a href="https://www.cnblogs.com/xueweisuoyong/p/11914045.html">https://www.cnblogs.com/xueweisuoyong/p/11914045.html</a></p></blockquote><ol><li>首先就是要下载node.js<br> <a href="https://nodejs.org/en">node链接</a><br> 就到官网下载就行，我是下载的挺顺的，没什么差池，第一篇文章讲的挺详细的，照着做就行</li></ol><ol><li>然后下载git<br> <a href="https://git-scm.com/downloads">git链接</a><br> 也是官网下载，我遇到的问题就是下载很慢，得有快半个小时多才下载好，其他没什么问题，可以参考上面放的第二篇文章</li></ol><p>下载完上面两个后可以打开cmd检查一下是不是安装成功（输入下图三行代码），成功的话就是下面这个界面</p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/42554774/1730260613488-26cebe87-d4f0-4a1c-9cd4-8e1a9cb4bd68.png" alt=""></p><ol><li>然后就是下载hexo<br> 得用管理员身份打开cmd<br> <img src="https://cdn.nlark.com/yuque/0/2024/png/42554774/1730260734784-72d18db3-7c13-46d9-8a47-1cf5cfb9a0c2.png" alt=""><br> 然后输入下面这串代码下载hexo，这里我做完忘记截屏了，不过没报错应该就是成功了（确信)</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure><ol><li>接着就是注册一个GitHub账号，这个我上个假期搞的，也就没截屏了，好像也挺顺的，就是取名字那里花了挺久（为什么想取的名字全被注册啊，恼）  </li></ol><h2 id="二-搭建仓库"><a href="#二-搭建仓库" class="headerlink" title="二. 搭建仓库"></a>二. 搭建仓库</h2><p>这里就要用到我们之前注册的GitHub账号。主页的左边就有Create repository，点后就是下图<br><img src="https://cdn.nlark.com/yuque/0/2024/png/42554774/1730262710074-a072ec7b-ab05-4936-bb98-6b3cbe57b849.png" alt=""></p><p>这里就得注意了，仓库名必须按照格式填写，即：<strong>用户名.github.io</strong>，比如我的用户名是Mondaying（这里的name和user name好像是有区别的，得用user name），那么仓库名必须填Mondaying.github.io</p><p>仓库也必须是public的，然后那个Add a README file也点上（这个我也不知道为什么，反正跟着点就对了）</p><p>然后就创建好了，放着备用</p><h2 id="三-配置ssh-key"><a href="#三-配置ssh-key" class="headerlink" title="三. 配置ssh key"></a>三. 配置ssh key</h2><ol><li>在桌面空白处右键，点显示更多选项，打开git bash，粘贴下面这串代码，记得把邮箱改成自己的，然后敲四下键盘</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;邮件地址&quot;</span><br></pre></td></tr></table></figure><ol><li>之后就去C盘用户文件夹里的某个文件夹里（因为好像每个人的都不一样，反正我和那个up主的就不一样，得找一下）去找下面这个文件夹<br> <img src="https://cdn.nlark.com/yuque/0/2024/png/42554774/1730263737700-ac2180c4-8bd6-41f6-bc1d-99cb4e1f62ee.png" alt=""><br> 点开里面找到id_rsa.pub打开，全选复制</li></ol><ol><li>然后我们打开GitHub，打开Settings</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2024/png/42554774/1730264452254-9a4f4209-202a-4001-a148-02e26c07dffd.png" alt=""></p><p>点进去后在左边找到SSH and GPG keys，然后点击new ssh key，title那里随便取名，key那里粘贴刚刚复制的东西，创建就可以了<br><img src="https://cdn.nlark.com/yuque/0/2024/png/42554774/1730264596585-f4a79952-4151-4467-9825-9ba0870d06bd.png" alt=""></p><ol><li>回到桌面，打开git bash，输入下面这串代码，验证一下有没有添加成功</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><p>回车后记得输入yes，这里也忘记结果截屏了，还是没报错就成功（确信）</p><h2 id="四-本地部署"><a href="#四-本地部署" class="headerlink" title="四. 本地部署"></a>四. 本地部署</h2><ol><li><p>首先选择一个合适的位置创建一个文件夹，用来放置博客文件<br> <img src="https://cdn.nlark.com/yuque/0/2024/png/42554774/1730265201600-39609800-8918-4b0f-9836-193245214bd8.png" alt=""><br> 打开文件夹，在文件夹里右键打开git bash，输入hexo init进行初始化（如果不行就输入npx hexo init）注意，输入这行代码后文件夹里应该得冒出来东西才对，就是得有一些文件的，但是像我就是输入后文件夹里没有东西，虽然没报错（我记得当时是没报错)，但是是有问题的，我的解决方法也挺简单的，就是退出去，删除文件夹，然后重新弄，如果显示文件夹被占用无法删除那就重启电脑。<br> 反正后面几步也一样，一旦有问题就删除文件夹重新来，多来几次就可以了  </p></li><li><p>输入npx hexo install安装  </p></li><li><p>输入npx hexo g生成<br> 我记得这里我卡了挺久，就是输入后它就是没反应，但是多等一会就有了，如果过了很久都不行就按上面方法，删除文档重新来  </p></li><li><p>输入npx hexo s本地部署<br> 这之后我们就会得到一个链接，打开就可以看到我们的博客在本地部署啦，这就是我们的博客了，这里记得回到命令行点ctrl+c停止本地服务器，然后再关闭窗口，否则你就得又重启你的电脑了（恼）因为不这样后面再打开就会显示被占用</p></li></ol><h2 id="五-上线博客"><a href="#五-上线博客" class="headerlink" title="五. 上线博客"></a>五. 上线博客</h2><ol><li><p>首先用记事本打开博客文件夹里的下面这个文件<br> <img src="https://cdn.nlark.com/yuque/0/2024/png/42554774/1730267044848-ab487849-6676-4475-beef-3aa05005dcb9.png" alt=""><br> 当然用vscode打开整个文件夹再进行操作最好，我这里图个方便.  </p></li><li><p>打开之后拖到最底下，把deploy以及后面的全删掉，复制粘贴下面这段</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: git@github.com:user name/user name.github.io.git</span><br><span class="line">  branch: main</span><br></pre></td></tr></table></figure><p>记得把user name换成我们的名字</p><ol><li>然后桌面打开git bash，输入npx hexo g生成<br> 这里我弹了一个报错，显示没找到git，但是视频里也没讲为什么<br> <img src="https://cdn.nlark.com/yuque/0/2024/png/42554774/1730127721025-d9a4a9da-26b8-45fa-a33a-2532af77ec07.png" alt=""><br> 然后我又找到了一位大佬的博客<a href="https://www.fomal.cc/posts/e593433d.html">https://www.fomal.cc/posts/e593433d.html</a>就是这篇，然后输入下面这串代码就好了</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><ol><li><p>然后输入npx hexo d上传<br> 然后这里因为是第一次使用，所以要填一下配置，按照下图输入两个代码就行，记得把邮箱和名字改成自己的（我记得代码它会提示你，你到上面复制下来改一下就行）<br> <img src="https://cdn.nlark.com/yuque/0/2024/png/42554774/1730127867283-0a8ecd95-96ea-49b3-84ed-a6e04bdb5f18.png" alt="">  </p></li><li><p>配置完了以后再次输入npx hexo d上传，会弹出一个GitHub登录窗口，进行登录就可以了<br> <img src="https://cdn.nlark.com/yuque/0/2024/png/42554774/1730128118033-25b37a7d-ad8b-4146-bebb-58dd54e16c2e.png" alt=""><br> 成功后就是下图这样<br> <img src="https://cdn.nlark.com/yuque/0/2024/png/42554774/1730128563189-14de6c61-d288-4f12-8ca0-81a3b3406730.png" alt="">  </p></li><li><p>我们回到GitHub上看到仓库那边那个黄圈圈变成绿勾后就可以输入链接访问了</p></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2024/png/42554774/1730128630964-3e3913b8-4c7c-43ec-8926-cb05b6ecbea5.png" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/42554774/1730128697211-575a3abb-1d12-4cf2-a2ad-5b43f796b00d.png" alt=""></p><h2 id="六-vercel部署和绑定域名"><a href="#六-vercel部署和绑定域名" class="headerlink" title="六. vercel部署和绑定域名"></a>六. vercel部署和绑定域名</h2><blockquote><p><a href="https://www.bilibili.com/video/BV1Ke4y1v7Qr/?spm_id_from=333.1007.top_right_bar_window_history.content.click&amp;vd_source=a01a62f772bf2e577e11004dfef0bde1">第2期：Vercel部署并绑定自定义域名+安装Butterfly主题_哔哩哔哩_bilibili</a></p></blockquote><p>这一步其实也不是必须的，就是我看视频里搞了跟着随便弄的，其实我也不是很懂，因为其实到上面第五步博客就已经搭好了，这里我就简单讲讲我干了什么，不细说</p><p>第一个vercel部署，好像是会让速度更快，而且vercel好像还可以搞图床（虽然现在还不太懂图床是什么），是可以搞一下的，跟着上面那个视频来就行，挺简单的，不难</p><p>第二个就是绑定自己的域名，因为我们这个博客得绑定一个国内的域名才能在国内访问（好像是），然后就是买一个，绑一下就行，也挺简单的，上面视频讲得也很详细</p><p><strong>这样我们的博客就搭建好啦，之后就是美化什么的，希望大家都能顺利搭建！</strong></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一篇文章</title>
      <link href="/2024/10/29/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/"/>
      <url>/2024/10/29/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="这是我的第一篇文章，嘻嘻"><a href="#这是我的第一篇文章，嘻嘻" class="headerlink" title="这是我的第一篇文章，嘻嘻"></a>这是我的第一篇文章，嘻嘻</h2>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
