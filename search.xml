<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Coopersmith</title>
      <link href="/2025/02/02/Coopersmith/"/>
      <url>/2025/02/02/Coopersmith/</url>
      
        <content type="html"><![CDATA[<p>偶遇题目，拼尽全力无法战胜，故深入学习</p><blockquote><p>参考文章，建议细细研读</p><p><a href="https://zhuanlan.zhihu.com/p/4783052681">https://zhuanlan.zhihu.com/p/4783052681</a></p><p><a href="https://www.math.auckland.ac.nz/~sgal018/crypto-book/ch19.pdf">https://www.math.auckland.ac.nz/~sgal018/crypto-book/ch19.pdf</a></p><p><a href="https://doc.sagemath.org/html/en/reference/polynomial_rings/sage/rings/polynomial/polynomial_modn_dense_ntl.html#sage.rings.polynomial.polynomial_modn_dense_ntl.small_roots">https://doc.sagemath.org/html/en/reference/polynomial_rings/sage/rings/polynomial/polynomial_modn_dense_ntl.html#sage.rings.polynomial.polynomial_modn_dense_ntl.small_roots</a></p><p><a href="https://www.ruanx.net/coppersmith/">https://www.ruanx.net/coppersmith/</a></p></blockquote><h1 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h1><p>设N是一个大整数，$ p \geq N^\beta $是 N 的一个因子，设 $ f(x) $ 是一个d阶(次数为d)的多项式，令$ X=\frac{1}{2}N^{\frac{1}{d} - \varepsilon} $，其中$ 0\le\varepsilon\le min{0.18,\frac{1}{d}} $，那么对于给定的$ (N,f(x)) $，有</p><ul><li>在模N意义下，可以快速求出$ f(x)=0 $满足$ \left | x \right | \le X $的全体正整数解（就是求出X以内的根）</li><li>给定$ \beta $，可以快速求出模p意义下较小的根（就是求模因子意义下的根，可以解决低位丢失类题目）</li></ul><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>有了这个定理，相信大家一定好奇为什么，为什么可以这么做，但是这个原理挺复杂的，站长现水平无法深入理解，但是大家可以点击上面的推荐文章（尤其那本书，感觉找到宝贝了），下面会简单讲一下我的理解，不一定对，建议直接看截图</p><p>就是把一个多项式看成一个多维向量，再构造成一个格，之后再运用LLL格基规约找到一个范数最小的向量，然后根据一个引理，就可以找到这个多项式的一个根。</p><p><img src="https://cdn.nlark.com/yuque/0/2025/png/42554774/1738330147438-9ce88761-e403-45ca-9811-bb123b71efc9.png" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2025/png/42554774/1738330127252-455ad20f-96b0-42e7-8691-069701d5bf34.png" alt=""></p><h1 id="small-roots"><a href="#small-roots" class="headerlink" title="small_roots"></a>small_roots</h1><p>知道这么一个定理后我们期望在代码层面实现它，这就要用到Sagemath里的small_roots这个函数，下面会具体介绍这个函数，首先放一个具体实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">R.&lt;x&gt; = PolynomialRing(Zmod(n), implementation=<span class="string">&#x27;NTL&#x27;</span>)</span><br><span class="line">P = p + x</span><br><span class="line">low_p = P.monic().small_roots(X = <span class="number">2</span>**<span class="number">340</span>, beta = <span class="number">0.4</span>)</span><br><span class="line"><span class="built_in">print</span>(low_p)</span><br></pre></td></tr></table></figure><blockquote><p>PolynomialRing ：构造多项式环</p><p>Zmod(n) ：模运算</p><p>implementation=’NTL’ ：执行 NTL</p><p>small_roots( X=？ , beta=？ , epsilon=？)：计算多项式的小整数根，返回结果是一个列表</p><p>X：根的绝对上界，比如说下面那道题目，上界就是2**340</p><p>beta：coopersmith里的一个参数，给定$ \beta $，以快速求出模某个p意义下较小的根，其中$ p\ge n^\beta $，是n的因数，$ \beta $一般取0.4</p><p>epsilon：也是coopersmith里的一个参数，程序默认好像是$ \beta/8 $，平时不太会用到这个参数，需要时加在beta后面就行</p><p>monic()：用于将多项式的首项系数归一化为1。它接受一个多项式作为参数，然后返回一个新的多项式，其中首项系数已经被归一化为1。这个过程可以简化多项式的表达式，使其更易于计算和分析。</p></blockquote><p>这样简单的使用方法就了解了，可以看看下面的题目，自己运用一下</p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="1-where-is-P"><a href="#1-where-is-P" class="headerlink" title="1.where is P?"></a>1.where is P?</h2><p><strong>题目</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line">m=bytes_to_long(<span class="string">b&#x27;XXXX&#x27;</span>)</span><br><span class="line">e=<span class="number">65537</span></span><br><span class="line">p=getPrime(<span class="number">1024</span>)</span><br><span class="line">q=getPrime(<span class="number">1024</span>)</span><br><span class="line">n=p*q</span><br><span class="line"><span class="built_in">print</span>(p)</span><br><span class="line">c=<span class="built_in">pow</span>(m,e,n)</span><br><span class="line">P=p&gt;&gt;<span class="number">340</span></span><br><span class="line"><span class="built_in">print</span>(P)</span><br><span class="line">a=<span class="built_in">pow</span>(P,<span class="number">3</span>,n)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;n=&quot;</span>,n)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;c=&quot;</span>,c)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a=&quot;</span>,a)</span><br><span class="line"><span class="comment">#n= 24479907029118467064460793139240403258697681144532146836881997837526487637306591893357774423547391867013441147680031968367449693796015901951120514250935018725570026327610524687128709707340727799633444550317834481416507364804274266363478822257132586592232042108076935945436358397787891169163821061005102693505011197453089873909085170776511350713452580692963748763166981047023704528272230392479728897831538235554137129584665886878574314566549330671483636900134584707867654841021494106881794644469229030140144595938886437242375435914268001721437309283611088568191856208951867342004280893021653793820874747638264412653721</span></span><br><span class="line"><span class="comment">#c= 6566517934961780069851397787369134601399136324586682773286046135297104713708615112015588908759927424841719937322574766875308296258325687730658550956691921018605724308665345526807393669538103819281108643141723589363068859617542807984954436567078438099854340705208503317269397632214274507740533638883597409138972287275965697689862321166613821995226000320597560745749780942467497435742492468670016480112957715214640939272457886646483560443432985954141177463448896521810457886108311082101521263110578485768091003174683555938678346359150123350656418123918738868598042533211541966786594006129134087145798672161268647536724</span></span><br><span class="line"><span class="comment">#a= 22184346235325197613876257964606959796734210361241668065837491428527234174610482874427139453643569493268653377061231169173874401139203757698022691973395609028489121048788465356158531144787135876251872262389742175830840373281181905217510352227396545981674450409488394636498629147806808635157820030290630290808150235068140864601098322473572121965126109735529553247807211711005936042322910065304489093415276688746634951081501428768318098925390576594162098506572668709475140964400043947851427774550253257759990959997691631511262768785787474750441024242552456956598974533625095249106992723798354594261566983135394923063605</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>考点</strong>：已知p高位，求低位 ；coopersmith</p><p>根据题目我们可以知道，是将p右移了340位，我们再次左移后得到的p就会缺失低位的340位，这时候我们就得用到small_roots函数（原理是coopersmith）来获取低位。</p><p>总的来说就是这个函数可以求一个解，那么我们构造$ f=p_high+x $（在模n情况下的解，给定$ \beta $就可以快速求出模某个b意义下较小的根，其中$ b\ge n^\beta $，是n的因数）</p><p>这样我们就可以知道p的低位，然后就可以知道p，之后就可以知道q，然后就RSA解密就行，但是题目没有直接给我们p的高位，而是a，a满足下面这个式子</p><p>$ a=p^3\mod n $</p><p>所以$ p^3=a+k*n $我们爆破一下k，判断是否可以开三次方，就可以求出p（求出来的p要再左移一下才是高位）</p><p>代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sage</span></span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">n= <span class="number">24479907029118467064460793139240403258697681144532146836881997837526487637306591893357774423547391867013441147680031968367449693796015901951120514250935018725570026327610524687128709707340727799633444550317834481416507364804274266363478822257132586592232042108076935945436358397787891169163821061005102693505011197453089873909085170776511350713452580692963748763166981047023704528272230392479728897831538235554137129584665886878574314566549330671483636900134584707867654841021494106881794644469229030140144595938886437242375435914268001721437309283611088568191856208951867342004280893021653793820874747638264412653721</span></span><br><span class="line">c= <span class="number">6566517934961780069851397787369134601399136324586682773286046135297104713708615112015588908759927424841719937322574766875308296258325687730658550956691921018605724308665345526807393669538103819281108643141723589363068859617542807984954436567078438099854340705208503317269397632214274507740533638883597409138972287275965697689862321166613821995226000320597560745749780942467497435742492468670016480112957715214640939272457886646483560443432985954141177463448896521810457886108311082101521263110578485768091003174683555938678346359150123350656418123918738868598042533211541966786594006129134087145798672161268647536724</span></span><br><span class="line">a= <span class="number">22184346235325197613876257964606959796734210361241668065837491428527234174610482874427139453643569493268653377061231169173874401139203757698022691973395609028489121048788465356158531144787135876251872262389742175830840373281181905217510352227396545981674450409488394636498629147806808635157820030290630290808150235068140864601098322473572121965126109735529553247807211711005936042322910065304489093415276688746634951081501428768318098925390576594162098506572668709475140964400043947851427774550253257759990959997691631511262768785787474750441024242552456956598974533625095249106992723798354594261566983135394923063605</span></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">    p = a+k*n</span><br><span class="line">    <span class="keyword">if</span> gmpy2.iroot(p,<span class="number">3</span>)[<span class="number">1</span>]:</span><br><span class="line">        <span class="built_in">print</span>(k)</span><br><span class="line">        <span class="built_in">print</span>(gmpy2.iroot(p,<span class="number">3</span>)[<span class="number">0</span>])</span><br><span class="line">p=<span class="number">148500014720728755901835170447203030242113125689825190413979909224639701026120883281188694701625473553602289432755479244507504340127322979884849883842306663453018960250560834067472479033116264539127330613635903666209920113813160301513820286874124210921593865507657148933555053341577090100101684021531775022459</span></span><br><span class="line">p=p&lt;&lt;<span class="number">340</span></span><br><span class="line"><span class="built_in">print</span>(p)</span><br><span class="line">R.&lt;x&gt; = PolynomialRing(Zmod(n), implementation=<span class="string">&#x27;NTL&#x27;</span>)</span><br><span class="line"></span><br><span class="line">P = p + x</span><br><span class="line">low_p = P.monic().small_roots(X = <span class="number">2</span>**<span class="number">340</span>, beta = <span class="number">0.4</span>)[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(p+low_p)</span><br><span class="line">p=p+low_p</span><br><span class="line">q=n//p</span><br><span class="line">n = p * q</span><br><span class="line">phin = (p - <span class="number">1</span>)*(q - <span class="number">1</span>)          <span class="comment"># 欧拉函数</span></span><br><span class="line">d = gmpy2.invert(e,phin)</span><br><span class="line">m = <span class="built_in">pow</span>(c,d,n)</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(m))</span><br><span class="line"></span><br><span class="line"><span class="comment"># LitCTF&#123;Y0U_hAV3_g0T_Th3_r1ghT_AnsW3r&#125;</span></span><br></pre></td></tr></table></figure><h2 id="2-easy-ya"><a href="#2-easy-ya" class="headerlink" title="2.easy_ya"></a>2.easy_ya</h2><p><strong>题目</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> flag <span class="keyword">import</span> flag</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gen</span>():</span><br><span class="line">    e = <span class="number">3</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            p = getPrime(<span class="number">512</span>)</span><br><span class="line">            q = getPrime(<span class="number">512</span>)</span><br><span class="line">            n = p*q</span><br><span class="line">            phi = (p-<span class="number">1</span>)*(q-<span class="number">1</span>)</span><br><span class="line">            d = inverse(e,phi)</span><br><span class="line">            <span class="keyword">return</span> p,q,d,n,e</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">p,q,d,n,e = gen()</span><br><span class="line">r = getPrime(<span class="number">512</span>)</span><br><span class="line">m = bytes_to_long(flag+os.urandom(<span class="number">32</span>))</span><br><span class="line">M = m%r</span><br><span class="line">c = <span class="built_in">pow</span>(m,e,n)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;r = %d&quot;</span>%r)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;M = %d&quot;</span>%M)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;n = %d&quot;</span>%n)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;e = %d&quot;</span>%e)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;c = %d&quot;</span>%c)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">r = 7996728164495259362822258548434922741290100998149465194487628664864256950051236186227986990712837371289585870678059397413537714250530572338774305952904473</span></span><br><span class="line"><span class="string">M = 4159518144549137412048572485195536187606187833861349516326031843059872501654790226936115271091120509781872925030241137272462161485445491493686121954785558</span></span><br><span class="line"><span class="string">n = 131552964273731742744001439326470035414270864348139594004117959631286500198956302913377947920677525319260242121507196043323292374736595943942956194902814842206268870941485429339132421676367167621812260482624743821671183297023718573293452354284932348802548838847981916748951828826237112194142035380559020560287</span></span><br><span class="line"><span class="string">e = 3</span></span><br><span class="line"><span class="string">c = 46794664006708417132147941918719938365671485176293172014575392203162005813544444720181151046818648417346292288656741056411780813044749520725718927535262618317679844671500204720286218754536643881483749892207516758305694529993542296670281548111692443639662220578293714396224325591697834572209746048616144307282</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>考点</strong>：coopersmith</p><p>一开始看到e很小，想到会不会是低密指数加密，用了那个脚本发现不行，爆不出来，说明得用别的方法，那只能关注<code>M = m%r</code>这个式子，我们可以得到$ m=M+k*r $</p><p>再根据rsa加密的式子，我们就可以得到下面这个多项式</p><p>$ c=m^e\mod n $</p><p>$ m^e-c=(M+k*r)^3-c=0\mod n $</p><p>所以$ f=(M+k<em>r)^3-c $，这样我们就可以根据small_roots()函数求k，唯一有点挑战的是k的上限我们不知道，得猜一下，实测2<em>*80到2</em></em>255都可以求出k，这也说明了这个上界参数不是越大越好</p><p>具体代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">r = <span class="number">7996728164495259362822258548434922741290100998149465194487628664864256950051236186227986990712837371289585870678059397413537714250530572338774305952904473</span></span><br><span class="line">M = <span class="number">4159518144549137412048572485195536187606187833861349516326031843059872501654790226936115271091120509781872925030241137272462161485445491493686121954785558</span></span><br><span class="line">n = <span class="number">131552964273731742744001439326470035414270864348139594004117959631286500198956302913377947920677525319260242121507196043323292374736595943942956194902814842206268870941485429339132421676367167621812260482624743821671183297023718573293452354284932348802548838847981916748951828826237112194142035380559020560287</span></span><br><span class="line">e = <span class="number">3</span></span><br><span class="line">c = <span class="number">46794664006708417132147941918719938365671485176293172014575392203162005813544444720181151046818648417346292288656741056411780813044749520725718927535262618317679844671500204720286218754536643881483749892207516758305694529993542296670281548111692443639662220578293714396224325591697834572209746048616144307282</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R.&lt;x&gt; = PolynomialRing(Zmod(n), implementation=<span class="string">&#x27;NTL&#x27;</span>)</span><br><span class="line"></span><br><span class="line">f = (M + x*r)**<span class="number">3</span>-c</span><br><span class="line">k = f.monic().small_roots(X = <span class="number">2</span>**<span class="number">80</span>, beta = <span class="number">0.4</span>)[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(k)</span><br><span class="line">k=<span class="number">810968823598060539864535</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(M+k*r))</span><br><span class="line"></span><br><span class="line"><span class="comment"># flag&#123;53a2e494-964d-4506-a2c4-c34b9475dedd&#125;</span></span><br></pre></td></tr></table></figure><h2 id="3-baby-xor"><a href="#3-baby-xor" class="headerlink" title="3.baby_xor"></a>3.baby_xor</h2><p><strong>题目</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag</span><br><span class="line"></span><br><span class="line">m = bytes_to_long(flag)</span><br><span class="line"><span class="keyword">assert</span> <span class="built_in">len</span>(flag)==<span class="number">32</span></span><br><span class="line">p = getPrime(<span class="number">512</span>)</span><br><span class="line">q = getPrime(<span class="number">512</span>)</span><br><span class="line">n = p*q</span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">c1 = p^m</span><br><span class="line">c2 = <span class="built_in">pow</span>(m,e,n)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;n = <span class="subst">&#123;n&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;c1 = <span class="subst">&#123;c1&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;c2 = <span class="subst">&#123;c2&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">n = 139167681803392690594490403105432649693546256181767408269202101512534988406137879788255103631885736461742577594980136624933914700779445704490217419248411578290305101891222576080645870988658334799437317221565839991979543660824098367011942169305111105129234902517835649895908656770416774539906212596072334423407</span></span><br><span class="line"><span class="string">c1 = 11201139662236758800406931253538295757259990870588609533820056210585752522925690049252488581929717556881067021381940083808024384402885422258545946243513996</span></span><br><span class="line"><span class="string">c2 = 112016152270171196606652761990170033221036025260883289104273504703557624964071464062375228351458191745141525003775876044271210498526920529385038130932141551598616579917681815276713386113932345056134302042399379895915706991873687943357627747262597883603999621939794450743982662393955266685255577026078256473601</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>考点</strong>：coopersmith</p><blockquote><p><a href="https://www.math.auckland.ac.nz/~sgal018/crypto-book/ch19.pdf">https://www.math.auckland.ac.nz/~sgal018/crypto-book/ch19.pdf</a> 很好的一本书，偶然发现</p></blockquote><p>很明显，我们得从<code>c1 = p^m</code>这个式子入手，因为<code>len(flag)==32</code>，这就相当于256位，所以p的前256位是正常的，就是低位缺失了，用small_roots函数求低位，但是发现求不出来，后面查了一下才发现是知道应该是高位不够，得再爆破出一部分（看了文献才知道小根好像得小于$ \frac{1}{2\sqrt2}N^{\frac{1}{4}-\varepsilon} $）</p><p>网上查了代码，如下（导入的tqdm库就是给一个进度条，好看一点，真的爆了好久好久）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">n = <span class="number">139167681803392690594490403105432649693546256181767408269202101512534988406137879788255103631885736461742577594980136624933914700779445704490217419248411578290305101891222576080645870988658334799437317221565839991979543660824098367011942169305111105129234902517835649895908656770416774539906212596072334423407</span></span><br><span class="line">c1 = <span class="number">11201139662236758800406931253538295757259990870588609533820056210585752522925690049252488581929717556881067021381940083808024384402885422258545946243513996</span></span><br><span class="line">e=<span class="number">65537</span></span><br><span class="line">pbits = <span class="number">512</span></span><br><span class="line">p_high = c1 &gt;&gt; <span class="number">256</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> trange(<span class="number">2</span>**<span class="number">8</span>):</span><br><span class="line">     p4 = p_high&lt;&lt;<span class="number">8</span></span><br><span class="line">     p4 = p4 + i</span><br><span class="line">     kbits = pbits - p4.nbits()</span><br><span class="line">     p4 = p4 &lt;&lt; kbits</span><br><span class="line">     PR.&lt;x&gt; = PolynomialRing(Zmod(n))</span><br><span class="line">     f = x + p4</span><br><span class="line">     roots = f.small_roots(X=<span class="number">2</span>^kbits, beta=<span class="number">0.4</span>, epsilon=<span class="number">0.01</span>)</span><br><span class="line">     <span class="keyword">if</span> roots:</span><br><span class="line">         p = p4 + <span class="built_in">int</span>(roots[<span class="number">0</span>])</span><br><span class="line">         <span class="keyword">break</span></span><br><span class="line"><span class="built_in">print</span>(p)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 11201139662236758800406931253538295757259990870588609533820056210585752522925662842097418194280333596411677923137891577493678147771013147838272857867768049</span></span><br></pre></td></tr></table></figure><p>爆出来p就可以基本RSA解密了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="number">139167681803392690594490403105432649693546256181767408269202101512534988406137879788255103631885736461742577594980136624933914700779445704490217419248411578290305101891222576080645870988658334799437317221565839991979543660824098367011942169305111105129234902517835649895908656770416774539906212596072334423407</span></span><br><span class="line">e=<span class="number">65537</span></span><br><span class="line">p=<span class="number">11201139662236758800406931253538295757259990870588609533820056210585752522925662842097418194280333596411677923137891577493678147771013147838272857867768049</span></span><br><span class="line">q=n//p</span><br><span class="line">c = <span class="number">112016152270171196606652761990170033221036025260883289104273504703557624964071464062375228351458191745141525003775876044271210498526920529385038130932141551598616579917681815276713386113932345056134302042399379895915706991873687943357627747262597883603999621939794450743982662393955266685255577026078256473601</span></span><br><span class="line"></span><br><span class="line">phin = (p - <span class="number">1</span>)*(q - <span class="number">1</span>)          </span><br><span class="line">d = gmpy2.invert(e,phin)       </span><br><span class="line"></span><br><span class="line">m = <span class="built_in">pow</span>(c,d,n)</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(m))</span><br><span class="line"></span><br><span class="line"><span class="comment"># LitCTF&#123;oh!!!!coppersmith_is_fun&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>对称密码—流密码</title>
      <link href="/2025/01/22/%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%81%E2%80%94%E6%B5%81%E5%AF%86%E7%A0%81/"/>
      <url>/2025/01/22/%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%81%E2%80%94%E6%B5%81%E5%AF%86%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h1 id="RC4"><a href="#RC4" class="headerlink" title="RC4"></a>RC4</h1><h2 id="加密流程"><a href="#加密流程" class="headerlink" title="加密流程"></a>加密流程</h2><h3 id="初始化算法-KSA"><a href="#初始化算法-KSA" class="headerlink" title="初始化算法(KSA)"></a><strong>初始化算法(KSA)</strong></h3><p><strong>Step</strong>1：先生成一个key，自定义。</p><p><strong>Step2</strong>：生成一个S盒，S盒有256个元素，分别是0，1，2，······，255。</p><p><img src="https://cdn.nlark.com/yuque/0/2025/png/42554774/1737530118391-e6a0f588-432c-419e-8d43-7dac2223eaff.png" alt=""></p><p><strong>Step3</strong>：生成一个K盒，同样是256个元素，这个K盒用key来填充，如果key是345，那么就3，4，5，3，4，5，3，4，5······这样一直重复填充下去。</p><p><img src="https://cdn.nlark.com/yuque/0/2025/png/42554774/1737530138496-f233326e-ce25-4e35-a533-5e8e827558d1.png" alt=""></p><p><strong>Step4</strong>：利用K盒来打乱我们刚刚生成的S盒，这个是通过一个规定的转换式子，每做一次，就交换S盒里的两个值。</p><p><img src="https://cdn.nlark.com/yuque/0/2025/png/42554774/1737439889235-473701e8-5e24-4bab-b845-3c8eaad335bf.png?x-oss-process=image%2Fformat%2Cwebp" alt=""></p><p>eg：按上面我们那个K表打乱后的S表如下，大家可以自己试一下（循环了七次）</p><p><img src="https://cdn.nlark.com/yuque/0/2025/png/42554774/1737530320751-f4ff1e23-f968-42bb-94c7-88b6055188d4.png" alt=""></p><h3 id="伪随机子密码生成算法（PRGA"><a href="#伪随机子密码生成算法（PRGA" class="headerlink" title="伪随机子密码生成算法（PRGA)"></a><strong>伪随机子密码生成算法（PRGA)</strong></h3><p>这一步是为了生成一个新盒，这个新盒里是一些伪随机的子密码，用来加密我们的明文，这个生成过程也有规定的式子，如下</p><p><img src="https://cdn.nlark.com/yuque/0/2025/png/42554774/1737440962165-c5c6764c-3539-4afa-8620-194787c452dc.png?x-oss-process=image%2Fformat%2Cwebp" alt=""></p><p>上图是用我们之前的K盒直接存储新生成的伪随机子密码，这无可厚非，只要S盒初始化过后（打乱后）K盒就没什么用了。</p><p>之后就是加密过程，就是用我们最后得到的那个子密码来和明文做异或，得到密文。</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="notRC4"><a href="#notRC4" class="headerlink" title="notRC4"></a>notRC4</h3><p><strong>题目</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> md5</span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Oo0</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.O0 = [<span class="number">0</span>] * <span class="number">256</span></span><br><span class="line">        <span class="variable language_">self</span>.Ooo = <span class="number">0</span></span><br><span class="line">        <span class="variable language_">self</span>.Ooo0 = [<span class="number">0</span>] * <span class="number">256</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">            <span class="variable language_">self</span>.O0[i] = i</span><br><span class="line">        <span class="variable language_">self</span>.oO0 = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">OO0</span>(<span class="params">self, oO0</span>):</span><br><span class="line">        l = <span class="built_in">len</span>(oO0)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">            <span class="variable language_">self</span>.Ooo0[i] = oO0[i % l]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">            <span class="variable language_">self</span>.oO0 = (<span class="variable language_">self</span>.oO0 + <span class="variable language_">self</span>.O0[i] + <span class="variable language_">self</span>.Ooo0[i]) % <span class="number">256</span></span><br><span class="line">            <span class="variable language_">self</span>.O0[i], <span class="variable language_">self</span>.O0[<span class="variable language_">self</span>.oO0] = <span class="variable language_">self</span>.O0[<span class="variable language_">self</span>.oO0], <span class="variable language_">self</span>.O0[i]</span><br><span class="line">        <span class="variable language_">self</span>.Ooo = <span class="variable language_">self</span>.oO0 = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">OO0o</span>(<span class="params">self, length</span>):</span><br><span class="line">        O = []</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">            <span class="variable language_">self</span>.Ooo = (<span class="variable language_">self</span>.Ooo + <span class="number">1</span>) % <span class="number">256</span></span><br><span class="line">            <span class="variable language_">self</span>.oO0 = (<span class="variable language_">self</span>.oO0 + <span class="variable language_">self</span>.O0[<span class="variable language_">self</span>.Ooo]) % <span class="number">256</span></span><br><span class="line">            <span class="variable language_">self</span>.O0[<span class="variable language_">self</span>.Ooo], <span class="variable language_">self</span>.O0[<span class="variable language_">self</span>.oO0] = <span class="variable language_">self</span>.O0[<span class="variable language_">self</span>.oO0], <span class="variable language_">self</span>.O0[<span class="variable language_">self</span>.Ooo]</span><br><span class="line">            t = (<span class="variable language_">self</span>.O0[<span class="variable language_">self</span>.Ooo] + <span class="variable language_">self</span>.O0[<span class="variable language_">self</span>.oO0]) % <span class="number">256</span></span><br><span class="line">            O.append(<span class="variable language_">self</span>.O0[t])</span><br><span class="line">        <span class="built_in">print</span>(<span class="variable language_">self</span>.O0)</span><br><span class="line">        <span class="keyword">return</span> O</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">xor</span>(<span class="params">s1, s2</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">bytes</span>(<span class="built_in">map</span>((<span class="keyword">lambda</span> x: x[<span class="number">0</span>] ^ x[<span class="number">1</span>]), <span class="built_in">zip</span>(s1, s2)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">enc</span>(<span class="params">msg</span>):</span><br><span class="line">    Oo0oO = Oo0()</span><br><span class="line">    Oo0oO.OO0(md5(msg).digest()[:<span class="number">8</span>])</span><br><span class="line">    O0O = Oo0oO.OO0o(<span class="built_in">len</span>(msg))</span><br><span class="line">    <span class="keyword">return</span> xor(msg, O0O)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(enc(flag))</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">s = [166, 163, 208, 147, 181, 152, 69, 90, 253, 114, 150, 255, 218, 220, 34, 74, 63, 201, 70, 115, 233, 96, 43, 169, 103, 191, 14, 149, 143, 25, 105, 93, 199, 246, 51, 75, 20, 5, 107, 3, 52, 135, 111, 139, 113, 47, 184, 76, 161, 174, 23, 30, 173, 72, 198, 56, 85, 55, 106, 126, 244, 223, 104, 29, 112, 148, 219, 118, 165, 59, 98, 175, 125, 100, 17, 16, 108, 6, 214, 140, 130, 206, 89, 62, 4, 236, 251, 91, 28, 45, 18, 53, 1, 144, 193, 133, 73, 44, 57, 88, 250, 204, 177, 67, 120, 21, 79, 71, 2, 185, 211, 200, 65, 234, 117, 9, 226, 142, 230, 209, 132, 248, 242, 196, 101, 81, 238, 247, 119, 179, 131, 229, 94, 50, 22, 183, 24, 158, 190, 222, 155, 172, 19, 12, 225, 10, 189, 232, 146, 227, 212, 210, 31, 164, 138, 78, 122, 176, 121, 0, 194, 186, 162, 160, 188, 168, 216, 153, 37, 252, 127, 145, 33, 82, 58, 170, 61, 254, 136, 207, 8, 237, 159, 36, 239, 95, 178, 167, 182, 102, 27, 123, 60, 129, 42, 26, 99, 39, 97, 40, 235, 205, 7, 49, 202, 197, 109, 195, 245, 171, 180, 15, 46, 83, 48, 156, 92, 249, 38, 32, 203, 41, 124, 54, 217, 134, 154, 35, 157, 128, 137, 221, 84, 86, 215, 213, 80, 11, 116, 141, 241, 64, 224, 87, 77, 187, 68, 192, 151, 240, 13, 228, 231, 66, 110, 243]</span></span><br><span class="line"><span class="string">enc = b&quot;]7\xab\xc9\xd8\x90\x1f\xd2OP\xad\x87&#x27;0\xe1\xff=~&quot;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>考点</strong>：rc4，异或</p><blockquote><p><a href="https://cn-sec.com/archives/3093479.html">https://cn-sec.com/archives/3093479.html</a> 可以参考这篇博客理解</p><p><a href="https://www.bilibili.com/video/BV1G64y1Y7p4/?spm_id_from=333.337.search-card.all.click&amp;vd_source=a01a62f772bf2e577e11004dfef0bde1">https://www.bilibili.com/video/BV1G64y1Y7p4/?spm_id_from=333.337.search-card.all.click&amp;vd_source=a01a62f772bf2e577e11004dfef0bde1</a> 这个视频也很棒</p></blockquote><p>虽然题目是notRC4，但流程上就是RC4，所以先了解一下RC4的过程。</p><p>首先是<strong>初始化算法(KSA)</strong></p><p>首先生成一个S盒，S盒有256个元素，分别是0，1，2，······，255，对应题目以下代码（代码只截取重要部分，建议定位到题目中分析）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">self</span>.O0 = [<span class="number">0</span>] * <span class="number">256</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">            <span class="variable language_">self</span>.O0[i] = i</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>再生成一个K盒，同样是256个元素，这个K盒用key来填充，如果key是123，那么就1，2，3，1，2，3，1，2，3······这样一直重复填充下去，直到填充完毕，对应下面代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">self</span>.Ooo0 = [<span class="number">0</span>] * <span class="number">256</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">OO0</span>(<span class="params">self, oO0</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">        <span class="variable language_">self</span>.Ooo0[i] = oO0[i % l]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接着我们要利用K盒来打乱我们刚刚生成的S盒，这个是通过一个规定的转换式子，每做一次，就交换S盒里的两个值，如下</p><p><img src="https://cdn.nlark.com/yuque/0/2025/png/42554774/1737439889235-473701e8-5e24-4bab-b845-3c8eaad335bf.png" alt=""></p><p>因为S[i]是固定的，所以打乱完全取决于K盒，打乱后的S盒我们称为初始化后的S盒，对应以下代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">           <span class="variable language_">self</span>.oO0 = (<span class="variable language_">self</span>.oO0 + <span class="variable language_">self</span>.O0[i] + <span class="variable language_">self</span>.Ooo0[i]) % <span class="number">256</span></span><br><span class="line">           <span class="variable language_">self</span>.O0[i], <span class="variable language_">self</span>.O0[<span class="variable language_">self</span>.oO0] = <span class="variable language_">self</span>.O0[<span class="variable language_">self</span>.oO0], <span class="variable language_">self</span>.O0[i]</span><br><span class="line">       <span class="variable language_">self</span>.Ooo = <span class="variable language_">self</span>.oO0 = <span class="number">0</span><span class="comment"># 这里是为了后面的使用，所以再次赋0，主要是上面部分</span></span><br></pre></td></tr></table></figure><p>接着是<strong>伪随机子密码生成算法（PRGA)、加密阶段</strong></p><p>这一步是为了生成一个新盒，这个新盒里是一些伪随机的子密码，用来加密我们的明文，这个生成过程也有规定的式子，如下</p><p><img src="https://cdn.nlark.com/yuque/0/2025/png/42554774/1737440962165-c5c6764c-3539-4afa-8620-194787c452dc.png" alt=""></p><p>上图是用我们之前的K盒直接存储新生成的伪随机子密码，这无可厚非，只要S盒初始化过后（打乱后）K盒就没什么用了。这一部分对应题目代码如下（题目是用一个新的列表放子密码的，即O）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">OO0o</span>(<span class="params">self, length</span>):</span><br><span class="line">        O = []</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">            <span class="variable language_">self</span>.Ooo = (<span class="variable language_">self</span>.Ooo + <span class="number">1</span>) % <span class="number">256</span></span><br><span class="line">            <span class="variable language_">self</span>.oO0 = (<span class="variable language_">self</span>.oO0 + <span class="variable language_">self</span>.O0[<span class="variable language_">self</span>.Ooo]) % <span class="number">256</span></span><br><span class="line">            <span class="variable language_">self</span>.O0[<span class="variable language_">self</span>.Ooo], <span class="variable language_">self</span>.O0[<span class="variable language_">self</span>.oO0] = <span class="variable language_">self</span>.O0[<span class="variable language_">self</span>.oO0], <span class="variable language_">self</span>.O0[<span class="variable language_">self</span>.Ooo]</span><br><span class="line">            t = (<span class="variable language_">self</span>.O0[<span class="variable language_">self</span>.Ooo] + <span class="variable language_">self</span>.O0[<span class="variable language_">self</span>.oO0]) % <span class="number">256</span></span><br><span class="line">            O.append(<span class="variable language_">self</span>.O0[t])</span><br><span class="line">        <span class="built_in">print</span>(<span class="variable language_">self</span>.O0)</span><br><span class="line">        <span class="keyword">return</span> O</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>之后就是加密过程，就是用我们最后得到的那个子密码来和明文做异或，得到密文。对应下面这段代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">xor</span>(<span class="params">s1, s2</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">bytes</span>(<span class="built_in">map</span>((<span class="keyword">lambda</span> x: x[<span class="number">0</span>] ^ x[<span class="number">1</span>]), <span class="built_in">zip</span>(s1, s2)))<span class="comment"># zip会返回一个元组的列表，返回列表长度与最短的对象相同</span></span><br><span class="line">xor(msg, O0O)<span class="comment"># O0O就是上面return的O</span></span><br></pre></td></tr></table></figure><p>到此，题目的加密过程完毕，输出了最后的S盒和密文</p><p>这道题感觉难就难变量定义的稀奇古怪，让人没有看下去的欲望，如果分析不下去了建议休息会再看，不然真的脑壳痛（恼）</p><p>那么我们要怎么求解明文呢？就要用到异或的知识。密文是通过异或得到的，要变回去，我们就得知道子密码盒，然后再异或一次就可以得到flag了，所以现在目的是求子密码盒。</p><p>这里我们就得考虑flag的格式，我们可以想到flag肯定是以’}’结尾的，这个已知，我们和密文异或，就可以得到一个子密码，即S[t]，知道S[t]以后，我们通过index函数就可以查列表的下标，于是我们就可以知道t</p><p>t知道以后我们关注这个式子<code>t = (self.O0[self.Ooo] + self.O0[self.oO0]) % 256</code>我们换种写法可能好看一点<code>t = (S[i] + S[j]) %256</code>，S[i]是已知的（最后一次i就是明文的长度，S盒又是知道的，所以S[i]已知）我们就可以得出S[j]，这样我们通过index就可以知道j，i和j都知道以后我们就可以逆推回去，把每一次的S[t]都算出来，这样和密文异或就可以把明文求出了，可以在纸上写一下，会很清晰</p><p><img src="https://cdn.nlark.com/yuque/0/2025/jpeg/42554774/1737444427312-6ad0c4ab-1185-4814-ad0e-98dbf1409cb1.jpeg" alt=""></p><p>代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">s = [<span class="number">166</span>, <span class="number">163</span>, <span class="number">208</span>, <span class="number">147</span>, <span class="number">181</span>, <span class="number">152</span>, <span class="number">69</span>, <span class="number">90</span>, <span class="number">253</span>, <span class="number">114</span>, <span class="number">150</span>, <span class="number">255</span>, <span class="number">218</span>, <span class="number">220</span>, <span class="number">34</span>, <span class="number">74</span>, <span class="number">63</span>, <span class="number">201</span>, <span class="number">70</span>, <span class="number">115</span>, <span class="number">233</span>, <span class="number">96</span>, <span class="number">43</span>, <span class="number">169</span>, <span class="number">103</span>, <span class="number">191</span>, <span class="number">14</span>, <span class="number">149</span>, <span class="number">143</span>, <span class="number">25</span>, <span class="number">105</span>, <span class="number">93</span>, <span class="number">199</span>, <span class="number">246</span>, <span class="number">51</span>, <span class="number">75</span>, <span class="number">20</span>, <span class="number">5</span>, <span class="number">107</span>, <span class="number">3</span>, <span class="number">52</span>, <span class="number">135</span>, <span class="number">111</span>, <span class="number">139</span>, <span class="number">113</span>, <span class="number">47</span>, <span class="number">184</span>, <span class="number">76</span>, <span class="number">161</span>, <span class="number">174</span>, <span class="number">23</span>, <span class="number">30</span>, <span class="number">173</span>, <span class="number">72</span>, <span class="number">198</span>, <span class="number">56</span>, <span class="number">85</span>, <span class="number">55</span>, <span class="number">106</span>, <span class="number">126</span>, <span class="number">244</span>, <span class="number">223</span>, <span class="number">104</span>, <span class="number">29</span>, <span class="number">112</span>, <span class="number">148</span>, <span class="number">219</span>, <span class="number">118</span>, <span class="number">165</span>, <span class="number">59</span>, <span class="number">98</span>, <span class="number">175</span>, <span class="number">125</span>, <span class="number">100</span>, <span class="number">17</span>, <span class="number">16</span>, <span class="number">108</span>, <span class="number">6</span>, <span class="number">214</span>, <span class="number">140</span>, <span class="number">130</span>, <span class="number">206</span>, <span class="number">89</span>, <span class="number">62</span>, <span class="number">4</span>, <span class="number">236</span>, <span class="number">251</span>, <span class="number">91</span>, <span class="number">28</span>, <span class="number">45</span>, <span class="number">18</span>, <span class="number">53</span>, <span class="number">1</span>, <span class="number">144</span>, <span class="number">193</span>, <span class="number">133</span>, <span class="number">73</span>, <span class="number">44</span>, <span class="number">57</span>, <span class="number">88</span>, <span class="number">250</span>, <span class="number">204</span>, <span class="number">177</span>, <span class="number">67</span>, <span class="number">120</span>, <span class="number">21</span>, <span class="number">79</span>, <span class="number">71</span>, <span class="number">2</span>, <span class="number">185</span>, <span class="number">211</span>, <span class="number">200</span>, <span class="number">65</span>, <span class="number">234</span>, <span class="number">117</span>, <span class="number">9</span>, <span class="number">226</span>, <span class="number">142</span>, <span class="number">230</span>, <span class="number">209</span>, <span class="number">132</span>, <span class="number">248</span>, <span class="number">242</span>, <span class="number">196</span>, <span class="number">101</span>, <span class="number">81</span>, <span class="number">238</span>, <span class="number">247</span>, <span class="number">119</span>, <span class="number">179</span>, <span class="number">131</span>, <span class="number">229</span>, <span class="number">94</span>, <span class="number">50</span>, <span class="number">22</span>, <span class="number">183</span>, <span class="number">24</span>, <span class="number">158</span>, <span class="number">190</span>, <span class="number">222</span>, <span class="number">155</span>, <span class="number">172</span>, <span class="number">19</span>, <span class="number">12</span>, <span class="number">225</span>, <span class="number">10</span>, <span class="number">189</span>, <span class="number">232</span>, <span class="number">146</span>, <span class="number">227</span>, <span class="number">212</span>, <span class="number">210</span>, <span class="number">31</span>, <span class="number">164</span>, <span class="number">138</span>, <span class="number">78</span>, <span class="number">122</span>, <span class="number">176</span>, <span class="number">121</span>, <span class="number">0</span>, <span class="number">194</span>, <span class="number">186</span>, <span class="number">162</span>, <span class="number">160</span>, <span class="number">188</span>, <span class="number">168</span>, <span class="number">216</span>, <span class="number">153</span>, <span class="number">37</span>, <span class="number">252</span>, <span class="number">127</span>, <span class="number">145</span>, <span class="number">33</span>, <span class="number">82</span>, <span class="number">58</span>, <span class="number">170</span>, <span class="number">61</span>, <span class="number">254</span>, <span class="number">136</span>, <span class="number">207</span>, <span class="number">8</span>, <span class="number">237</span>, <span class="number">159</span>, <span class="number">36</span>, <span class="number">239</span>, <span class="number">95</span>, <span class="number">178</span>, <span class="number">167</span>, <span class="number">182</span>, <span class="number">102</span>, <span class="number">27</span>, <span class="number">123</span>, <span class="number">60</span>, <span class="number">129</span>, <span class="number">42</span>, <span class="number">26</span>, <span class="number">99</span>, <span class="number">39</span>, <span class="number">97</span>, <span class="number">40</span>, <span class="number">235</span>, <span class="number">205</span>, <span class="number">7</span>, <span class="number">49</span>, <span class="number">202</span>, <span class="number">197</span>, <span class="number">109</span>, <span class="number">195</span>, <span class="number">245</span>, <span class="number">171</span>, <span class="number">180</span>, <span class="number">15</span>, <span class="number">46</span>, <span class="number">83</span>, <span class="number">48</span>, <span class="number">156</span>, <span class="number">92</span>, <span class="number">249</span>, <span class="number">38</span>, <span class="number">32</span>, <span class="number">203</span>, <span class="number">41</span>, <span class="number">124</span>, <span class="number">54</span>, <span class="number">217</span>, <span class="number">134</span>, <span class="number">154</span>, <span class="number">35</span>, <span class="number">157</span>, <span class="number">128</span>, <span class="number">137</span>, <span class="number">221</span>, <span class="number">84</span>, <span class="number">86</span>, <span class="number">215</span>, <span class="number">213</span>, <span class="number">80</span>, <span class="number">11</span>, <span class="number">116</span>, <span class="number">141</span>, <span class="number">241</span>, <span class="number">64</span>, <span class="number">224</span>, <span class="number">87</span>, <span class="number">77</span>, <span class="number">187</span>, <span class="number">68</span>, <span class="number">192</span>, <span class="number">151</span>, <span class="number">240</span>, <span class="number">13</span>, <span class="number">228</span>, <span class="number">231</span>, <span class="number">66</span>, <span class="number">110</span>, <span class="number">243</span>]</span><br><span class="line">a = <span class="string">b&quot;]7\xab\xc9\xd8\x90\x1f\xd2OP\xad\x87&#x27;0\xe1\xff=~&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">t=s.index(<span class="built_in">ord</span>(<span class="string">&#x27;&#125;&#x27;</span>)^<span class="built_in">ord</span>(<span class="string">&#x27;~&#x27;</span>))</span><br><span class="line">i=<span class="number">18</span></span><br><span class="line">sj=(t-s[i])%<span class="number">256</span></span><br><span class="line">j=s.index(sj)</span><br><span class="line">s[i],s[j]=s[j],s[i]</span><br><span class="line">j=(j-s[i])%<span class="number">256</span></span><br><span class="line">i=i-<span class="number">1</span></span><br><span class="line">t=(s[i]+s[j])%<span class="number">256</span></span><br><span class="line">flag=<span class="string">&#x27;&#125;&#x27;</span></span><br><span class="line"><span class="keyword">while</span> i&gt;<span class="number">0</span>:</span><br><span class="line">    flag+=(<span class="built_in">chr</span>((a[i-<span class="number">1</span>])^s[t]))</span><br><span class="line">    s[i],s[j]=s[j],s[i]</span><br><span class="line">    j=(j-s[i])%<span class="number">256</span></span><br><span class="line">    i=i-<span class="number">1</span></span><br><span class="line">    t=(s[i]+s[j])%<span class="number">256</span></span><br><span class="line"></span><br><span class="line">flag=flag[::-<span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br><span class="line"></span><br><span class="line"><span class="comment"># flag&#123;einfache_rc4&#125;</span></span><br></pre></td></tr></table></figure><h1 id="LCG"><a href="#LCG" class="headerlink" title="LCG"></a>LCG</h1><blockquote><p><a href="https://www.cnblogs.com/vancasola/p/9942583.html">https://www.cnblogs.com/vancasola/p/9942583.html</a></p><p><a href="https://en.wikipedia.org/wiki/Linear_congruential_generator">https://en.wikipedia.org/wiki/Linear_congruential_generator</a></p><p><a href="https://blog.csdn.net/m0_74345946/article/details/132888135?ops_request_misc=%257B%2522request%255Fid%2522%253A%25221dd70df47b55af8763c80a26c08369d7%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=1dd70df47b55af8763c80a26c08369d7&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-132888135-null-null.142^v101^pc_search_result_base7&amp;utm_term=lcg&amp;spm=1018.2226.3001.4187">LCG入门-CSDN博客</a></p></blockquote><h2 id="加密流程-1"><a href="#加密流程-1" class="headerlink" title="加密流程"></a>加密流程</h2><p>LCG（linear congruential generator）线性同余算法由以下参数组成：</p><div class="table-container"><table><thead><tr><th>参数</th><th>m</th><th>a</th><th>b</th><th>X</th></tr></thead><tbody><tr><td>性质</td><td>模数</td><td>乘数</td><td>加数</td><td>随机数</td></tr><tr><td>作用</td><td>取模</td><td>移位</td><td>偏移</td><td>作为结果</td></tr></tbody></table></div><p>LCG算法是如下的一个递推公式，每下一个随机数是当前随机数向左移动 $ log_2a<br> $ 位，加上一个 b，最后对 m 取余，使随机数限制在 0 ~ m-1 内</p><p>$ X_{n+1}=(aX_{n}+b)\mod m $</p><p>只要我们知道上面的重要参数，要求哪个都很轻松，所以要知道以下公式</p><p><strong>公式1</strong>：反推$ X_n $</p><p>$ X_{n}=(X_{n+1}-b)*a^{-1}\mod m $</p><p><strong>公式2</strong>：求a</p><p>$ a=(X_{i-1}-X_{i-2})^{-1}*(X_{i}-X_{i-1})\mod p $</p><p><strong>公式3</strong>：求b</p><p>$ b=(X_{i+1}-aX_i)\mod m $</p><p><strong>公式4</strong>：求m</p><p>$ t_i=(X_i-X_{i-1})=a(X_{i-1}-X_{i-2})=a*t_{i-1}\mod m $</p><p>$ t_{i+1}t_{i-1}-t_it_i=a^2t_{i-1}-at_{i-1}at_{i-1}=0\mod m $</p><p>上面这个式子就说明了 $ t_{i+1}*t_{i-1}-t_i*t_i $ 是p的倍数，那么我们只要改变i，得到两个值，求一下公因子，就可以求出来m</p><h2 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h2><h3 id="babyLCG"><a href="#babyLCG" class="headerlink" title="babyLCG"></a>babyLCG</h3><p><strong>题目</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag</span><br><span class="line"></span><br><span class="line">m = bytes_to_long(flag)</span><br><span class="line">bit_len = m.bit_length()</span><br><span class="line">a = getPrime(bit_len)</span><br><span class="line">b = getPrime(bit_len)</span><br><span class="line">p = getPrime(bit_len+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">seed = m</span><br><span class="line">result = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    seed = (a*seed+b)%p</span><br><span class="line">    result.append(seed)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">result = [34162247026397342478798569901414759621400, 48622925600981805953284319521855204943516, 873946493924376814098626588792484831751, 55835889122403142019357216062663278735799, 78197983655527534886328482392841803329879, 7826910556079551454813328357787595898220, 48420932174201345880210110234297855524418, 41702494213414751668850237022097487126943, 53964978232593731384060231097661907644428, 41614447441497057710125709202129649216700]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><p><strong>考点</strong>：LCG</p><p>只要知道关于LCG的三个基础公式，这道题就很简单，建议自己推导一遍</p><p>$ seed_i=（a*seed_{i-1}+b）\mod p $</p><p>设$ t_i=(seed_i-seed_{i-1})=a(seed_{i-1}-seed_{i-2})=a*t_{i-1}\mod p $</p><p>$ t_{i+1}*t_{i-1}-t_i*t_i=a^2t_{i-1}-a*t_{i-1}*a*t_{i-1}=0\mod p $</p><p>上面这个式子就说明了 $ t_{i+1}*t_{i-1}-t_i*t_i $ 是p的倍数，那么我们只要改变i，得到两个值，求一下公因子，就可以求出来p，p有了a也很好求</p><p>$ a=(seed_{i-1}-seed_{i-2})^{-1}*t_i\mod p $</p><p>a有了随便套一个式子就可以求b了，这样LCG的三个重要参数就都有了，第一个值逆回去就可以求出明文了</p><p>代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">result = [<span class="number">34162247026397342478798569901414759621400</span>, <span class="number">48622925600981805953284319521855204943516</span>, <span class="number">873946493924376814098626588792484831751</span>, <span class="number">55835889122403142019357216062663278735799</span>, <span class="number">78197983655527534886328482392841803329879</span>, <span class="number">7826910556079551454813328357787595898220</span>, <span class="number">48420932174201345880210110234297855524418</span>, <span class="number">41702494213414751668850237022097487126943</span>, <span class="number">53964978232593731384060231097661907644428</span>, <span class="number">41614447441497057710125709202129649216700</span>]</span><br><span class="line">t1=result[<span class="number">1</span>]-result[<span class="number">0</span>]</span><br><span class="line">t2=result[<span class="number">2</span>]-result[<span class="number">1</span>]</span><br><span class="line">t3=result[<span class="number">3</span>]-result[<span class="number">2</span>]</span><br><span class="line">t4=result[<span class="number">4</span>]-result[<span class="number">3</span>]</span><br><span class="line">t5=result[<span class="number">5</span>]-result[<span class="number">4</span>]</span><br><span class="line">t6=result[<span class="number">6</span>]-result[<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">p = gcd((t6*t4-t5*t5),(t5*t3-t4*t4))</span><br><span class="line"><span class="built_in">print</span>(p)</span><br><span class="line">a=(t3*gmpy2.invert(t2,p))%p</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">b=(result[<span class="number">1</span>]-a*result[<span class="number">0</span>])%p</span><br><span class="line">m = ((result[<span class="number">0</span>]-b)*gmpy2.invert(a,p))%p</span><br><span class="line"><span class="built_in">print</span>(m)</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(m))</span><br><span class="line"></span><br><span class="line"><span class="comment"># flag&#123;gratulieren&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 对称密码 </tag>
            
            <tag> CTF </tag>
            
            <tag> Crypto </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>椭圆曲线</title>
      <link href="/2024/11/24/%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF/"/>
      <url>/2024/11/24/%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="椭圆曲线"><a href="#椭圆曲线" class="headerlink" title="椭圆曲线"></a>椭圆曲线</h1><p>下面进行椭圆曲线相关知识的学习（基于crypto hack），中间穿插了一些数论和近世代数的几个知识点。</p><h2 id="一-预备知识"><a href="#一-预备知识" class="headerlink" title="一. 预备知识"></a>一. 预备知识</h2><p>学习的时候碰到了数论和近世代数的几个知识点，因为这两门我都没学完（尤其近世代数，完全没开始看），所有只能求尽量讲清楚吧。</p><h3 id="群"><a href="#群" class="headerlink" title="群"></a>群</h3><p>近世代数是主要研究代数系统（即非空集合）的学科，我们会在这个非空集合上定义满足一定条件的一种或多种二元运算（代数运算）。群是近世代数里面一个重要的概念。下面放一个课本上的定义。</p><p><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/42554774/1731940824047-20ebce66-31a9-433b-8dd2-0b15645a016f.jpeg" alt=""></p><p>简单解释一下就是在一个非空集合里定义一个二元运算，这个运算对于这个集合内的元素都满足</p><p>(1)<strong>结合率</strong>        (2)<strong>单位元</strong>    (3)<strong>逆元</strong></p><p>其实还有一个<strong>封闭性</strong>，就是运算结果还是在这个集合里。</p><p><strong>举一个例子</strong>，对于所有非零有理数（非空集合），和普通乘法（二元运算）构成了一个群，这个群满足结合律（是显然的），有单位元1（任意数与1做这个二元运算都等于它本身，且交换也满足），且对于任意一个a，都有$ \frac{1}{a} $与a做这个二元运算后等于单位元1（交换也满足)</p><h3 id="阿贝尔群（Abel-群）"><a href="#阿贝尔群（Abel-群）" class="headerlink" title="阿贝尔群（Abel 群）"></a>阿贝尔群（Abel 群）</h3><p>阿贝尔群是在群的基础上加上一个条件得到的，即<strong>交换率</strong></p><p>普通的群满足结合率，但是是不一定满足交换率的（目前我举不出具体例子，但是我是联想矩阵运算去理解的，不过可能不准确，感兴趣可以去查一下有没有具体例子）</p><p>所以一旦一个群满足<strong>交换律</strong>，这个群就是<strong>阿贝尔群</strong>，也叫<strong>交换群</strong></p><p>交换群的概念在后面椭圆曲线的运算上会有比较重要的运用。一旦满足结合律和交换律，那么运算时的次序就没那么重要了，这是<strong>基于椭圆曲线的DH密钥交换</strong>的一个重要基础。</p><h3 id="二次剩余"><a href="#二次剩余" class="headerlink" title="二次剩余"></a>二次剩余</h3><blockquote><p><a href="https://oi-wiki.org/math/number-theory/quad-residue/">https://oi-wiki.org/math/number-theory/quad-residue/</a></p></blockquote><p>是数论里面解同余方程那里的一个比较重要的概念，我们有以下定义：</p><p>令整数a，p满足（a，p）= 1，若存在x使得</p><p>$ x^{2} \equiv a\mod p $</p><p>则称a为模p的二次剩余，否则称a为模p的二次非剩余</p><p>这里面还是有挺多概念的东西的，但是上面博客里面讲的十分详细，可以看一看</p><p>所以这里我只强调一个特殊情况下的求解，即$ p \equiv 3\mod 4 $</p><p>满足上面所说情况，且我们知道a是p的二次剩余（怎么验证是不是二次剩余可以看看那个网站里，讲的很详细，数论我没学完，怕讲不清楚），就可以用下图方法来求一个解（可以求出x的值）</p><p><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/42554774/1732103648533-7e560906-4c9c-464a-a188-22d21af569ef.jpeg" alt=""></p><p>我们可以验证一下（自己推了一下，字有点丑，流泪猫猫）</p><p><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/42554774/1732104617404-6926d99e-b246-4eb0-af0d-9ce5036d251e.jpeg" alt=""></p><p>这里因为p+1是4的倍数，指数部分就是整数，所以会很好算。大家也可以试试自己推一下加深理解</p><p>至于其他的情况我还没学完（流泪猫猫头），拜托，数论太难了，但是那个网站里面真的很详细！可以仔细研读</p><h2 id="二-椭圆曲线入门"><a href="#二-椭圆曲线入门" class="headerlink" title="二. 椭圆曲线入门"></a>二. 椭圆曲线入门</h2><blockquote><p><a href="https://www.cnblogs.com/Kalafinaian/p/7392505.html">https://www.cnblogs.com/Kalafinaian/p/7392505.html</a></p></blockquote><p>要研究椭圆曲线就要知道维尔特拉斯方程（Weierstrass），这个方程的形式挺复杂的，感兴趣可以去查一下，然后我们主要运用它的普通形式，即</p><p>$ y^{2} = x^{3} +ax +b $</p><p>大致图像如下</p><p><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/42554774/1732106124295-85739cb9-d47b-46fa-ad13-8b30984d7734.jpeg" alt=""></p><p>像什么曲线每个点是非奇异的（光滑的）这样的性质我就不强调了，这里先知道长什么样就行</p><h3 id="椭圆曲线上的点加法"><a href="#椭圆曲线上的点加法" class="headerlink" title="椭圆曲线上的点加法"></a>椭圆曲线上的点加法</h3><p>我们知道椭圆曲线长什么样子后，就会期望在上面做一些运算，而它确实也提供了点加法运算。其原理是</p><p>假设A=（x1，y1）B=（x2，y2）是曲线上的两个点</p><p>那么P + Q的结果，就是<strong>PQ连线</strong>与椭圆曲线的交点<strong>R</strong>‘关于x轴的<strong>对称点R</strong>，如下图</p><p><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/42554774/1732106828572-99020cec-0105-4fc8-8f25-61689f557c4c.jpeg" alt=""></p><p>倘若是A + A，则我们考虑<strong>A点的切线</strong>，切线与椭圆曲线的交点R’关于x轴的<strong>对称点R</strong>即为结果，如下图</p><p><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/42554774/1732106983277-08aef9d8-3a9a-4f68-85ba-5fca4c0f413f.jpeg" alt=""></p><p>下面是一个具体的计算方法</p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/42554774/1732110476331-aeff5e4d-b778-4574-bc3e-4796656c3024.png" alt=""></p><h3 id="单位元和逆元"><a href="#单位元和逆元" class="headerlink" title="单位元和逆元"></a>单位元和逆元</h3><p>我们知道了椭圆曲线上的点加法运算后，我们会期望它具备群属性，以便于我们研究，这就要找到一个单位元O，使得</p><p>$ P +O=P $</p><p>但我们会发现没有一个点是满足这个条件的，那么我们就规定一个无穷远处的抽象点为单位元O（可以想象一下，一个点和无穷远处点的连线与曲线的交点还是这个点，满足条件）。这个无穷远点可以看成在y轴的正（负）半轴的无穷远处。这就有了单位元了。</p><p>有了单位元后我们来找逆元，即存在-P使得</p><p>$ P +（-P）=O $</p><p>其实回顾一下点加法的定义，我们很容易就能找到逆元就是关于x轴对称的那个点</p><p>例如R=（x3，y3）那么逆元R’=（x3，-y3）</p><p>也可以想象一下，这两个点的连线就是交在无穷远处，满足定义。</p><p>到这里，椭圆曲线上的点加法满足了群的所以性质，所以满足椭圆曲线的所有点加上一个无穷大的虚数点O，就构成了一个群。实际是，这个群也是满足交换率的，而满足交换率的群我们称之为阿贝尔群。</p><p>然后我们真正研究的时候，其实会希望在一个有限域内去研究，特别是素数域，所有我们对方程取模，这样以后，我们研究的就是一些对称的点，而不是连续的线</p><p>取模后逆元那里就有点小区别因为-y = p - y mod p，所以在有限域上的逆元表示成 R’（x，p - y）</p><h3 id="椭圆曲线构建离散对数问题（ECDLP）"><a href="#椭圆曲线构建离散对数问题（ECDLP）" class="headerlink" title="椭圆曲线构建离散对数问题（ECDLP）"></a>椭圆曲线构建离散对数问题（ECDLP）</h3><p>对于一个给定的椭圆曲线E，考虑椭圆曲线上的两个元素P和T，DL问题就是找到整数d，使得</p><p>$ P+P+\dots+P =dP=T $</p><p>很多时候，这个d就是私钥（如在ECC加密体系里）</p><p>（d*P就是椭圆曲线上的标量乘法，不过理解上还是要当成点加法的重复进行）</p><p>很多时候，知道T来求d是十分困难的，相当于一个离散对数问题。这确保了椭圆曲线加密的安全性。</p><h3 id="基于椭圆曲线的DH密钥交换"><a href="#基于椭圆曲线的DH密钥交换" class="headerlink" title="基于椭圆曲线的DH密钥交换"></a>基于椭圆曲线的DH密钥交换</h3><p>知道了椭圆曲线，我们要用来做一些和密码有关的事情</p><p>于是Alice和Bob协商做下面这些事</p><p><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/42554774/1732114355132-c04e044e-3946-4877-8a2a-275ef34626ed.jpeg" alt=""></p><p>两个人并用分别用自己随机生成的整数a和b与P（公开）做标量乘法得到A（公开）和B（公开），并把得到的值分别传给对方。</p><p>Alice得到B并用自己一开始的那个随机数a与B做标量乘法，得到T，Bob同理。两人把得到的T作为共享密钥。</p><p>对于Alice：T = a <em> （b </em> P）</p><p>对于Bob：  T =  b <em>（a </em> P）</p><p>因为椭圆曲线是一个阿贝尔群，所以运算次序对结果不影响，所以两个人得到的T相同，这确保了交换的可行性</p><p>这个过程里面，外人只可能得到P、A和B（这三个是公开的），但是仅仅通过这三个是算不出a和b的（即算不出T），这确保了这个交换过程的安全性。</p><p>这样Alice和Bob就可以用这个联合密钥去加密一些东西</p><p>之后Alice和Bob进行了思考，他们认为，既然椭圆曲线方程已知，那干嘛还要传递y呀？（欸！我有一个好主意）于是他们觉得只传递x就可以了，以实现高效传递</p><p>事实上只传递x也确实是可行的，我们考虑把已知的x值代入曲线方程就可以得到    y<sup>2</sup> = k mod p    的形式</p><p>其中k是带入x后的算出值，这就是一个二次剩余问题（数论的知识点），这样就是一个比较简单解决的问题（课本上这么说的，虽然在我看来还是很难），很容易就可以求出y。</p><p>但这里会有一个小问题，那就是如果数对（x，y）满足上面那个式子，那么显然的（x，p - y）也是满足的，所以实际生活中，我们在传递x坐标时，会附带传递一个指定y的奇偶性的标志位，以此来达到区分到底是哪个点（感兴趣可以查一下，挺复杂的，没看懂）</p><h2 id="三-题目"><a href="#三-题目" class="headerlink" title="三. 题目"></a>三. 题目</h2><h3 id="Efficient-Exchange"><a href="#Efficient-Exchange" class="headerlink" title="Efficient Exchange"></a>Efficient Exchange</h3><p><strong>题目</strong>：</p><p><code>E: Y2=X3 +497X+1768 mod 9739</code></p><p><code>Calculate the shared secret after Alice sends you x(QA)=4726, with your secret integer nB=6534.</code></p><p><code>Use the file to decode the flag decrypt.py</code></p><p><code>&#123;&#39;iv&#39;: &#39;cd9da9f1c60925922377ea952afc212c&#39;, &#39;encrypted_flag&#39;: &#39;febcbe3a3414a730b125931dccf912d2239f3e969c4334d95ed0ec86f6449ad8&#39;&#125;</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.Padding <span class="keyword">import</span> pad, unpad</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">is_pkcs7_padded</span>(<span class="params">message</span>):</span><br><span class="line">    padding = message[-message[-<span class="number">1</span>]:]</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">all</span>(padding[i] == <span class="built_in">len</span>(padding) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(padding)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decrypt_flag</span>(<span class="params">shared_secret: <span class="built_in">int</span>, iv: <span class="built_in">str</span>, ciphertext: <span class="built_in">str</span></span>):</span><br><span class="line">    <span class="comment"># Derive AES key from shared secret</span></span><br><span class="line">    sha1 = hashlib.sha1()</span><br><span class="line">    sha1.update(<span class="built_in">str</span>(shared_secret).encode(<span class="string">&#x27;ascii&#x27;</span>))</span><br><span class="line">    key = sha1.digest()[:<span class="number">16</span>]</span><br><span class="line">    <span class="comment"># Decrypt flag</span></span><br><span class="line">    ciphertext = <span class="built_in">bytes</span>.fromhex(ciphertext)</span><br><span class="line">    iv = <span class="built_in">bytes</span>.fromhex(iv)</span><br><span class="line">    cipher = AES.new(key, AES.MODE_CBC, iv)</span><br><span class="line">    plaintext = cipher.decrypt(ciphertext)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> is_pkcs7_padded(plaintext):</span><br><span class="line">        <span class="keyword">return</span> unpad(plaintext, <span class="number">16</span>).decode(<span class="string">&#x27;ascii&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> plaintext.decode(<span class="string">&#x27;ascii&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">shared_secret = ?</span><br><span class="line">iv = ?</span><br><span class="line">ciphertext = ?</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(decrypt_flag(shared_secret, iv, ciphertext))</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>考点</strong>：二次剩余，AES解密，ECDH的高效传递</p><p>这里主要考察对ECDH的高效传递的理解，Alice和Bob认为，椭圆曲线方程已知，那干嘛还要传递y呀？（欸！我有一个好主意）于是他们觉得只传递x就可以了。于是Alice给我发了一个x值，希望我能够以此知道共享密钥。并且Alice用共享密钥通过AES加密了flag</p><p>事实上只传递x也确实是可行的，我们考虑把已知的x值代入曲线方程就可以得到    y2 = k mod p    的形式</p><p>其中k是带入x后的算出值，这就是一个二次剩余问题（数论的知识点），这样就是一个比较简单解决的问题（课本上这么说的，虽然在我看来还是很难），很容易就可以求出y</p><p>但这里会有一个小问题，那就是如果数对（x，y）满足上面那个式子，那么显然的（x，p - y）也是满足的，所以实际生活中，我们在传递x坐标时，会附带传递一个指定y的奇偶性的标志位，以此来达到区分到底是哪个点（感兴趣可以查一下，挺复杂的，没看懂）</p><p>不过这道题会相对简单，因为我们最后只用x来做文章，所以y的值我们不关心，那么对于同一个x，即使两个人最后算出来的y不一样（一个是y，一个是p-y），经过运算后也不会影响x的值（可能画个图会好理解一点，两个对称的点，画斜率，与曲线的交点的x还是一样的），所以我们任意求出一个y来进行计算就行</p><p>现在来进行y的计算，题目给了提示p = 3 mod 4，这就可以运用二次剩余的知识点来解决，下面是原理图</p><p><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/42554774/1732085889491-3c78c1ef-668a-4c38-af7c-ba3b30ef22a4.jpeg" alt=""></p><p>这里直接用</p><p>$ y = a^\frac{p+1}{4}\mod p $</p><p>当然你也可以直接遍历p（遍历完总能找到一个解），因为这题p确实不大，两个办法都行，都可以求p（我一开始用的第二个，觉得不是预期解法才去查的第一个），求出y了就没什么难度了，套那个解密文件就行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sage</span></span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.Padding <span class="keyword">import</span> pad, unpad</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">is_pkcs7_padded</span>(<span class="params">message</span>):</span><br><span class="line">    padding = message[-message[-<span class="number">1</span>]:]</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">all</span>(padding[i] == <span class="built_in">len</span>(padding) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(padding)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decrypt_flag</span>(<span class="params">shared_secret: <span class="built_in">int</span>, iv: <span class="built_in">str</span>, ciphertext: <span class="built_in">str</span></span>):</span><br><span class="line">    <span class="comment"># Derive AES key from shared secret</span></span><br><span class="line">    sha1 = hashlib.sha1()</span><br><span class="line">    sha1.update(<span class="built_in">str</span>(shared_secret).encode(<span class="string">&#x27;ascii&#x27;</span>))</span><br><span class="line">    key = sha1.digest()[:<span class="number">16</span>]</span><br><span class="line">    <span class="comment"># Decrypt flag</span></span><br><span class="line">    ciphertext = <span class="built_in">bytes</span>.fromhex(ciphertext)</span><br><span class="line">    iv = <span class="built_in">bytes</span>.fromhex(iv)</span><br><span class="line">    cipher = AES.new(key, AES.MODE_CBC, iv)</span><br><span class="line">    plaintext = cipher.decrypt(ciphertext)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> is_pkcs7_padded(plaintext):</span><br><span class="line">        <span class="keyword">return</span> unpad(plaintext, <span class="number">16</span>).decode(<span class="string">&#x27;ascii&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> plaintext.decode(<span class="string">&#x27;ascii&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p = <span class="number">9739</span></span><br><span class="line">y = <span class="built_in">int</span>(((<span class="number">4726</span>**<span class="number">3</span>+<span class="number">497</span>*<span class="number">4726</span>+<span class="number">1768</span>)**((p+<span class="number">1</span>)//<span class="number">4</span>))%p)</span><br><span class="line"><span class="built_in">print</span>(y)</span><br><span class="line">E = EllipticCurve(GF(<span class="number">9739</span>),[<span class="number">497</span>,<span class="number">1768</span>])</span><br><span class="line">P = E([<span class="number">4726</span>,<span class="number">6287</span>])</span><br><span class="line">shared_secret = (<span class="number">6534</span>*P)[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(shared_secret)</span><br><span class="line"></span><br><span class="line">iv = <span class="string">&#x27;cd9da9f1c60925922377ea952afc212c&#x27;</span></span><br><span class="line">ciphertext = <span class="string">&#x27;febcbe3a3414a730b125931dccf912d2239f3e969c4334d95ed0ec86f6449ad8&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(decrypt_flag(shared_secret, iv, ciphertext))</span><br><span class="line"> </span><br><span class="line"><span class="comment"># crypto&#123;3ff1c1ent_k3y_3xch4ng3&#125;</span></span><br></pre></td></tr></table></figure><p><strong>flag</strong>：crypto{3ff1c1ent_k3y_3xch4ng3}</p><h2 id="四-总结"><a href="#四-总结" class="headerlink" title="四. 总结"></a>四. 总结</h2><p>到这里，我们对椭圆曲线就有了简单认识，但其实还并没有接触到真正的一些加密算法，比如说ECC（但是原理懂了这个也就很好理解了，所以问题不大）。而且椭圆曲线加密也不是绝对安全的，后面还要学习各种攻击方式（像之前我瞥到的光滑数攻击），总的来说，道阻且长。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> CTF </tag>
            
            <tag> Crypto </tag>
            
            <tag> 椭圆曲线 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>格入门</title>
      <link href="/2024/11/15/%E6%A0%BC%E5%85%A5%E9%97%A8/"/>
      <url>/2024/11/15/%E6%A0%BC%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="格入门"><a href="#格入门" class="headerlink" title="格入门"></a>格入门</h1><p>这两周就是学习了一些格的基本知识，因为临近期中考，学的有点仓促，但总算是了解了一点，我把学到知识点也写了写，作业的解题思路会放在后面题目运用那里，可以跳转去看</p><h2 id="一-预备知识"><a href="#一-预备知识" class="headerlink" title="一. 预备知识"></a>一. 预备知识</h2><p>要学习格，是得有线性代数的知识才行的。（反正我看到那些矩阵向量什么的就回忆起上学期被线代支配的恐惧）因为我上学期线代学的也不好，忘的也差不多了，加上这里篇幅也有限，我也只能点一下cryptohack上面提到的一些线代知识，目前来看够用，不过强烈建议系统的学习一下线代。</p><h3 id="向量和向量空间"><a href="#向量和向量空间" class="headerlink" title="向量和向量空间"></a>向量和向量空间</h3><p>以二维向量空间举例，我们可以任意取一个点A，连接原点O和A点，这就构成成了一个向量。我们也可以用A点的坐标来表示这个向量,就像这样<strong>v=</strong>(x,y)</p><p>向量满足加减、数乘和点积运算，下面举例说明（加粗表示向量）</p><p><strong>v</strong>=(a , b)，<strong>w</strong>=(c , d)</p><p><strong>v</strong> + <strong>w</strong> = （a + c，b + d） （减法同理）</p><p>c * <strong>w </strong>= （c <em> a， c </em> b ）      （数乘）</p><p><strong>v</strong> * <strong>w</strong> = a * c + b * d        （点积）</p><p>多维是同理的</p><p>然后向量还分行向量和列向量，可以简单理解为行向量就是在纸上横着写的向量（确信），列向量就是在纸上竖着写的向量（确信）</p><h3 id="向量大小和基"><a href="#向量大小和基" class="headerlink" title="向量大小和基"></a>向量大小和基</h3><p>$ \begin{Vmatrix}v\ \end{Vmatrix} $用来表示向量的长度，其大小是$ \begin{align}<br>\sqrt{v*v}<br>\end{align} $(高中应该就有这个知识点的)</p><p>这里还有一些关于线性独立的知识点，比如向量空间里有一组向量$ v_i $</p><p>满足方程$ \begin{align} a_1⋅v_1+a_2⋅v_2+…+a_k⋅v_k=0 \end{align} $</p><p>当$ a_i<br> $全为零时等式才成立，那么这k个向量就是线性无关的，反之线性相关</p><p>而向量空间的基底会要求是一组线性无关的向量，当我们有了这一组向量基，我们就可以用这个基底来表示这个向量空间中的任意向量</p><p>拿二维空间举例</p><p>$ \begin{align} i=(0,1)\end{align} $ $ \begin{align} j = (1,0)\end{align} $就是一组线性无关的基底，这两个向量就可以表示整个二维平面</p><p>其实了解一下矩阵会更有帮助，但是我就不介绍了（有试着想写一下，但是发现讲不清楚，还是留给大家的线代老师吧）</p><p><a href="https://www.bilibili.com/video/BV1aW411Q7x1/?spm_id_from=333.1007.top_right_bar_window_custom_collection.content.click&amp;vd_source=a01a62f772bf2e577e11004dfef0bde1">线代课程</a>（放一个宋浩老师线代课的链接吧）</p><h3 id="施密特正交化"><a href="#施密特正交化" class="headerlink" title="施密特正交化"></a>施密特正交化</h3><p>这个东西感觉只可意会不可言传了，我就放个图，<del>大家自己悟吧</del>（主要我也不知道为什么，只会套公式）</p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/42554774/1730734509235-c52c5bf3-4af8-4401-9542-e0c44579ad40.png" alt=""></p><p>这个正交化就是可以构造一个正交基，正交的概念就是向量相互垂直，上面我举的二维空间的基底就是一组正交基，因为点乘为零（两个向量垂直，点乘为零）</p><p>正交化会有挺多好处的（应该，反正没学懂，就会套公式）</p><p>这个就是解决一下crypto hack上的一道题，其他地方好像和那个高斯晶格规约有点像，但那里我们会四舍五入，所以还是有点区别的</p><p>下面放一个求解代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sage</span></span><br><span class="line"><span class="keyword">from</span> sympy.matrices <span class="keyword">import</span> Matrix, GramSchmidt</span><br><span class="line">l = [Matrix([<span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>, -<span class="number">1</span>]), Matrix([<span class="number">2</span>, <span class="number">1</span>, -<span class="number">3</span>, <span class="number">4</span>]), Matrix([<span class="number">1</span>, <span class="number">0</span>, -<span class="number">2</span>, <span class="number">7</span>]), Matrix([<span class="number">6</span>, <span class="number">2</span>, <span class="number">9</span>, -<span class="number">5</span>])]</span><br><span class="line"><span class="comment"># 注意：将数据转为Matrix格式，否则调用GramSchmidt函数会报错！</span></span><br><span class="line"><span class="comment"># 返回未单位化结果</span></span><br><span class="line">o1 = GramSchmidt(l) <span class="comment"># 注意：orthonormal默认为False，不执行单位化操作</span></span><br><span class="line"><span class="built_in">print</span>(o1)</span><br><span class="line"><span class="comment"># 返回单位化结果</span></span><br><span class="line">o2 = GramSchmidt(l,orthonormal=<span class="literal">True</span>) <span class="comment"># 注意：orthonormal设为True，执行单位化操作</span></span><br><span class="line"><span class="built_in">print</span>(o2)</span><br></pre></td></tr></table></figure><h2 id="二-格的初步认识"><a href="#二-格的初步认识" class="headerlink" title="二. 格的初步认识"></a>二. 格的初步认识</h2><blockquote><p>参考文档</p><p><a href="https://tover.xyz/p/LLL-attack-equation/">格攻击之小未知数方程求解入门——原理与例子 | Tover’s Blog</a></p><p>这个博客里讲的真的很好！</p></blockquote><h3 id="格定义"><a href="#格定义" class="headerlink" title="格定义"></a>格定义</h3><p>这里先放一个课本上的定义</p><p><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/42554774/1731031878819-11983b36-e144-4468-acf9-e5961f9a255a.jpeg" alt=""></p><p>可能看起来比较难懂，但是我们还是从上面那个二维平面出发，我们已经知道了我们可以用一组基底来表示整个二维平面（基底不唯一），我们是通过把这两个向量乘以不同的系数后相加得到的，那么想象一下，我们如果令系数只为整数会怎么样呢？</p><p>这个时候，我们通过这个基底，就只能得到空间里的一些点，那么这个就是一个整数格</p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/42554774/1731033008919-7ec8338d-05df-4c71-8650-b0c08eb23041.png" alt=""></p><p>我们把基底写成一个矩阵，那么就可以得到上面定义里的写法，同时这个矩阵的<strong>行列式</strong>的值，叫做这个<strong>基本域的容积</strong></p><p>同时如果我们扩展到n维向量空间，就是定义里的表示</p><h3 id="格常见问题"><a href="#格常见问题" class="headerlink" title="格常见问题"></a>格常见问题</h3><p>通过上面我们简单了解了一下格是什么，长什么样，那么就要考虑能拿它干什么</p><p>这就得提一下格上的两个常见问题，一个是最短向量问题（SVP），另一个是最近向量问题（CVP）</p><p>SVP是指我们要在格L上找到一个最短的非零向量$ v $，使得$ \begin{Vmatrix}v\ \end{Vmatrix} $最小</p><p>可能在二维空间里你一下就可以看出来哪个是最短的向量，但是一旦扩展到多维时，这就是一个困难的问题了。这里补一个课本上看到的存在性定理，感兴趣可以看一下</p><p><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/42554774/1731034540889-80fdac9a-282b-49e1-b5ab-8cbfa0c984fe.jpeg" alt=""></p><p>那么为了找到这个最短向量，我们有以下规约</p><h4 id="高斯格基规约"><a href="#高斯格基规约" class="headerlink" title="高斯格基规约"></a>高斯格基规约</h4><p>这个是适用于二维平面，通过算法可以找到二维平面里的最短向量，感觉是LLL的特殊情况（因为好像sage上用LLL的算法也可以解这个），下面放个算法图</p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/42554774/1731034151787-c932dad2-cf3a-40a6-bd0a-392a94db460c.png" alt=""></p><p>如果你仔细看一下的话就会发现这个算法和那个施密特正交化是有一点像的，但是我们知道在施密特正交化里，m不一定是整数，这就会导致得到的向量不在格里，所以我们对m四舍五入取整，这样来得到</p><h4 id="LLL格基规约"><a href="#LLL格基规约" class="headerlink" title="LLL格基规约"></a>LLL格基规约</h4><p>原理其实感觉差不了太多，就是去找最短向量</p><p>这里的运用就是根据关系找到一个基底的矩阵，矩阵中所有数是已知的，然后我们要求解的向量（要求解的未知数构成的向量）是一些数作用在这个矩阵后得到，这个向量就在格上，然后我们期望这个向量是最短向量，以此来求解未知数，下面放一个newstar时候用过的代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># sage</span><br><span class="line">from gmpy2 import *</span><br><span class="line">from Crypto.Util.number import *</span><br><span class="line">#from tqdm import *</span><br><span class="line"> </span><br><span class="line">a = 134812492661960841508904741709490501744478747431860442812349873283670029478557996515894514952323891966807395438595833662645026902457124893765483848187664404810892289353889878515048084718565523356944401254704006179297186883488636493997227870769852726117603572452948662628907410024781493099700499334357552050587</span><br><span class="line">b = 1522865915656883867403482317171460381324798227298365523650851184567802496240011768078593938858595296724393891397782658816647243489780661999411811900439319821784266117539188498407648397194849631941074737391852399318951669593881907935220986282638388656503090963153968254244131928887025800088609341714974103921219202972691321661198135553928411002184780139571149772037283749086504201758438589417378336940732926352806256093865255824803202598635567105242590697162972609</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">mat = [[b,0],[a,1]]</span><br><span class="line">M = Matrix(ZZ,mat)</span><br><span class="line">qq,pp= M.LLL()[0]   # 最短向量</span><br><span class="line"> </span><br><span class="line">print(pp)</span><br><span class="line">print(qq)</span><br></pre></td></tr></table></figure><p>然而要运用LLL算法是有条件的，就是我们要通过这个算法来求最短向量，那么我们要求的向量起码得是最短向量，这就得看一下上面的最短向量存在定理，我们要求解的向量长度满足条件后才是最短向量，才可以用LLL算法，然后格的维数也不能太高，不然准确度不高，耗时也会长。</p><p>具体解一下题应该就能理解，可以往后看</p><h2 id="三-题目及运用"><a href="#三-题目及运用" class="headerlink" title="三. 题目及运用"></a>三. 题目及运用</h2><p>我们来具体分析一下下面这一题</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> getPrime, inverse, bytes_to_long, long_to_bytes</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> Tools.scripts.var_access_benchmark <span class="keyword">import</span> make_nonlocal_writer</span><br><span class="line"></span><br><span class="line">FLAG = <span class="string">b&#x27;crypto&#123;?????????????????????&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gen_key</span>():</span><br><span class="line">    q = getPrime(<span class="number">512</span>)</span><br><span class="line">    upper_bound = <span class="built_in">int</span>(math.sqrt(q // <span class="number">2</span>))</span><br><span class="line">    lower_bound = <span class="built_in">int</span>(math.sqrt(q // <span class="number">4</span>))</span><br><span class="line">    f = random.randint(<span class="number">2</span>, upper_bound)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        g = random.randint(lower_bound, upper_bound)</span><br><span class="line">        <span class="keyword">if</span> math.gcd(f, g) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    h = (inverse(f, q)*g) % q</span><br><span class="line">    <span class="keyword">return</span> (q, h), (f, g)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encrypt</span>(<span class="params">q, h, m</span>):</span><br><span class="line">    <span class="keyword">assert</span> m &lt; <span class="built_in">int</span>(math.sqrt(q // <span class="number">2</span>))</span><br><span class="line">    r = random.randint(<span class="number">2</span>, <span class="built_in">int</span>(math.sqrt(q // <span class="number">2</span>)))</span><br><span class="line">    e = (r*h + m) % q</span><br><span class="line">    <span class="keyword">return</span> e</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decrypt</span>(<span class="params">q, h, f, g, e</span>):</span><br><span class="line">    a = (f*e) % q</span><br><span class="line">    m = (a*inverse(f, g)) % g</span><br><span class="line">    <span class="keyword">return</span> m</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public, private = gen_key()</span><br><span class="line">q, h = public</span><br><span class="line">f, g = private</span><br><span class="line"></span><br><span class="line">m = bytes_to_long(FLAG)</span><br><span class="line">e = encrypt(q, h, m)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;Public key: <span class="subst">&#123;(q,h)&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;Encrypted Flag: <span class="subst">&#123;e&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure><p>因为我在newstar的时候有简单看看格，那个时候认识不够全面，以为只要构造出一个矩阵就行，所有下面分享一个错误思路</p><p>就是我一看到就定睛在e = (r*h + m) % q这个式子上</p><p>然后e - m = q*k + r*h</p><p>所以$ \begin{align}(k,r)\begin{pmatrix}q&amp;0 \\ h&amp;1 \end{pmatrix} =(e-m,r)\end{align} $</p><p>我们写成  v*B = w</p><p><del>想着这个式子构造出格，直接求明文，简单简单</del></p><p>但是这个思路是错误的，因为没有考虑我们通过（k，r）作用到矩阵后得到的这个向量到底是不是最短向量</p><p>我们可以算一下$ \begin{Vmatrix}w\ \end{Vmatrix} $和$ \sqrt2{det(B)}^\frac{1}{2} $（根据上面最短向量存在定理比较一下，就可以判断w是不是最短向量），其实这里没有明显的算出值（因为我们不知道m，但大概率这个w的长度是大的）所以大小都不知道，我们根本无法判断w是不是最短向量，所有LLL规约求出来的不是w。这里根本还是因为我违背这种题目的初衷，就是本来是用格攻击求小未知数，但是我求的不是小未知数</p><p><strong>上面错误思路告诉我们，不是所有的式子都可以通过构造格来求解，只有当我们要求解的未知数所构成的向量恰好在格上，且这个向量恰好是最短向量时（小未知数），才可以求解</strong></p><p>那么下面来看正确做法</p><p>既然上面那个式子构造出来的格不对，那么我们转战另一个式子</p><p>h = (inverse(f, q)*g) % q</p><p>即 h = k * q + f<sup> -1</sup> * g mod（q）</p><p>这么看有个f关于q的逆元，那么两边乘个f，得到</p><p>h * f = k \<em> q \</em> f + g  </p><p>我们试着移项得到 g = h*f + k<sub>1</sub> *q*f   （为什么要移项？因为我们要把已知的两个数h和q放在一边，来构造矩阵）</p><p>这个时候就很清晰了，加上  kf * 0 + f = f （感觉是一类比较固定的式子，一个恒等式，方便构造矩阵）这个式子就可以得到</p><p>$ \begin{align}(k_1f,f) \begin{pmatrix} q&amp;0 \\ h&amp;1 \end{pmatrix} =(g,f)\end{align} $</p><p>我们写成  v*B = w</p><p>这个时候我们再验证一下$ \left \| w \right \| = \sqrt{f^{2} * g^{2}} ＜\sqrt{(\frac{q}{2})^{2} *(\frac{q}{2})^{2}  } ＜\sqrt{2}\sqrt{q}＜\sqrt{2} det(B)^{\frac{1}{2} } $</p><p>f和g小于q的一半应该是显然的，因为题目定义的时候就是小于的，不理解可以返回去再看一下题目定义f和g那里</p><p>这个时候w大概率就是最小向量，这个时候，我们运用LLL格级规约就可以求出w，即密钥，然后通过解密代码（题目已给）就可以求出明文</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sage</span></span><br><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#from tqdm import *</span></span><br><span class="line"></span><br><span class="line">a = <span class="number">2163268902194560093843693572170199707501787797497998463462129592239973581462651622978282637513865274199374452805292639586264791317439029535926401109074800</span></span><br><span class="line"></span><br><span class="line">b = <span class="number">7638232120454925879231554234011842347641017888219021175304217358715878636183252433454896490677496516149889316745664606749499241420160898019203925115292257</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mat = [[b,<span class="number">0</span>],[a,<span class="number">1</span>]]</span><br><span class="line">M = Matrix(ZZ,mat)</span><br><span class="line">g,f= M.LLL()[<span class="number">0</span>] </span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(f)</span><br><span class="line"><span class="built_in">print</span>(g)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decrypt</span>(<span class="params">q, h, f, g, e</span>):</span><br><span class="line">    a = (f*e) % q</span><br><span class="line">    m = (a*inverse(f, g)) % g</span><br><span class="line">    <span class="keyword">return</span> m</span><br><span class="line">    </span><br><span class="line">Publickey=(<span class="number">7638232120454925879231554234011842347641017888219021175304217358715878636183252433454896490677496516149889316745664606749499241420160898019203925115292257</span>, <span class="number">2163268902194560093843693572170199707501787797497998463462129592239973581462651622978282637513865274199374452805292639586264791317439029535926401109074800</span>)</span><br><span class="line">q = Publickey[<span class="number">0</span>]</span><br><span class="line">h = Publickey[<span class="number">1</span>]</span><br><span class="line">e = <span class="number">5605696495253720664142881956908624307570671858477482119657436163663663844731169035682344974286379049123733356009125671924280312532755241162267269123486523</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">g = <span class="number">43997957885147078115851147456370880089696256470389782348293341937915504254589</span></span><br><span class="line"></span><br><span class="line">f = <span class="number">47251817614431369468151088301948722761694622606220578981561236563325808178756</span></span><br><span class="line"></span><br><span class="line">m =decrypt(q, h, f, g, e)</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(m))</span><br></pre></td></tr></table></figure><p>就可以解出明文了</p><h2 id="四-总结"><a href="#四-总结" class="headerlink" title="四. 总结"></a>四. 总结</h2><p>最后简单总结一下用格解小未知数方程的过程</p><p>首先找到一个式子，转化成一个向量（感觉可以叫系数向量，因为就是这个向量作用于矩阵，以此来得到一个在格上的向量）乘以一个矩阵（基底），得到另一个向量（我们要求解的小未知数所构成的向量）的形式</p><p>然后可以简单判断一下是不是最短向量（根据最短向量存在定理）</p><p>之后就可以用LLL规约解出最短向量，这个向量里的就是我们要求的小未知数了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> CTF </tag>
            
            <tag> Crypto </tag>
            
            <tag> 格 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>个人博客搭建</title>
      <link href="/2024/11/02/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
      <url>/2024/11/02/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="个人博客搭建"><a href="#个人博客搭建" class="headerlink" title="个人博客搭建"></a>个人博客搭建</h1><blockquote><p>参考文章</p><p><a href="https://blog.fiveth.cc/p/bb32/">https://blog.fiveth.cc/p/bb32/</a></p><p><a href="https://www.bilibili.com/video/BV1Ju4m1c7WR/?spm_id_from=333.1007.top_right_bar_window_default_collection.content.click&amp;vd_source=a01a62f772bf2e577e11004dfef0bde1">【零成本】Hexo个人博客搭建教程 | 无需服务器_哔哩哔哩_bilibili</a></p></blockquote><p>记录一下个人博客的搭建过程，我的是Hexo框架，参考的就是上面的视频和博客，中间有一点问题，然后我看了另外一位大佬的博客解决的，等到具体步骤具体说，然后我搭好的结果就是<a href="https://mondaying.cn">mondaying.cn</a>（就是简单搞出来，主题什么的还是没搞懂），下面就简单讲一下过程。</p><h2 id="一-准备工作"><a href="#一-准备工作" class="headerlink" title="一. 准备工作"></a>一. 准备工作</h2><blockquote><p>参考文章</p><p><a href="https://www.cnblogs.com/liuqiyun/p/8133904.html">https://www.cnblogs.com/liuqiyun/p/8133904.html</a></p><p><a href="https://www.cnblogs.com/xueweisuoyong/p/11914045.html">https://www.cnblogs.com/xueweisuoyong/p/11914045.html</a></p></blockquote><ol><li>首先就是要下载node.js<br> <a href="https://nodejs.org/en">node链接</a><br> 就到官网下载就行，我是下载的挺顺的，没什么差池，第一篇文章讲的挺详细的，照着做就行</li></ol><ol><li>然后下载git<br> <a href="https://git-scm.com/downloads">git链接</a><br> 也是官网下载，我遇到的问题就是下载很慢，得有快半个小时多才下载好，其他没什么问题，可以参考上面放的第二篇文章</li></ol><p>下载完上面两个后可以打开cmd检查一下是不是安装成功（输入下图三行代码），成功的话就是下面这个界面</p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/42554774/1730260613488-26cebe87-d4f0-4a1c-9cd4-8e1a9cb4bd68.png" alt=""></p><ol><li>然后就是下载hexo<br> 得用管理员身份打开cmd<br> <img src="https://cdn.nlark.com/yuque/0/2024/png/42554774/1730260734784-72d18db3-7c13-46d9-8a47-1cf5cfb9a0c2.png" alt=""><br> 然后输入下面这串代码下载hexo，这里我做完忘记截屏了，不过没报错应该就是成功了（确信)</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure><ol><li>接着就是注册一个GitHub账号，这个我上个假期搞的，也就没截屏了，好像也挺顺的，就是取名字那里花了挺久（为什么想取的名字全被注册啊，恼）  </li></ol><h2 id="二-搭建仓库"><a href="#二-搭建仓库" class="headerlink" title="二. 搭建仓库"></a>二. 搭建仓库</h2><p>这里就要用到我们之前注册的GitHub账号。主页的左边就有Create repository，点后就是下图<br><img src="https://cdn.nlark.com/yuque/0/2024/png/42554774/1730262710074-a072ec7b-ab05-4936-bb98-6b3cbe57b849.png" alt=""></p><p>这里就得注意了，仓库名必须按照格式填写，即：<strong>用户名.github.io</strong>，比如我的用户名是Mondaying（这里的name和user name好像是有区别的，得用user name），那么仓库名必须填Mondaying.github.io</p><p>仓库也必须是public的，然后那个Add a README file也点上（这个我也不知道为什么，反正跟着点就对了）</p><p>然后就创建好了，放着备用</p><h2 id="三-配置ssh-key"><a href="#三-配置ssh-key" class="headerlink" title="三. 配置ssh key"></a>三. 配置ssh key</h2><ol><li>在桌面空白处右键，点显示更多选项，打开git bash，粘贴下面这串代码，记得把邮箱改成自己的，然后敲四下键盘</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;邮件地址&quot;</span><br></pre></td></tr></table></figure><ol><li>之后就去C盘用户文件夹里的某个文件夹里（因为好像每个人的都不一样，反正我和那个up主的就不一样，得找一下）去找下面这个文件夹<br> <img src="https://cdn.nlark.com/yuque/0/2024/png/42554774/1730263737700-ac2180c4-8bd6-41f6-bc1d-99cb4e1f62ee.png" alt=""><br> 点开里面找到id_rsa.pub打开，全选复制</li></ol><ol><li>然后我们打开GitHub，打开Settings</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2024/png/42554774/1730264452254-9a4f4209-202a-4001-a148-02e26c07dffd.png" alt=""></p><p>点进去后在左边找到SSH and GPG keys，然后点击new ssh key，title那里随便取名，key那里粘贴刚刚复制的东西，创建就可以了<br><img src="https://cdn.nlark.com/yuque/0/2024/png/42554774/1730264596585-f4a79952-4151-4467-9825-9ba0870d06bd.png" alt=""></p><ol><li>回到桌面，打开git bash，输入下面这串代码，验证一下有没有添加成功</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><p>回车后记得输入yes，这里也忘记结果截屏了，还是没报错就成功（确信）</p><h2 id="四-本地部署"><a href="#四-本地部署" class="headerlink" title="四. 本地部署"></a>四. 本地部署</h2><ol><li><p>首先选择一个合适的位置创建一个文件夹，用来放置博客文件<br> <img src="https://cdn.nlark.com/yuque/0/2024/png/42554774/1730265201600-39609800-8918-4b0f-9836-193245214bd8.png" alt=""><br> 打开文件夹，在文件夹里右键打开git bash，输入hexo init进行初始化（如果不行就输入npx hexo init）注意，输入这行代码后文件夹里应该得冒出来东西才对，就是得有一些文件的，但是像我就是输入后文件夹里没有东西，虽然没报错（我记得当时是没报错)，但是是有问题的，我的解决方法也挺简单的，就是退出去，删除文件夹，然后重新弄，如果显示文件夹被占用无法删除那就重启电脑。<br> 反正后面几步也一样，一旦有问题就删除文件夹重新来，多来几次就可以了  </p></li><li><p>输入npx hexo install安装  </p></li><li><p>输入npx hexo g生成<br> 我记得这里我卡了挺久，就是输入后它就是没反应，但是多等一会就有了，如果过了很久都不行就按上面方法，删除文档重新来  </p></li><li><p>输入npx hexo s本地部署<br> 这之后我们就会得到一个链接，打开就可以看到我们的博客在本地部署啦，这就是我们的博客了，这里记得回到命令行点ctrl+c停止本地服务器，然后再关闭窗口，否则你就得又重启你的电脑了（恼）因为不这样后面再打开就会显示被占用</p></li></ol><h2 id="五-上线博客"><a href="#五-上线博客" class="headerlink" title="五. 上线博客"></a>五. 上线博客</h2><ol><li><p>首先用记事本打开博客文件夹里的下面这个文件<br> <img src="https://cdn.nlark.com/yuque/0/2024/png/42554774/1730267044848-ab487849-6676-4475-beef-3aa05005dcb9.png" alt=""><br> 当然用vscode打开整个文件夹再进行操作最好，我这里图个方便.  </p></li><li><p>打开之后拖到最底下，把deploy以及后面的全删掉，复制粘贴下面这段</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: git@github.com:user name/user name.github.io.git</span><br><span class="line">  branch: main</span><br></pre></td></tr></table></figure><p>记得把user name换成我们的名字</p><ol><li>然后桌面打开git bash，输入npx hexo g生成<br> 这里我弹了一个报错，显示没找到git，但是视频里也没讲为什么<br> <img src="https://cdn.nlark.com/yuque/0/2024/png/42554774/1730127721025-d9a4a9da-26b8-45fa-a33a-2532af77ec07.png" alt=""><br> 然后我又找到了一位大佬的博客<a href="https://www.fomal.cc/posts/e593433d.html">https://www.fomal.cc/posts/e593433d.html</a>就是这篇，然后输入下面这串代码就好了</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><ol><li><p>然后输入npx hexo d上传<br> 然后这里因为是第一次使用，所以要填一下配置，按照下图输入两个代码就行，记得把邮箱和名字改成自己的（我记得代码它会提示你，你到上面复制下来改一下就行）<br> <img src="https://cdn.nlark.com/yuque/0/2024/png/42554774/1730127867283-0a8ecd95-96ea-49b3-84ed-a6e04bdb5f18.png" alt="">  </p></li><li><p>配置完了以后再次输入npx hexo d上传，会弹出一个GitHub登录窗口，进行登录就可以了<br> <img src="https://cdn.nlark.com/yuque/0/2024/png/42554774/1730128118033-25b37a7d-ad8b-4146-bebb-58dd54e16c2e.png" alt=""><br> 成功后就是下图这样<br> <img src="https://cdn.nlark.com/yuque/0/2024/png/42554774/1730128563189-14de6c61-d288-4f12-8ca0-81a3b3406730.png" alt="">  </p></li><li><p>我们回到GitHub上看到仓库那边那个黄圈圈变成绿勾后就可以输入链接访问了</p></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2024/png/42554774/1730128630964-3e3913b8-4c7c-43ec-8926-cb05b6ecbea5.png" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/42554774/1730128697211-575a3abb-1d12-4cf2-a2ad-5b43f796b00d.png" alt=""></p><h2 id="六-vercel部署和绑定域名"><a href="#六-vercel部署和绑定域名" class="headerlink" title="六. vercel部署和绑定域名"></a>六. vercel部署和绑定域名</h2><blockquote><p><a href="https://www.bilibili.com/video/BV1Ke4y1v7Qr/?spm_id_from=333.1007.top_right_bar_window_history.content.click&amp;vd_source=a01a62f772bf2e577e11004dfef0bde1">第2期：Vercel部署并绑定自定义域名+安装Butterfly主题_哔哩哔哩_bilibili</a></p></blockquote><p>这一步其实也不是必须的，就是我看视频里搞了跟着随便弄的，其实我也不是很懂，因为其实到上面第五步博客就已经搭好了，这里我就简单讲讲我干了什么，不细说</p><p>第一个vercel部署，好像是会让速度更快，而且vercel好像还可以搞图床（虽然现在还不太懂图床是什么），是可以搞一下的，跟着上面那个视频来就行，挺简单的，不难</p><p>第二个就是绑定自己的域名，因为我们这个博客得绑定一个国内的域名才能在国内访问（好像是），然后就是买一个，绑一下就行，也挺简单的，上面视频讲得也很详细</p><p><strong>这样我们的博客就搭建好啦，之后就是美化什么的，希望大家都能顺利搭建！</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一篇文章</title>
      <link href="/2024/10/29/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/"/>
      <url>/2024/10/29/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="这是我的第一篇文章，嘻嘻"><a href="#这是我的第一篇文章，嘻嘻" class="headerlink" title="这是我的第一篇文章，嘻嘻"></a>这是我的第一篇文章，嘻嘻</h2>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
